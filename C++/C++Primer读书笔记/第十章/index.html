<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="王秋鹏">
    
    <title>
        
            C++ Primer 第十章 泛型算法 |
        
        wangqp
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                wangqp
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/c/"
                            >
                                C++
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/Codeing/"
                            >
                                数据结构与算法
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                            >
                                系统编程与网络编程
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%95%B0%E6%8D%AE%E5%BA%93/"
                            >
                                数据库
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E9%A1%B9%E7%9B%AE"
                            >
                                项目
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/c/">C++</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/Codeing/">数据结构与算法</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">系统编程与网络编程</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E9%A1%B9%E7%9B%AE">项目</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">C++ Primer 第十章 泛型算法</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">王秋鹏</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2021-09-10 00:00:00</span>
        <span class="mobile">2021-09-10 00:00</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>标准库提供了一组算法，用来处理不同的容器</p>
<h5 id="10-1-概述"><a href="#10-1-概述" class="headerlink" title="10.1 概述"></a><strong>10.1 概述</strong></h5><p>大多数算法定义在头文件 algorithm 中，部分在 numeric 中</p>
<p>这些算法不直接操作容器，而是遍历两个迭代器指定的一个元素范围来进行操作。</p>
<p>算法不会改变容器的大小。</p>
<h5 id="10-2-初识泛型算法"><a href="#10-2-初识泛型算法" class="headerlink" title="10.2 初识泛型算法"></a><strong>10.2 初识泛型算法</strong></h5><p>标准库提供了超过100个算法。</p>
<p>标准库算法都对一个范围内的元素进行操作，此元素范围称为“输入范围”</p>
<p>部分算法从两个序列中读取元素，两个序列不必相同（如vector和list），序列中的元素也不必相同（如double和int），要求是只要能比较两种元素即可。</p>
<p><strong>几种假定</strong></p>
<p>操作两个序列的算法有的接受三个迭代器：前两个表示第一个序列的元素范围，第三个表示第二个序列的元素范围。这种情况假定第二个序列至少与第一个一样长。</p>
<p>向目的位置迭代器写入 n 个数据的算法假定目的位置足够大（大于等于 n）</p>
<h6 id="10-2-1-只读算法"><a href="#10-2-1-只读算法" class="headerlink" title="10.2.1 只读算法"></a><strong>10.2.1 只读算法</strong></h6><p>对于只读算法，最好使用 cbegin() 和 cend()。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sum = <span class="built_in">accumulate</span>(vec.<span class="built_in">cbegin</span>(),vec.<span class="built_in">cend</span>(),val);<span class="comment">//对输入范围内的元素在 val 的基础上求和。可以对字符串“+”。注意元素是加在val上，如果元素是double，val是int，和会被转换成int</span></span><br><span class="line"><span class="type">bool</span> F = <span class="built_in">equal</span>(vec1.<span class="built_in">cbegin</span>(),vec1,<span class="built_in">end</span>(),vec2.<span class="built_in">cbegin</span>());<span class="comment">//比较两个序列的元素是否全部相等（假定第二个序列至少与第一个序列一样长）</span></span><br><span class="line"><span class="keyword">auto</span> iter = <span class="built_in">find_if</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="string">&#x27;一元谓词&#x27;</span>);<span class="comment">//查找符合某条件的元素，返回迭代器，如果没有就返回尾迭代器</span></span><br></pre></td></tr></table></figure>

<h6 id="10-2-2-写容器元素的算法"><a href="#10-2-2-写容器元素的算法" class="headerlink" title="10.2.2 写容器元素的算法"></a><strong>10.2.2 写容器元素的算法</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),val);<span class="comment">//将 val 赋予输入序列中的每一个元素</span></span><br><span class="line"><span class="built_in">fill</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">begin</span>() + vec.<span class="built_in">size</span>()/<span class="number">2</span>,<span class="number">10</span>);<span class="comment">//将一个容器的前一半的值写为10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">fill_n</span>(dest,n,val);<span class="comment">//将 val 赋予从 dest 开始的连续 n 个元素。假定dest开始的序列有至少 n 个元素</span></span><br><span class="line"><span class="built_in">fill_n</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">size</span>(),<span class="number">0</span>);<span class="comment">//将 vec 的所有元素重置为0</span></span><br><span class="line"></span><br><span class="line">for_each(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),<span class="string">&#x27;可调用对象&#x27;</span>);</span><br><span class="line"><span class="comment">//对输入范围内的每一个元素执行可调用对象的内容。注意：可调用对象是一元谓词，参数类型是迭代器指向的类型</span></span><br></pre></td></tr></table></figure>

<p><strong>插入迭代器</strong></p>
<p><strong>插入迭代器</strong>是一种向容器中添加元素的迭代器。</p>
<p>当通过插入迭代器向容器赋值时，一个新的元素被添加到容器中。</p>
<p>函数 <strong>back_inserter</strong> 定义在头文件 iterator 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">back_inserter</span>(vec);<span class="comment">//it 即为vec新加的插入迭代器</span></span><br><span class="line">*it = <span class="number">24</span>;<span class="comment">//给 it 赋值后，vec 现在有一个元素为 24</span></span><br></pre></td></tr></table></figure>

<p>​         </p>
<p>可以用 back_inserter() 函数的返回值作为算法的目的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">fill_n</span>(<span class="built_in">back_inserter</span>(vec),<span class="number">10</span>,<span class="number">0</span>);<span class="comment">//添加 10 个元素到 vec</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<p><strong>拷贝算法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ret = <span class="built_in">copy</span>(<span class="built_in">begin</span>(a1),<span class="built_in">end</span>(a1),<span class="built_in">begin</span>(a2));<span class="comment">//把数组 a1 的内容拷贝给 a2，返回的是目的位置迭代器（递增后）的值</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">replace</span>(ilst.<span class="built_in">begin</span>(),ilst.<span class="built_in">end</span>(),<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//把输入范围内所有值为 0 的元素改为 42</span></span><br><span class="line"><span class="built_in">replace_copy</span>(ilst.<span class="built_in">begin</span>(),ilst.<span class="built_in">end</span>(),dest,<span class="number">0</span>,<span class="number">42</span>);<span class="comment">//把输入范围内所有值为 0 的元素改为 42 并拷给 dest 开头的序列。</span></span><br></pre></td></tr></table></figure>

<p>​             </p>
<h6 id="10-2-3-重排容器元素的算法"><a href="#10-2-3-重排容器元素的算法" class="headerlink" title="10.2.3 重排容器元素的算法"></a><strong>10.2.3 重排容器元素的算法</strong></h6><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sort</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());<span class="comment">//默认按字典序从小到达排列输入范围内的元素。重复的元素会相邻</span></span><br><span class="line"><span class="keyword">auto</span> end_unique = <span class="built_in">unique</span>(words.<span class="built_in">begin</span>(),words.<span class="built_in">end</span>());</span><br><span class="line"><span class="comment">//将输入范围内的元素重排，将重复的元素里不是第一次出现的元素都放到序列的后端。返回指向序列后端重复元素中的第一个重复元素的迭代器。</span></span><br><span class="line">words.<span class="built_in">erase</span>(end_unique,words.<span class="built_in">end</span>());<span class="comment">//删除重复的元素。erase()函数可以接受两个相等的迭代器作为参数。</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<h5 id="10-3-定制操作"><a href="#10-3-定制操作" class="headerlink" title="10.3 定制操作"></a><strong>10.3 定制操作</strong></h5><p>可以使用自定义操作符来替代默认运算符。</p>
<h6 id="10-3-1-向算法传递函数"><a href="#10-3-1-向算法传递函数" class="headerlink" title="10.3.1 向算法传递函数"></a><strong>10.3.1 向算法传递函数</strong></h6><p><strong>谓词</strong>是一个可调用的表达式，返回结果是一个可以作为条件的值，如返回一个 bool 值。</p>
<p>谓词的参数类型必须是元素类型可以转换到的类型。<strong>谓词的实参是输入序列的元素（是元素本身不是迭代器）</strong></p>
<p>谓词分为<strong>一元谓词</strong>和<strong>二元谓词</strong>，分别接受一个参数和两个参数。不同的标准库算法会接受不同的谓词作为参数。</p>
<h6 id="10-3-2-lambda表达式"><a href="#10-3-2-lambda表达式" class="headerlink" title="10.3.2 lambda表达式"></a><strong>10.3.2 lambda表达式</strong></h6><p>lambda 表达式适合那种只在一两个地方使用的简单操作。</p>
<p>可以向一个算法传递任何类别的可调用对象。</p>
<p>总共有四种可调用对象：函数、函数指针、重载了函数调用运算符的类、<strong>lambda表达式</strong></p>
<p>lambda表达式组成部分：<strong>捕获列表、参数列表、返回类型、函数体</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[capture list](parameter list)-&gt;<span class="keyword">return</span> type &#123;function body&#125;</span><br></pre></td></tr></table></figure>

<p>​           </p>
<p>捕获列表的内容为 lambda所在函数中定义的局部变量（直接写局部变量的名字即可，通常为空）。捕获列表只用于<strong>局部非 static 变量。</strong></p>
<p>参数列表和返回类型都可以省略。如果忽略返回类型，则根据 return 语句推断返回类型（此时函数体必须只有 return 语句）。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = []&#123; <span class="keyword">return</span> <span class="number">42</span>&#125;;<span class="comment">//定义了一个可调用对象 f，返回 42</span></span><br></pre></td></tr></table></figure>

<p>​         </p>
<p>lambda表达式的调用方式也是使用<strong>调用运算符，内含实参</strong>。</p>
<p>lambda 没有默认参数。</p>
<h6 id="10-3-3-lambda捕获和返回"><a href="#10-3-3-lambda捕获和返回" class="headerlink" title="10.3.3 lambda捕获和返回"></a><strong>10.3.3 lambda捕获和返回</strong></h6><p>定义一个 lambda 时，编译器生成一个<strong>与 lambda 对应的未命名的类类型</strong>。</p>
<p>当向一个函数传递一个 lambda 时，同时定义了一个新类型和该类型的一个对象：传递的参数实际上就是此编译器生成的类类型的未命名对象。</p>
<p>类似，auto f = [ ]{ return 42; } 实际上定义了一个类类型的对象。</p>
<p>默认情况下，从 lambda 生成的类都包含一个对应该 lambda 所捕获的变量的数据成员。</p>
<p>lambda 捕获变量的方式分为<strong>值捕获</strong>和<strong>引用捕获</strong>，类似参数传递。</p>
<p><strong>值捕获</strong></p>
<p>注意采用值捕获的前提是变量可以拷贝。（iostream 等类型不可拷贝）</p>
<p>被值捕获的变量的值是在 lambda 创建时拷贝，而非调用时拷贝。因此在 lambda 创建后改变被捕获的变量不会影响 lambda 中对应的值。</p>
<p><strong>引用捕获</strong></p>
<p>采用引用捕获时，在捕获列表中的变量名前加上引用符即可。</p>
<p>注意采用引用捕获必须确保<strong>被引用的对象在 lambda 执行时是存在的</strong>。</p>
<p>lambda 捕获的都是上层函数的局部变量，在函数结束后就都不复存在了。</p>
<p>引用捕获可以用于捕获变量是 IO 类型时。</p>
<p><strong>使用 lambda</strong></p>
<p>lambda 和含有可调用对象的类对象都可以作为函数的返回值，要注意此时 lambda 不能包含引用捕获。</p>
<p><strong>应该尽量减少捕获的数据量，同时尽量避免捕获指针或引用</strong>。</p>
<p>捕获列表中可以同时有值捕获的变量和引用捕获的变量</p>
<p><strong>隐式捕获</strong></p>
<p>一般在捕获列表中显式地列出所有的捕获变量，但也可以采用<strong>隐式捕获</strong>。隐式捕获情况下，编译器会根据 lambda 中的代码来推断要使用的变量。</p>
<p>隐式捕获只需在捕获列表中写一个 &amp; 或 = 即可，&amp; 表示采用引用捕获，= 表示采用值捕获。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [=](<span class="type">const</span> string&amp; s)&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>()&gt;=sz; &#125;);</span><br></pre></td></tr></table></figure>

<p><strong>混合显式捕获与隐式捕获</strong></p>
<p>可以通过混合使用隐式捕获和显示捕获来实现对一部分变量使用值传递，而另一部分使用引用传递。</p>
<p>混合捕获时捕获列表中的第一个元素必须是一个 &amp; 或 =：</p>
<ol>
<li>如果是 &amp;，表示采用隐式的引用捕获，此时后面显式捕获的变量必须都采用值捕获。</li>
<li>如果是 =，表示采用隐式的值捕获，此时后面显式捕获的变量必须都采用引用捕获。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [&amp;,c](<span class="type">const</span> string&amp; s)&#123; os&lt;&lt;s&lt;&lt;c; &#125;);   <span class="comment">// 这里的 os 是通过隐式的引用捕获得到的。</span></span><br><span class="line">for_each(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), [=, &amp;os](cosnt string&amp; s)&#123; os&lt;&lt;s&lt;&lt;c;&#125;); <span class="comment">// 这里的 c 是通过隐式的值捕获得到的。</span></span><br></pre></td></tr></table></figure>

<p><strong>捕获列表</strong></p>
<p>总结可得，捕获列表可以有六种形式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[],[参数序列]             <span class="comment">// 空列表与显式捕获</span></span><br><span class="line">[=],[&amp;]                  <span class="comment">// 隐式值捕获与隐式引用捕获</span></span><br><span class="line">[=,参数列表],[&amp;,参数列表] <span class="comment">// 混合捕获</span></span><br></pre></td></tr></table></figure>

<p><strong>可变 lambda</strong></p>
<p>默认情况下，通过值捕获拷贝的变量，lambda 不会改变其值。如果希望改变，必须在参数列表后加上<strong>关键字 mutable</strong>。</p>
<p>引用捕获的变量是否可以修改依赖于引用指向的是 const 还是非 const 类型。</p>
<p><strong>指定 lambda 返回类型</strong></p>
<p>如果 lambda 中只包含一个单一的 return 语句，可以省略返回类型。</p>
<p>如果 lambda 中除了 return 还有其他语句，此时应该指明返回类型。</p>
<h6 id="10-3-4-参数绑定"><a href="#10-3-4-参数绑定" class="headerlink" title="10.3.4 参数绑定"></a><strong>10.3.4 参数绑定</strong></h6><p><strong>lambda 表达式适合那种只在一两个地方使用的简单操作</strong>。如果操作需要很多语句或要在很多地方使用，通常应该定义一个函数。</p>
<p>对于捕获列表为空的 lambda，通常可以用函数来代替。对于捕获列表不为空的 lambda，不容易使用函数替换。</p>
<p><strong>标准库 bind 函数</strong></p>
<p>bind 函数接受一个可调用对象，生成一个<strong>新的调用对象</strong>来“适应”原对象的参数列表。bind 函数定义在<strong>头文件 functional</strong> 中。</p>
<p><strong>bind 使用示例</strong></p>
<p>要将 comp2 绑定到 comp1。</p>
<p>comp1 比较两个 int 的大小，comp2 相当于第二个参数的默认实参为 6 的 comp1。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">comp1</span>(<span class="number">5</span>, <span class="number">6</span>);<span class="comment">//比较 5 和 6 的大小</span></span><br><span class="line"><span class="keyword">auto</span> comp2 = <span class="built_in">bind</span>(comp1, _1, <span class="number">6</span>);<span class="comment">//bind 中第一个参数是 comp1 的函数名，后面的参数是 comp1 的参数列表。bind 的返回值是新生成的可调用对象</span></span><br><span class="line">        <span class="comment">//_1 表示 comp2 的第一个参数，这里表示将 comp2 的第一个参数和 comp1 的第一个参数绑定在了一起。</span></span><br><span class="line"><span class="built_in">comp2</span>(<span class="number">7</span>);<span class="comment">//使用 comp2 比较 7 和 6 的大小。在调用 comp2(7) 时会将其映射为 comp1(7,6);</span></span><br></pre></td></tr></table></figure>

<p><strong>bind 占位符</strong></p>
<p>_1,_2,_n 等占位符分别表示<strong>新可调用对象</strong>的第 1,2,n 个参数，将 _n 放在 bind 中不同的参数位置，表示将新可调用对象的第 n 个参数和旧可调用对象在该位置的参数绑定在了一起。</p>
<p>_1,_2 等定义在<strong>命名空间 placeholders</strong> 中，placeholders 这个名字定义在 std 中。placeholders 的实现定义在 functional 头文件中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std::placeholders;<span class="comment">//使用 _1,_2 前要先声明使用命名空间 placeholders。</span></span><br></pre></td></tr></table></figure>

<p><strong>bind 绑定的主要功能有两个：</strong></p>
<ol>
<li>可以减少参数数目。（减少掉的参数被设为一个固定值）</li>
<li>可以改变参数顺序。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = <span class="built_in">bind</span>(f, a, b, _2, c, _1); <span class="comment">// g 只有两个参数，两个参数分别传递给 f 的第 5 个和第 3 个参数</span></span><br></pre></td></tr></table></figure>



<p><strong>将 bind 用于算法的谓词</strong></p>
<p>因为算法的谓词只能是一元谓词或二元谓词，所以除了使用 lambda 外，也可以使用 bind 来将函数的参数缩减为 1 个或 2 个来作为谓词使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = <span class="built_in">find_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), <span class="built_in">bind</span>(comp2, _1, <span class="number">6</span>));</span><br></pre></td></tr></table></figure>



<p><strong>绑定引用参数</strong></p>
<p>默认情况下，bind 的那些不是占位符的参数是值传递，被拷贝到 bind 返回的可调用对象中。</p>
<p>如果要传递引用或该参数类型不能拷贝（如 os）怎么办？使用 <strong>ref 函数</strong>。</p>
<p>ref 函数接受一个参数，返回一个可以拷贝的对象，该对象含有参数的引用。cref 生成保存 const 引用的类。ref 和 cref 也定义在头文件 functional 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bind</span>(print, os, _1, <span class="string">&#x27;\n&#x27;</span>);       <span class="comment">// 错误，os 不能拷贝</span></span><br><span class="line"><span class="built_in">bind</span>(print, <span class="built_in">ref</span>(os), _1, <span class="string">&#x27;n&#x27;</span>);   <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>

<h5 id="10-4-再探迭代器"><a href="#10-4-再探迭代器" class="headerlink" title="10.4 再探迭代器"></a><strong>10.4 再探迭代器</strong></h5><p>除了每个容器各自的迭代器外，标准库在头文件 <strong>iterator</strong> 中定义了四种迭代器：</p>
<ol>
<li><strong>插入迭代器：</strong>绑定到容器上，可以来向容器插入元素。</li>
<li><strong>流迭代器：</strong>绑定到输入或输出流上，可以用来遍历所关联的 IO 流。</li>
<li><strong>反向迭代器：</strong>这些迭代器向后移动，除了 forward_list 外的标准库容器都有反向迭代器。</li>
<li><strong>移动迭代器：</strong>移动迭代器不拷贝其中的元素，而是移动他们。</li>
</ol>
<h6 id="10-4-1-插入迭代器"><a href="#10-4-1-插入迭代器" class="headerlink" title="10.4.1 插入迭代器"></a><strong>10.4.1 插入迭代器</strong></h6><p><strong>插入器</strong>是一种迭代器适配器，它接受一个容器，生成一个迭代器，能实现向给定容器添加元素。</p>
<p>插入器实际上是一个函数。</p>
<p>注意 <strong>back_inserter</strong> 是插入器，<strong>back_insert_iterator&gt;</strong> 是插入迭代器类型。back_inserter(v) 返回绑定到容器 v 的 back_insert_iterator，并实现其自增。</p>
<p><strong>插入器的三种类型</strong></p>
<ol>
<li><strong>back_inserter</strong>：创建一个使用 push_back 的迭代器。只有容器支持 push_back 才能使用 back_inserter。</li>
<li><strong>front_inserter：</strong>创建一个使用 push_front 的迭代器。只有容器支持 push_front 才能使用 front_inserter。</li>
<li><strong>inserter：</strong>创建一个使用 insert 的迭代器。此函数接受第二个参数，这个参数必须是一个指向给定容器的迭代器，元素将被插入到给定迭代器所表示的元素之前。</li>
</ol>
<p><strong>插入迭代器的定义</strong></p>
<p>有两种方式，一种是<strong>直接定义</strong>，另一种是<strong>通过插入器生成</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="string">&#x27;使用插入器生成&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> bIn = <span class="built_in">back_inserter</span>(v);  <span class="comment">// bIn 是一个绑定到 v 的插入迭代器。</span></span><br><span class="line"><span class="string">&#x27;直接定义&#x27;</span></span><br><span class="line">back_insert_iterator&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">bIn</span>(v);        <span class="comment">// bIn 是一个绑定到 v 的插入迭代器。</span></span><br><span class="line">insert_iterator&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">iIn</span>(v, v.<span class="built_in">begin</span>());  <span class="comment">// iIn 是一个绑定到 v 的插入迭代器</span></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><strong>插入迭代器的操作</strong></p>
<p>有实际意义的插入迭代器操作只有一种，就是赋值操作。</p>
<p>当通过插入迭代器赋值时，插入迭代器调用容器操作来向给定容器的指定位置插入一个元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*bIn = <span class="number">30</span>;<span class="comment">//在 bIn 所绑定的容器的尾元素之后插入一个 30</span></span><br><span class="line">*iIn = <span class="number">10</span>;<span class="comment">//在 iIn 所绑定的容器的相应元素之前插入一个 10</span></span><br></pre></td></tr></table></figure>

<p>​     </p>
<p><strong>插入器 inserter 与函数 insert 的不同</strong></p>
<p>下面的 1 和 2 的效果是一样的。</p>
<p>插入迭代器是恒定指向同一个元素的。而 insert 返回的是指向所插入元素的迭代器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> iIn = <span class="built_in">inserter</span>(v, v.<span class="built_in">begin</span>());</span><br><span class="line">*iIn = <span class="number">10</span>;</span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line">iter = v.<span class="built_in">insert</span>(v.<span class="built_in">begin</span>(), <span class="number">10</span>);</span><br><span class="line">++iter;</span><br></pre></td></tr></table></figure>

<p>​     </p>
<p><strong>插入迭代器的使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v1,v2;</span><br><span class="line">*<span class="built_in">back_inserter</span>(v1) = <span class="number">1</span>;    <span class="comment">// 在 v1 的尾元素之后插入一个 1</span></span><br><span class="line">*<span class="built_in">inserter</span>(v1, v1.<span class="built_in">begin</span>()) = <span class="number">3</span>; <span class="comment">// 在 v1 的首元素之前插入一个 3</span></span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">back_inserter</span>(v2)); <span class="comment">// 将 v1 的所有元素按顺序拷贝到 v2 的尾元素之后。</span></span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(),v1.<span class="built_in">end</span>(),<span class="built_in">inserter</span>(v2,v2.<span class="built_in">begin</span>())); <span class="comment">// 将 v1 的所有元素按顺序拷贝到 v2的首元素之前</span></span><br></pre></td></tr></table></figure>

<p>​      </p>
<h6 id="10-4-2-iostream迭代器"><a href="#10-4-2-iostream迭代器" class="headerlink" title="10.4.2 iostream迭代器"></a><strong>10.4.2 iostream迭代器</strong></h6><p>iostream 有两类</p>
<ol>
<li><strong>istream_iterator</strong>：读取输入流。</li>
<li><strong>ostream_iterator</strong>：向输出流写数据。</li>
</ol>
<p>流迭代器可以绑定到 iostream,fstream,stringstream。它将对应的流当作一个元素序列来处理。</p>
<p>流迭代器的<strong>主要作用</strong>是辅助使用泛型算法从流对象读取数据和写入数据。</p>
<p>创建流迭代器时，必须指定迭代器将要读写的对象类型。</p>
<p><strong>istream_iterator 的定义</strong></p>
<p>可以为任何具有输入运算符的（&gt;&gt;）类型定义 istream_iterator，即所有内置类型和重置了 &gt;&gt; 的类。</p>
<p>创建流迭代器时，有<strong>两种情况：</strong></p>
<ol>
<li>绑定到一个流</li>
<li>默认初始化：采用这种方式创建的迭代器可以当作尾后值使用，可以在 for 循环中作为终止条件。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">iInt</span><span class="params">(cin)</span></span>;<span class="comment">//创建了一个流迭代器 iInt，iInt 从 cin 读取 int</span></span><br><span class="line">istream_iterator&lt;<span class="type">int</span>&gt; intEof;<span class="comment">//尾后迭代器。当关联的流遇到文件尾或遇到错误，迭代器的值就与尾后迭代器相等。</span></span><br></pre></td></tr></table></figure>

<p><strong>istream_iterator 操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in1 == in2; in1 != int2;<span class="comment">//首先 in1 和 in2 必须读取相同类型。如果 in1 和 in2 都是尾后迭代器或绑定到相同的输入，则两者相等。</span></span><br><span class="line">*in;<span class="comment">//返回从流中读取的值</span></span><br><span class="line">++in;in++;<span class="comment">//递增操作</span></span><br></pre></td></tr></table></figure>

<p><strong>istream_iterator 的使用</strong></p>
<p>流迭代器可以用于一部分泛型算法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">istream_iterator&lt;<span class="type">int</span>&gt; <span class="title">inInt</span><span class="params">(cin)</span>,eof</span>;</span><br><span class="line"><span class="string">&#x27;1&#x27;</span></span><br><span class="line"><span class="keyword">while</span>(inInt != eof)</span><br><span class="line">    vec.<span class="built_in">push_back</span>(*inInt++);</span><br><span class="line"><span class="string">&#x27;2&#x27;</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">vec</span><span class="params">(inInt,eof)</span></span>;<span class="comment">//和上面效果相同，当遇到文件尾或遇到第一个不是 int 的数据停止。    </span></span><br></pre></td></tr></table></figure>

<p><strong>ostream_iterator 定义</strong></p>
<p>可以为任何具有输出运算符的（&lt;&lt;）类型定义 <strong>ostream_iterator</strong>，即所有内置类型和重置了 &lt;&lt; 的类。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;<span class="type">double</span>&gt; <span class="title">out</span><span class="params">(os)</span></span>;<span class="comment">//out 将类型为 double 的值写到输出流 os 中</span></span><br><span class="line"><span class="function">ostream_iterator&lt;<span class="type">double</span>&gt; <span class="title">out</span><span class="params">(os,str)</span></span>;<span class="comment">//out 将类型为 double 的值写到 os 中，每个值后面都跟着一个C风格字符串 str。</span></span><br></pre></td></tr></table></figure>

<p>​         </p>
<p><strong>ostream_iterator 操作</strong></p>
<p>ostream_iterator 的赋值操作等价于输出流的输出操作。<strong>每赋一次值，输出一次。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out = <span class="number">3.14</span>;<span class="comment">//等价于 os&lt;&lt;3.14。将 3.14 写入到 out 绑定的输出流中。</span></span><br><span class="line">*out; ++out; out++;<span class="comment">//这些运算符存在但没有意义。</span></span><br></pre></td></tr></table></figure>



<p><strong>ostream_iterator 的使用</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:vec)</span><br><span class="line">    out = e;<span class="comment">//赋值语句将元素写到 cout，每赋一次值，写操作就会被提交一次。</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:vec) *out++ = e;<span class="comment">//与上面的语句实际效果相同，看起来更清晰。    </span></span><br></pre></td></tr></table></figure>

<p>​       </p>
<p>也可以使用 copy 来打印 vec 中的元素，更为简单。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">copy</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>(),out);<span class="comment">//将 vec 中的元素写入到了 out 绑定的输出流中</span></span><br></pre></td></tr></table></figure>

<p>​        </p>
<h6 id="10-4-3-反向迭代器"><a href="#10-4-3-反向迭代器" class="headerlink" title="10.4.3 反向迭代器"></a><strong>10.4.3 反向迭代器</strong></h6><p>除了 forward_list 外，其他容器都支持反向迭代器。</p>
<p>反向迭代器支持递增和递减操作。注意流迭代器不支持递减操作。</p>
<p><strong>反向迭代器的颠倒</strong></p>
<p>函数 <strong>riter.base()</strong> 返回相应的正向迭代器，正向迭代器指向<strong>靠后一个元素</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> riter = string.<span class="built_in">rbegin</span>()<span class="comment">//反向迭代器 riter 指向 string 的尾元素</span></span><br><span class="line"><span class="keyword">auto</span> iter = riter.<span class="built_in">base</span>();<span class="comment">//正向迭代器 iter 指向 string 的尾后元素</span></span><br></pre></td></tr></table></figure>

<p>​       </p>
<h5 id="10-5-泛型算法结构"><a href="#10-5-泛型算法结构" class="headerlink" title="10.5 泛型算法结构"></a><strong>10.5 泛型算法结构</strong></h5><h6 id="10-5-1-5类迭代器"><a href="#10-5-1-5类迭代器" class="headerlink" title="10.5.1 5类迭代器"></a><strong>10.5.1 5类迭代器</strong></h6><p>算法所要求的迭代器操作可以分为 5 类，每个算法都会为它的迭代器参数指明需提供哪类迭代器</p>
<ol>
<li><strong>输入迭代器：</strong>只读，不写；单遍扫描，只能递增。</li>
<li><strong>输出迭代器：</strong>只写，不读；单遍扫描，只能递增。</li>
<li><strong>前向迭代器：</strong>可读写；多遍扫描，只能递增。</li>
<li><strong>双向迭代器：</strong>可读写；多遍扫描，可递增递减。</li>
<li><strong>随机访问迭代器：</strong>可读写，多遍扫描，支持全部迭代器运算。</li>
</ol>
<p>迭代器根据支持的操作的多少分层。C++ 标准指明了泛型算法的每个迭代器参数的最小类别。</p>
<p><strong>输入迭代器</strong></p>
<p>输入迭代器只用于顺序访问，只能用于单遍扫描算法，如算法 find 和 accumulate。</p>
<p>Istream_iterator 是一种输入迭代器。</p>
<p><strong>输出迭代器</strong></p>
<p>只能向一个输出迭代器赋值一次，只能用于顺序访问的单遍扫描算法。如 copy 函数的第三个参数。</p>
<p>ostream_iterator 是一种输出迭代器。</p>
<p><strong>前向迭代器</strong></p>
<p>可以读写元素。只能在序列中沿一个方向移动，可以多次读写同一个元素。</p>
<p>可以保存前向迭代器的状态，使用前向迭代器的算法可以对序列多遍扫描。</p>
<p>算法 replace 要求前向迭代器，forward_list 的迭代器是前向迭代器。</p>
<p><strong>双向迭代器</strong></p>
<p>可以正向/反向读写序列中的元素。支持递增递减运算符。</p>
<p>算法 reverse 要求双向迭代器。list 的迭代器是双向迭代器。</p>
<p><strong>随机访问迭代器</strong></p>
<p>提供在常量时间内访问序列中任意元素的能力。</p>
<p>支持以下操作：</p>
<ol>
<li>支持 &lt;, &lt;=, &gt;, &gt;= 等关系运算符。</li>
<li>支持迭代器与整数的加减。</li>
<li>支持两个迭代器之间的相减。</li>
<li>支持下标运算符。iter[n] 和 *(iter[n]) 含义相同。</li>
</ol>
<p>算法 sort 要求随机访问迭代器。array, deque, vector, string 的迭代器是随机访问迭代器。</p>
<h6 id="10-5-2-算法形参模式"><a href="#10-5-2-算法形参模式" class="headerlink" title="10.5.2 算法形参模式"></a><strong>10.5.2 算法形参模式</strong></h6><p>算法的形参一般是以下 4 种模式之一</p>
<ol>
<li><em>alg(beg, end, other args);</em> </li>
<li><em>alg(beg, end, dest, other args);</em> dest 经常是一个<strong>插入迭代器</strong>或一个 <strong>ostream_iterator</strong>，他们都能确保不管写多少元素都肯定是安全的。</li>
<li><em>alg(beg, end, beg2, other args);</em></li>
<li><em>alg(beg, end, beg2, end2, other args);</em></li>
</ol>
<h6 id="10-5-3-算法命名规范"><a href="#10-5-3-算法命名规范" class="headerlink" title="10.5.3 算法命名规范"></a><strong>10.5.3 算法命名规范</strong></h6><p>算法遵循一同命名和重载规范。</p>
<p><strong>重载谓词的算法</strong></p>
<p>一些算法使用重载形式传递一个谓词，来代替 &lt; 或 ==。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">unique</span>(beg, end);          <span class="comment">// 使用 == 比较元素</span></span><br><span class="line"><span class="built_in">unique</span>(beg, end, comp);    <span class="comment">// 使用 comp 比较元素</span></span><br></pre></td></tr></table></figure>

<p>​        </p>
<p><strong>_if 版本的算法</strong></p>
<p>接受一个元素值的算法通常有另一个不同名的 _if 版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">find</span>(beg, end, val);       <span class="comment">// 查找范围内 val 第一次出现的版本。</span></span><br><span class="line"><span class="built_in">find_if</span>(beg, end, pred);   <span class="comment">// 查找第一个令 pred 为真的元素。</span></span><br></pre></td></tr></table></figure>

<p>​              </p>
<p><strong>拷贝版本的算法</strong></p>
<p>默认情况下，重排元素的算法会将重排后的元素写回给定的输入序列中。拷贝版本则将元素写到一个给定的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reverse</span>(beg, end);             <span class="comment">// 反转序列中的元素。</span></span><br><span class="line"><span class="built_in">reverse_copy</span>(beg, end, dest);  <span class="comment">// 将元素按逆序拷贝到 dest。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">remove_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), [](<span class="type">int</span> i)&#123;<span class="keyword">return</span> i%<span class="number">2</span>;&#125;);                         <span class="comment">// 从 v1 中删除奇数元素。</span></span><br><span class="line"><span class="built_in">remove_copy_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">back_inserter</span>(v2), [](<span class="type">int</span> i)&#123;<span class="keyword">return</span> i%<span class="number">2</span>;&#125;); <span class="comment">// 将去掉了奇数元素的 v1 序列拷到 v2 中。</span></span><br></pre></td></tr></table></figure>

<h5 id="10-6-特定容器算法"><a href="#10-6-特定容器算法" class="headerlink" title="10.6 特定容器算法"></a><strong>10.6 特定容器算法</strong></h5><p><strong>链表类型 list 和 forward_list</strong> 定义了几个成员函数形式的算法。它们定义了独有的 <strong>sort, merge, remove, reverse 和 unique。</strong></p>
<p>通用版本的 sort 要求随机访问迭代器，而 list 和 forward_list 分别提供双向迭代器和前向迭代器，因此不能用于 list 和 forward_list。</p>
<p>其他链表类型定义的算法的通用版本可以用于链表，但是性能差很多，应该<strong>优先使用成员函数版本的算法。</strong></p>
<p><strong>成员函数版本的算法</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">lst.<span class="built_in">merge</span>(lst2);        <span class="comment">// 将 lst2 的元素合并入 lst。两者必须都是有序的，合并后 lst2 将变为空。使用 &lt; 比较元素。</span></span><br><span class="line">lst.<span class="built_in">merge</span>(lst2,comp);   <span class="comment">// 上面的 merge 的重载版本，用给定的 comp 代替 &lt;</span></span><br><span class="line"></span><br><span class="line">lst.<span class="built_in">remove</span>(val);        <span class="comment">// 调用 erase 删除掉与给定值相等的每个元素。</span></span><br><span class="line">lst.<span class="built_in">remove_if</span>(pred);    <span class="comment">// pred 是个一元谓词，删除掉 lst 中使 pred 为真的每个元素。</span></span><br><span class="line"></span><br><span class="line">lst.<span class="built_in">reverse</span>();          <span class="comment">// 反转 lst 中元素的顺序。</span></span><br><span class="line"></span><br><span class="line">lst.<span class="built_in">sort</span>();             <span class="comment">// 使用 &lt; 给元素排序</span></span><br><span class="line">lst.<span class="built_in">sord</span>(comp);         <span class="comment">// 重载版本</span></span><br><span class="line"></span><br><span class="line">lst.<span class="built_in">unique</span>();          <span class="comment">// 调用 erase 删除同一个值的连续拷贝。</span></span><br><span class="line">lst.<span class="built_in">unique</span>(pred);      <span class="comment">// pred 是个二元谓词，删除使 pred 为真的连续拷贝。</span></span><br></pre></td></tr></table></figure>



<p><strong>splice算法</strong></p>
<p>链表类型定义了 <strong>splice 算法</strong>，此算法是链表特有的，<strong>没有通用版本</strong>。</p>
<p>splice 算法用来在两个链表间移动元素或在一个链表中移动元素的位置。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">lst.<span class="built_in">splice</span>(p, lst2); flst.<span class="built_in">splice_after</span>(p, lst2);              <span class="comment">// p 是一个指向 lst 中元素的迭代器，或一个指向 flst 首前位置的迭代器。</span></span><br><span class="line">        <span class="comment">// 函数将 lst2 中的所有元素移动到 lst 中 p 之前的位置或 flst  中 p 之后的位置。</span></span><br><span class="line">lst.<span class="built_in">splice</span>(p, lst2, p2); flst.<span class="built_in">splice_after</span>(p, lst2, p2);      <span class="comment">// p2 是一个指向 lst2 中位置的迭代器。</span></span><br><span class="line">        <span class="comment">// 函数将 p2 指向的元素移动到 lst 中，或将 p2 之后的元素移动到 flst 中,lst2 可以是与 lst 或 flst 相同的链表。</span></span><br><span class="line">lst.<span class="built_in">splice</span>(p, lst2, b, e); flst.<span class="built_in">splice_after</span> (p, lst2, b, e); <span class="comment">// b 和 e 表示 lst2 中的合法范围。</span></span><br><span class="line">        <span class="comment">// 将给定范围中的元素从 lst2 移动到 lst 中。lst2 可以是与 lst 或 flst 相同的链表，但是 p 不能指向 b 和 e 之间的元素。   </span></span><br></pre></td></tr></table></figure>

<p>​                 </p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E4%B9%9D%E7%AB%A0/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第九章 顺序容器</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第十一章 关联容器</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">王秋鹏</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#10-1-%E6%A6%82%E8%BF%B0"><span class="nav-text">10.1 概述</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-2-%E5%88%9D%E8%AF%86%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95"><span class="nav-text">10.2 初识泛型算法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#10-2-1-%E5%8F%AA%E8%AF%BB%E7%AE%97%E6%B3%95"><span class="nav-text">10.2.1 只读算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-2-2-%E5%86%99%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">10.2.2 写容器元素的算法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-2-3-%E9%87%8D%E6%8E%92%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84%E7%AE%97%E6%B3%95"><span class="nav-text">10.2.3 重排容器元素的算法</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-3-%E5%AE%9A%E5%88%B6%E6%93%8D%E4%BD%9C"><span class="nav-text">10.3 定制操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#10-3-1-%E5%90%91%E7%AE%97%E6%B3%95%E4%BC%A0%E9%80%92%E5%87%BD%E6%95%B0"><span class="nav-text">10.3.1 向算法传递函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-3-2-lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">10.3.2 lambda表达式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-3-3-lambda%E6%8D%95%E8%8E%B7%E5%92%8C%E8%BF%94%E5%9B%9E"><span class="nav-text">10.3.3 lambda捕获和返回</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-3-4-%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A"><span class="nav-text">10.3.4 参数绑定</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-4-%E5%86%8D%E6%8E%A2%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">10.4 再探迭代器</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#10-4-1-%E6%8F%92%E5%85%A5%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">10.4.1 插入迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-4-2-iostream%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">10.4.2 iostream迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-4-3-%E5%8F%8D%E5%90%91%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">10.4.3 反向迭代器</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-5-%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95%E7%BB%93%E6%9E%84"><span class="nav-text">10.5 泛型算法结构</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#10-5-1-5%E7%B1%BB%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">10.5.1 5类迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-5-2-%E7%AE%97%E6%B3%95%E5%BD%A2%E5%8F%82%E6%A8%A1%E5%BC%8F"><span class="nav-text">10.5.2 算法形参模式</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#10-5-3-%E7%AE%97%E6%B3%95%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83"><span class="nav-text">10.5.3 算法命名规范</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#10-6-%E7%89%B9%E5%AE%9A%E5%AE%B9%E5%99%A8%E7%AE%97%E6%B3%95"><span class="nav-text">10.6 特定容器算法</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
