<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="王秋鹏">
    
    <title>
        
            C++ Primer 第十一章 关联容器 |
        
        wangqp
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                wangqp
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/c/"
                            >
                                C++
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/Codeing/"
                            >
                                数据结构与算法
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                            >
                                系统编程与网络编程
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%95%B0%E6%8D%AE%E5%BA%93/"
                            >
                                数据库
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E9%A1%B9%E7%9B%AE"
                            >
                                项目
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"
                            >
                                杂七杂八
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about/"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/c/">C++</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/Codeing/">数据结构与算法</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">系统编程与网络编程</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E9%A1%B9%E7%9B%AE">项目</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/">杂七杂八</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about/">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">C++ Primer 第十一章 关联容器</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">王秋鹏</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2021-09-10 00:00:00</span>
        <span class="mobile">2021-09-10 00:00</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>关联容器中的元素按关键字来保存和访问，顺序容器中的元素按他们在容器中的位置来保存和访问</p>
<p>关联容器包括 <strong>map</strong> 和 <strong>set</strong> 。</p>
<p>map 和 multimap 在<strong>头文件 map</strong> 中，set 和 multiset 在<strong>头文件 set</strong> 中，无序 map 和无序 set 分别在<strong>头文件 unordered_map</strong> 和 <strong>unordered_set</strong> 中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;按关键字有序保存元素&#x27;</span></span><br><span class="line">map;<span class="comment">//保存关键字-值对</span></span><br><span class="line">set;<span class="comment">//关键字就是值，只保存关键字</span></span><br><span class="line">multimap;<span class="comment">//关键字可重复出现的map</span></span><br><span class="line">multiset;<span class="comment">//关键字可重复出现的set</span></span><br><span class="line"><span class="string">&#x27;无序集合&#x27;</span></span><br><span class="line">unordered_map;<span class="comment">//无序map</span></span><br><span class="line">unordered_set;<span class="comment">//无序set</span></span><br><span class="line">unordered_multimap;<span class="comment">//哈希组织的 map，关键字可重复出现</span></span><br><span class="line">unordered_multiset;<span class="comment">//哈希组织的 set，关键字可重复出现</span></span><br></pre></td></tr></table></figure>

<h5 id="11-1-使用关联容器"><a href="#11-1-使用关联容器" class="headerlink" title="11.1 使用关联容器"></a><strong>11.1 使用关联容器</strong></h5><p><strong>使用 map</strong></p>
<p>map 可以使用范围 for 循环</p>
<p>map 的一个经典应用是单词计数程序</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)</span><br><span class="line">    ++word_count[word];</span><br></pre></td></tr></table></figure>

<p><strong>使用 set</strong></p>
<p>set 也可以使用范围 for 循环。</p>
<h5 id="11-2-关联容器概述"><a href="#11-2-关联容器概述" class="headerlink" title="11.2 关联容器概述"></a><strong>11.2 关联容器概述</strong></h5><p>所有的有序、无序关联容器都支持下面这些通用操作。</p>
<p>关联容器不支持顺序容器的位置相关的操作，关联容器中的元素是根据关键字存储的。</p>
<p>关联容器的迭代器都是<strong>双向</strong>的。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;类型别名&#x27;</span></span><br><span class="line">iterator</span><br><span class="line">const_iterator</span><br><span class="line">value_type <span class="comment">//容器元素类型。定义方式： vector&lt;int&gt;::value_type</span></span><br><span class="line">reference <span class="comment">//元素类型的引用。定义方式： vector&lt;int&gt;::reference</span></span><br><span class="line">const_reference <span class="comment">//元素的 const 左值类型</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;构造函数&#x27;</span>-<span class="string">&#x27;三种通用的构造函数：同类拷贝、迭代器范围初始化、列表初始化&#x27;</span></span><br><span class="line">C c1;                          <span class="comment">// 默认构造函数，构造空容器。</span></span><br><span class="line"><span class="function">C <span class="title">c1</span> <span class="params">(c2)</span></span>;                    <span class="comment">// 拷贝构造函数，容器类型与元素类型必须都相同</span></span><br><span class="line"><span class="function">C <span class="title">c1</span> <span class="params">(c2.begin(), c2.end())</span></span>;  <span class="comment">// 要求两种元素类型可以转换即可。</span></span><br><span class="line">C c1 &#123;a, b, c, ...&#125;;          <span class="comment">// 使用初始化列表，容器的大小与初始化列表一样大</span></span><br><span class="line">        <span class="comment">// 只有顺序容器的构造函数可以接受大小参数，关联容器不行。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;赋值与swap&#x27;</span></span><br><span class="line">c1 = c2;</span><br><span class="line">c1 = &#123;a,b,c,....&#125;</span><br><span class="line">a.<span class="built_in">swap</span>(b);</span><br><span class="line"><span class="built_in">swap</span>(a,b);<span class="comment">//两种 swap 等价</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;大小&#x27;</span></span><br><span class="line">c.<span class="built_in">size</span>();</span><br><span class="line">c.<span class="built_in">max_size</span>();<span class="comment">//c 可以保存的最大元素数目，是整个内存层面的容量，不是已分配内存。不同于 caplity, caplity 只能用于 vector，queue，string</span></span><br><span class="line">c.<span class="built_in">empty</span>();</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;添加/删除元素（不适用于array）&#x27;</span></span><br><span class="line">c.<span class="built_in">insert</span>(args); <span class="comment">//将 args 中的元素拷贝进 c，args 是一个迭代器或迭代器范围</span></span><br><span class="line">c.<span class="built_in">emplace</span>(inits);<span class="comment">//使用 inits 构造 c 中的一个元素</span></span><br><span class="line">c.<span class="built_in">erase</span>(args);<span class="comment">//删除指定的元素，args 是一个迭代器或迭代器范围</span></span><br><span class="line">c.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;关系运算符&#x27;</span></span><br><span class="line">==; !=; &lt;; &lt;=; &gt;; &gt;=  <span class="comment">//所有容器都支持相等和不等运算符。无序关联容易不支持大于小于运算符。</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;获取迭代器&#x27;</span></span><br><span class="line">c.<span class="built_in">begin</span>(); c.<span class="built_in">end</span>(); </span><br><span class="line">c.<span class="built_in">cbegin</span>(); c.<span class="built_in">cend</span>(); <span class="comment">//返回 const_iterator</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;反向容器的额外成员&#x27;</span></span><br><span class="line">reverse_iterator <span class="comment">//逆序迭代器，这是一个和 iterator 不同的类型</span></span><br><span class="line">const_reverse_iterator </span><br><span class="line">c.<span class="built_in">rbegin</span>();c.<span class="built_in">rend</span>();</span><br><span class="line">c.<span class="built_in">crbegin</span>();c.<span class="built_in">crend</span>();</span><br></pre></td></tr></table></figure>

<p>上面是关联容器和顺序容器的通用操作，下面是关联容器的额外操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;类型别名&#x27;</span></span><br><span class="line">key_type <span class="comment">//关键字类型</span></span><br><span class="line">mapped_type <span class="comment">//每个关联的类型，只适用于 map</span></span><br><span class="line">value_type <span class="comment">//对于 set，与 key_type 相同，对于 map，为 pair&lt;const key_type,mapped_type&gt;</span></span><br></pre></td></tr></table></figure>

<h6 id="11-2-1-定义关联容器"><a href="#11-2-1-定义关联容器" class="headerlink" title="11.2.1 定义关联容器"></a><strong>11.2.1 定义关联容器</strong></h6><p>只有顺序容器的构造函数可以接受大小参数，关联容器不行。</p>
<p>关联容器的初始化可以使用直接初始化（使用小括号）、列表初始化（使用花括号）、拷贝初始化（使用等号）。</p>
<p>使用迭代器范围进行直接初始化时，如果迭代器范围中有重复关键字，生成的 set 和 map 会<strong>自动去除重复的元素</strong>。</p>
<p><strong>值初始化</strong></p>
<p>除了三种构造函数外，关联容器可以进行<strong>值初始化</strong>。初始化器必须能转换为容器中元素的类型。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;string&gt; ss = &#123;<span class="string">&quot;the&quot;</span>,<span class="string">&quot;and&quot;</span>&#125;;</span><br><span class="line">map&lt;string, string&gt; sm = &#123; &#123;<span class="string">&quot;LiLin&quot;</span>,<span class="string">&quot;男&quot;</span>&#125;,&#123;<span class="string">&quot;HeFan&quot;</span>,<span class="string">&quot;男&quot;</span>&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>初始化 map 时，将<strong>关键字-值对</strong>包括在<strong>一个花括号中 {key, value}</strong> 就可以构成 map 的一个元素。</p>
<p><strong>初始化 multiset 和 multimap</strong></p>
<p>使用迭代器范围进行直接初始化时，无论有没有重复关键字，都会生成包含所有元素的 multiset 和 multimap。</p>
<h6 id="11-2-2-关键字类型的要求"><a href="#11-2-2-关键字类型的要求" class="headerlink" title="11.2.2 关键字类型的要求"></a><strong>11.2.2 关键字类型的要求</strong></h6><p><strong>有序容器的关键字类型</strong></p>
<p>有序容器的关键字类型必须定义元素比较的方法，标准库默认使用 &lt; 来比较关键字。可以使用如 vector 等容器的迭代器来作为有序容器的关键字。</p>
<p>重载了 &lt; 运算符的类可以直接用作关键字。</p>
<p>可以向算法提供一个自己定义的比较操作，操作必须在关键字类型上定义一个<strong>严格弱序</strong>，类似小于等于但不一样：</p>
<ol>
<li>两个关键字不能同时”小于等于“对方。</li>
<li>该操作有传递性。</li>
<li>如果两个关键字互不”小于等于“对方，那么两个就是等价的。容器将它们看做相等。</li>
</ol>
<p>当两个关键字是等价的，map 只能存储一个，但是也可以通过另一个关键字来访问值。</p>
<p><strong>使用关键字类型的比较函数</strong></p>
<p>当自己定义了比较操作，必须在定义关联容器时指出来，自定义的操作类型（函数指针类型）应在尖括号中紧跟元素类型给出。并将函数名作为参数传递给构造函数。</p>
<p>比较函数应该返回 bool 值，两个参数的类型应该都是容器的关键字类型。当第一个参数小于第二个参数时返回真。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;比较函数的定义方式&#x27;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">comp</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() &lt; rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;定义容器对象&#x27;</span></span><br><span class="line"><span class="function">multiset&lt;Sales_data,<span class="title">decltype</span><span class="params">(comp)</span>*&gt; <span class="title">bookstore</span><span class="params">(comp)</span></span>;</span><br></pre></td></tr></table></figure>

<p>​        </p>
<p>注意<strong>当使用 decltype 获取函数指针时要加上 * 运算符。</strong></p>
<h6 id="11-2-3-pair类型"><a href="#11-2-3-pair类型" class="headerlink" title="11.2.3 pair类型"></a><strong>11.2.3 pair类型</strong></h6><p>pair 类型定义在头文件 <strong>utility</strong> 中。</p>
<p>pair 也是一个模板。</p>
<p><strong>pair 定义</strong></p>
<p>pair 的默认构造函数对数据成员进行值初始化，因此 string，vector 等类型会默认为空，int 会默认为 0。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;直接定义&#x27;</span></span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p;<span class="comment">//默认初始化</span></span><br><span class="line"><span class="function">pair&lt;string, <span class="type">int</span>&gt; <span class="title">p</span><span class="params">(str, i)</span></span>;</span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p&#123;<span class="string">&quot;LiLin&quot;</span>, <span class="number">17</span>&#125;;</span><br><span class="line">pair&lt;string, <span class="type">int</span>&gt; p = &#123;<span class="string">&quot;LiLin&quot;</span>, <span class="number">17</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;使用 make_pair&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> p = <span class="built_in">make_pari</span>(v1, v2);<span class="comment">//pair 的类型根据 v1 和 v2 的类型推断。</span></span><br></pre></td></tr></table></figure>

<p>​             </p>
<p><strong>pair 操作</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">p.first  <span class="comment">//返回 p 的第一个成员</span></span><br><span class="line">p.second <span class="comment">//返回 p 的第二个成员</span></span><br><span class="line">p1 &lt; p2;   <span class="comment">//当 p1.first &lt; p2.first &amp;&amp; p1.second &lt; p2.second 时为真。</span></span><br><span class="line">p1&lt;=p2; p1&gt;p2; p1&gt;=p2;</span><br><span class="line">p1 == p2;<span class="comment">//当 first 和 second 成员都相等时，两个 pair 相等。</span></span><br><span class="line">p1 != p2;</span><br></pre></td></tr></table></figure>

<p><strong>创建 pair 类型的返回值</strong></p>
<p>如果一个函数返回一个 pair，可以对返回值进行<strong>列表初始化</strong>或<strong>隐式构造返回值</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;string,<span class="type">int</span>&gt; <span class="title">process</span><span class="params">(<span class="type">bool</span> a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a) </span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;LiLin&quot;</span>,<span class="number">17</span>&#125;;<span class="comment">//列表初始化</span></span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">pair</span>&lt;string,<span class="type">int</span>&gt;();<span class="comment">//隐式构造返回值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<h5 id="11-3-关联容器操作"><a href="#11-3-关联容器操作" class="headerlink" title="11.3 关联容器操作"></a><strong>11.3 关联容器操作</strong></h5><p>关联容器除了上面列出的类型别名，还有如下三种</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;类型别名&#x27;</span></span><br><span class="line">key_type <span class="comment">//关键字类型</span></span><br><span class="line">mapped_type <span class="comment">//每个关联的类型，只适用于 map</span></span><br><span class="line">value_type <span class="comment">//对于 set，与 key_type 相同，对于 map，为 pair&lt;const key_type,mapped_type&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意 set 的 key_type 类型不是常量，pair 的 first 成员也不是常量，只有 map 的 value_type 中的 first 成员是常量。</p>
<h6 id="11-3-1-关联容器迭代器"><a href="#11-3-1-关联容器迭代器" class="headerlink" title="11.3.1 关联容器迭代器"></a><strong>11.3.1 关联容器迭代器</strong></h6><p>解引用关联容器迭代器得到的是 value_type 的引用。</p>
<p><strong>set 的迭代器</strong></p>
<p>set 的关键值与 map 的关键值一样，都是不能改变的。</p>
<p>可以用 <strong>set 的迭代器读取元素值，但不能修改。</strong></p>
<p><strong>关联容器和算法</strong></p>
<p>当对关联容器使用泛型算法时，一般要么把它作为源序列，要么把它作为目的序列。比如从关联容器拷贝元素，向关联容器插入元素等。</p>
<h6 id="11-3-2-添加元素"><a href="#11-3-2-添加元素" class="headerlink" title="11.3.2 添加元素"></a><strong>11.3.2 添加元素</strong></h6><p>插入容器中已存在的元素对 map 和 set 没有影响。</p>
<p><strong>使用</strong> <strong>insert</strong> <strong>添加元素</strong></p>
<p>关联容器添加元素一般使用 insert 成员，可以添加<strong>一个元素</strong>也可以添加<strong>一个元素范围</strong>，或者<strong>初始化列表</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="number">10</span>);                     <span class="comment">// 插入一个元素（s中没有关键字时才插入）。返回一个pair，pair包含一个迭代器指向具有指定关键字的元素，和一个表明是否插入成功的 bool 值</span></span><br><span class="line">s.<span class="built_in">insert</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>();  <span class="comment">// 插入迭代器范围。返回 void</span></span><br><span class="line">s.<span class="built_in">insert</span>(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;);              <span class="comment">// 插入初始化列表。返回 void</span></span><br><span class="line">s.<span class="built_in">insert</span>(iter, <span class="number">10</span>);               <span class="comment">// 类似于 insert(10),iter 是一个迭代器，提示从哪里开始搜索新元素应该存储的位置。返回一个迭代器，指向具有制定关键字的元素。</span></span><br></pre></td></tr></table></figure>

<p>​          </p>
<p><strong>向 map 添加临时构造的元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map&lt;string, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="string">&#x27;四种方法&#x27;</span></span><br><span class="line">m.<span class="built_in">insert</span>(&#123;str, <span class="number">1</span>&#125;);                    <span class="comment">//最简单的方法，直接使用花括号</span></span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(str, <span class="number">1</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;string, <span class="type">int</span>&gt;(str, <span class="number">1</span>));   <span class="comment">//pair 类型直接定义</span></span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;string, <span class="type">int</span>&gt;::<span class="built_in">value_type</span>(str, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>

<p><strong>使用 emplace 添加元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s.<span class="built_in">emplace</span>(args);<span class="comment">//args用来构造一个元素，其他和 s.insert(10) 相同</span></span><br><span class="line">s.<span class="built_in">emplace</span>(iter, args);<span class="comment">//除了 args 其他和 s.insert(iter, 10) 相同</span></span><br></pre></td></tr></table></figure>

<p><strong>检测 insert 的返回值</strong></p>
<p>注意 insert 返回的值不是固定的，依赖于容器类型和参数</p>
<ol>
<li>对于不重复的map和set，<strong>添加的单一元素</strong>的 insert 和 emplace 都<strong>返回一个 pair</strong>，pair 内是<strong>具有给定关键字的元素的迭代器</strong>和<strong>一个 bool 值</strong></li>
<li>对于不重复的map和set，<strong>添加多个元素</strong>都返回 <strong>void</strong></li>
</ol>
<p>在向 map 或 set 添加元素时，<strong>检测 insert 的返回值可以很有用，要灵活使用。</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cin&gt;&gt;word)&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = word_count.<span class="built_in">insert</span>(&#123;word,<span class="number">1</span>&#125;);</span><br><span class="line">    <span class="keyword">if</span>(ret.second = <span class="literal">false</span>)</span><br><span class="line">        ++ret.first-&gt;second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>向 multiset 或 multimap 添加元素</strong></p>
<p>在 multiset 或 multimap 上调用 insert 总会插入元素。</p>
<p><strong>插入单个元素</strong>的 insert <strong>返回一个指向新元素的迭代器。</strong></p>
<h6 id="11-3-3-删除元素"><a href="#11-3-3-删除元素" class="headerlink" title="11.3.3 删除元素"></a><strong>11.3.3 删除元素</strong></h6><p>关联容器定义了一个额外版本的 erase 和两个与顺序容器相似版本的 erase</p>
<ol>
<li><strong>额外版本：</strong>输入参数为关键字（注意不是关键字的迭代器），返回删除的元素数量，对于非重复关键字的容器，返回值总是 1 或 0。</li>
<li><strong>与顺序容器相似版本：</strong>注意顺序容器会返回删除元素后一个元素的迭代器，而这里的 erase 返回 void</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;与顺序容器相似版本的 erase&#x27;</span></span><br><span class="line">s.<span class="built_in">erase</span>(iter);          <span class="comment">// 删除一个元素，返回 void</span></span><br><span class="line">s.<span class="built_in">erase</span>(iter1, iter2)   <span class="comment">// 删除一个范围，返回 void</span></span><br><span class="line"><span class="string">&#x27;额外版本&#x27;</span></span><br><span class="line"><span class="keyword">auto</span> cnt = s.<span class="built_in">erase</span>(<span class="string">&quot;LiLin&quot;</span>);<span class="comment">//</span></span><br></pre></td></tr></table></figure>

<p><strong>删除关联容器的最后一个元素</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m.<span class="built_in">erase</span>(--m.<span class="built_in">end</span>());   <span class="comment">// 正确！m 的迭代器支持自增与自减</span></span><br><span class="line">m.<span class="built_in">erase</span>(m.<span class="built_in">rbegin</span>());  <span class="comment">// 错误！</span></span><br></pre></td></tr></table></figure>

<p><strong>遍历容器删除元素</strong></p>
<p><strong>注意 map 和 vector 的不同</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;map&#x27;</span></span><br><span class="line">map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = m.<span class="built_in">begin</span>(); iter != m.<span class="built_in">end</span>(); )&#123;</span><br><span class="line">    <span class="keyword">if</span>(iter-&gt;second == <span class="number">0</span>)</span><br><span class="line">        m.<span class="built_in">erase</span>(iter++); <span class="comment">//这是循环map删除指定元素的唯一方式。利用了 i++ 的原理</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter++;    </span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;vector&#x27;</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> iter = v.<span class="built_in">begin</span>(); iter != v.<span class="built_in">end</span>(); )&#123;</span><br><span class="line">    <span class="keyword">if</span>(*iter == <span class="number">0</span>)</span><br><span class="line">        iter = v.<span class="built_in">erase</span>(iter);<span class="comment">//vecotr 的 erase 操作返回所删除元素之后的迭代器</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        iter++;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="11-3-4-map的下标操作"><a href="#11-3-4-map的下标操作" class="headerlink" title="11.3.4 map的下标操作"></a><strong>11.3.4 map的下标操作</strong></h6><p>map 和 unordered_map 都支持下标操作和对应的 at 函数。set 类型则不支持下标。multimap 和 unordered_multimap 不支持下标操作。</p>
<p>map 的下标操作会返回一个 mapped_type 对象。</p>
<p>如果关键字不再 map 中，会创建一个元素并插入到 map 中，关联值将进行值初始化。</p>
<p>注意：因为关联值是<strong>值初始化</strong>，所以在单词计数程序中，<strong>可以直接 map[word]++ ，不必特意插入元素</strong>。</p>
<p>注意：map 的下标操作只能返回非常量引用（不同于顺序容器的下标操作），如果 map 本身是常量，则无法使用下标访问元素，这时要用 at() 函数。</p>
<p><strong>at 函数</strong></p>
<p><strong>m.at(k) 会访问关键字为 k 的元素，带参数检查；如果 k 不在 m 中，抛出一个 out_of_range 异常。</strong></p>
<h6 id="11-3-5-访问与查找元素"><a href="#11-3-5-访问与查找元素" class="headerlink" title="11.3.5 访问与查找元素"></a><strong>11.3.5 访问与查找元素</strong></h6><p><strong>访问元素</strong></p>
<p>map  可以通过下标或 at() 函数访问元素。</p>
<p>set 只能通过迭代器来访问元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;基本的访问操作&#x27;</span></span><br><span class="line">c[k];</span><br><span class="line">c.<span class="built_in">at</span>(k);</span><br></pre></td></tr></table></figure>

<p><strong>查找元素</strong></p>
<p>关联容器查找一个指定元素的方法有多种。一般 find 是最佳选择。</p>
<p>对于不允许重复关键字的容器，find 和 count 差别不大，对于允许重复关键字的容器，count 会统计有多少个元素有相同的关键字。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;查找操作&#x27;</span></span><br><span class="line">c.<span class="built_in">find</span>(k);<span class="comment">//返回一个迭代器，指向关键字为 k 的元素，如果 k 不在容器中，返回尾后迭代器。</span></span><br><span class="line">c.<span class="built_in">count</span>(k);<span class="comment">//返回关键字等于 k 的元素数量。</span></span><br><span class="line">c.<span class="built_in">lower_bound</span>(k);<span class="comment">//返回一个迭代器，指向第一个关键字大于等于 k 的元素。</span></span><br><span class="line">c.<span class="built_in">upper_bound</span>(k);<span class="comment">//返回一个迭代器，指向第一个关键字大于 k 的元素。</span></span><br><span class="line">c.<span class="built_in">equal_range</span>(k);<span class="comment">//返回一个迭代器 pair，表示关键字等于 k 的元素范围。若干 k 不存在，pair 的两个成员相等，指向可以安全插入 k 的位置</span></span><br></pre></td></tr></table></figure>

<p><strong>检查元素是否存在</strong></p>
<p>检查元素是否存在用 find 或 count。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(word_count.<span class="built_in">find</span>(<span class="string">&quot;LiLin&quot;</span>) == word_count.<span class="built_in">end</span>())</span><br><span class="line"><span class="keyword">if</span>(word_count.<span class="built_in">count</span>(<span class="string">&quot;LiLin&quot;</span>) == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>​       </p>
<p><strong>在 multimap 或 multiset 中查找元素</strong></p>
<p>要在 multimap 或 multiset 中查找所有具有给定关键字的元素比较麻烦，有三种方法</p>
<ol>
<li>使用 find 和 count 配合，找到第一个关键字为 k 的元素和所有关键字为 k 的元素数目，遍历完成。</li>
<li>使用 lower_bound 和 upper_bound 配合。注意当关键字 k 不存在时，这两个函数返回相同的迭代器，可能是尾后迭代器也可能不是。</li>
<li>使用 equal_range。最直接的方法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = <span class="built_in">multiM</span>(item); pos.first != pos.second; ++pos.first)</span><br><span class="line">    cout &lt;&lt; pos.first-&gt;second;</span><br></pre></td></tr></table></figure>

<p>​      </p>
<h5 id="11-4-无序容器"><a href="#11-4-无序容器" class="headerlink" title="11.4 无序容器"></a><strong>11.4 无序容器</strong></h5><p>4 个无序容器使用哈希函数和关键字类型的 == 运算符来组织元素，而非比较运算符。</p>
<p>无序容器用于<strong>关键字类型不好排序</strong>的情况。</p>
<p><strong>使用无序容器</strong></p>
<p>无序容器也有 <strong>find，insert，迭代器</strong>等操作。</p>
<p>在大多数情况下，可以用无序容器替换对应的有序容器，反之亦然。但是注意无序容器中元素未按顺序存储。</p>
<p><strong>管理桶</strong></p>
<p>无序容器在存储上组织为<strong>一组桶</strong>，每个桶保存零个或多个元素。</p>
<p>无序容器使用哈希函数将元素映射到桶，并将具有一个特定哈希值的所有元素保存在相同的桶中。如果容器允许重复关键字，那所有具有相同关键字的元素也都在同一个桶中。不同关键字的元素也可能映射到相同的桶。</p>
<p>对于相同的参数，哈希函数总是产生相同的结果。</p>
<p>当一个桶中保存了多个元素，需要顺序搜索这些元素来查找想要的那个。计算一个元素的哈希值和在桶中搜索通常都很快。</p>
<p><strong>管理桶的函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;桶接口&#x27;</span></span><br><span class="line">c.<span class="built_in">bucket_count</span>();      <span class="comment">//返回正在使用的桶的数目</span></span><br><span class="line">c.<span class="built_in">max_bucket_count</span>();  <span class="comment">//返回容器能容纳的最多的桶的数量</span></span><br><span class="line">c.<span class="built_in">bucket_size</span>(n);      <span class="comment">//返回第 n 个桶中有多少个元素</span></span><br><span class="line">c.<span class="built_in">bucket</span>(k);           <span class="comment">//返回关键字为 k 的元素所在的桶</span></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;桶迭代&#x27;</span></span><br><span class="line">local_iterator         <span class="comment">//类型别名，可以用来访问桶中元素的迭代器类型</span></span><br><span class="line">const_local_iterator   <span class="comment">//类型别名，桶迭代器的常量版本</span></span><br><span class="line">c.<span class="built_in">begin</span>(n), c.<span class="built_in">end</span>(n)  <span class="comment">//返回桶 n 的首元素迭代器和尾后迭代器</span></span><br><span class="line">c.<span class="built_in">cbegin</span>(n),c.<span class="built_in">cend</span>(n) </span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;哈希策略&#x27;</span></span><br><span class="line">c.<span class="built_in">load_factor</span>();      <span class="comment">//返回每个桶的平均元素数量，类型为 float</span></span><br><span class="line">c.<span class="built_in">max_load_factor</span>();  <span class="comment">//返回 c 试图维护的平均桶大小，类型为 float。c 会在需要时添加新的桶，始终保持 load_factor &lt;= max_loat_factor</span></span><br><span class="line">c.<span class="built_in">rehash</span>(n);          <span class="comment">//重组存储，使得 bucket_count &gt;= n 且 bucket_count &gt; size / max_load_factor</span></span><br><span class="line">c.<span class="built_in">reserve</span>(n);         <span class="comment">//重组存储，使得 c 可以保存 n 个元素而不必 rehash。</span></span><br></pre></td></tr></table></figure>



<p><strong>无序容器对关键字的要求</strong></p>
<p>默认情况下，无序容器使用 == 运算符比较关键字，使用用一个 hash （hash 模板）类型的对象来生成每个元素的哈希值。</p>
<p>标准库为内置类型（包括指针）和 string、智能指针等都定义了 hash，因此<strong>内置类型，string 和智能指针类型</strong>都能直接用来作为无序容器的关键字。</p>
<p>对于自定义的类类型，不能直接用来作为无序容器的关键字，因为他们不能直接使用 hash 模板，除非提供自己的 hash 模板版本。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;定义自己的 hash 模板版本&#x27;</span></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">hasher</span><span class="params">(<span class="type">const</span> Sales_data &amp;sd)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>&lt;string&gt;() (sd.<span class="built_in">isbn</span>());<span class="comment">//这里采用了标准库的 hash 类型对象来计算 isbn 成员的哈希值，作为整个 Sale_data 对象的哈希值。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;重载比较函数（这里是相等）&#x27;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">eq</span><span class="params">(<span class="type">const</span> Sales_data &amp;lhs, <span class="type">const</span> Sales_data &amp;rhs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.<span class="built_in">isbn</span>() == rhs.<span class="built_in">isbn</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">&#x27;定义 unordered_multiset&#x27;</span></span><br><span class="line">unordered_multiset&lt; Sales_data, <span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eq)* &gt; sals;</span><br></pre></td></tr></table></figure>

<p>无论是有序容器还是无序容器，具有相同关键字的元素都是相邻存储的。</p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E7%AB%A0/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第十章 泛型算法</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第一章 开始</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">王秋鹏</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#11-1-%E4%BD%BF%E7%94%A8%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-text">11.1 使用关联容器</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-2-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="nav-text">11.2 关联容器概述</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#11-2-1-%E5%AE%9A%E4%B9%89%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8"><span class="nav-text">11.2.1 定义关联容器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-2-2-%E5%85%B3%E9%94%AE%E5%AD%97%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%A6%81%E6%B1%82"><span class="nav-text">11.2.2 关键字类型的要求</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-2-3-pair%E7%B1%BB%E5%9E%8B"><span class="nav-text">11.2.3 pair类型</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-3-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E6%93%8D%E4%BD%9C"><span class="nav-text">11.3 关联容器操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#11-3-1-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="nav-text">11.3.1 关联容器迭代器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-3-2-%E6%B7%BB%E5%8A%A0%E5%85%83%E7%B4%A0"><span class="nav-text">11.3.2 添加元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-3-3-%E5%88%A0%E9%99%A4%E5%85%83%E7%B4%A0"><span class="nav-text">11.3.3 删除元素</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-3-4-map%E7%9A%84%E4%B8%8B%E6%A0%87%E6%93%8D%E4%BD%9C"><span class="nav-text">11.3.4 map的下标操作</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#11-3-5-%E8%AE%BF%E9%97%AE%E4%B8%8E%E6%9F%A5%E6%89%BE%E5%85%83%E7%B4%A0"><span class="nav-text">11.3.5 访问与查找元素</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#11-4-%E6%97%A0%E5%BA%8F%E5%AE%B9%E5%99%A8"><span class="nav-text">11.4 无序容器</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
