<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="王秋鹏">
    
    <title>
        
            C++ Primer 第一章 开始 |
        
        wangqp
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                wangqp
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/c/"
                            >
                                C++
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/Codeing/"
                            >
                                数据结构与算法
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                            >
                                系统编程与网络编程
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%95%B0%E6%8D%AE%E5%BA%93/"
                            >
                                数据库
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E9%A1%B9%E7%9B%AE"
                            >
                                项目
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"
                            >
                                杂七杂八
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about/"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/c/">C++</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/Codeing/">数据结构与算法</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">系统编程与网络编程</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E9%A1%B9%E7%9B%AE">项目</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/">杂七杂八</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about/">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">C++ Primer 第一章 开始</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">王秋鹏</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2021-09-10 00:00:00</span>
        <span class="mobile">2021-09-10 00:00</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p><strong>第12章 动态内存</strong></p>
<p>动态分配对象的生存期通过显示的分配与释放来控制。</p>
<p><strong>动态对象的正确释放是一个极容易出错的地方。</strong></p>
<p><strong>静态内存</strong>用来保存<strong>全局变量</strong>与<strong>局部 static 对象</strong>，<strong>类 static 数据成员。</strong></p>
<p><strong>栈内存</strong>用来保存定义在函数内的非 static 对象。</p>
<p><strong>堆保存</strong>动态分配的对象。</p>
<p><strong>12.0 补充知识</strong></p>
<p><strong>堆内存和栈内存的比较：</strong></p>
<ol>
<li><p>控制权：</p>
</li>
<li><ol>
<li>栈由编译器自动分配和释放；</li>
<li>堆由程序员分配和释放</li>
</ol>
</li>
<li><p>空间大小：</p>
</li>
<li><ol>
<li>栈：windows下，栈是向低地址扩展的，是连续的内存区域，所以栈顶地址和栈的最大容量都是确定的，似乎一般是 2M 或 1M</li>
<li>堆：堆是向高地址扩展的，是不连续的内存区域。系统是用<strong>链表来存储空闲地址</strong>的。<strong>堆的大小由计算机的有效虚拟内存决定，因此空间大得多</strong>。</li>
</ol>
</li>
<li><p>分配效率：</p>
</li>
<li><ol>
<li>栈：速度较快。</li>
<li>堆：速度较慢，但使用方便。</li>
</ol>
</li>
<li><p>系统响应：</p>
</li>
<li><ol>
<li>栈：如果剩余空间不足，异常提示栈溢出</li>
<li>堆：在记录空闲地址的链表中寻找空间大于所申请空间的堆结点，然后将该结点从空闲节点链表中删除。一般会在首地址处记录本次分配空间的大小。</li>
</ol>
</li>
<li><p>存储内容：</p>
</li>
<li><ol>
<li>栈：存储函数的各个参数、局部变量、函数返回地址等。第一个进栈的就是函数返回地址</li>
<li>堆：内容由程序员决定。</li>
</ol>
</li>
</ol>
<p><strong>12.1 动态内存与智能指针</strong></p>
<p>c++ 使用 new 和 delete 管理动态内存</p>
<ul>
<li><strong>new</strong>：在堆中为对象分配空间并返回指向该对象的指针</li>
<li><strong>delete</strong>：接受一个动态对象的指针，销毁该对象并释放内存。</li>
</ul>
<p>忘记释放内存会引起<strong>内存泄漏</strong>，释放了后继续引用指针会<strong>引用非法内存</strong>。</p>
<p>如果忘记释放内存，在<strong>程序结束时会由操作系统自动回收。</strong></p>
<p>新标准库提供两种智能指针和一个伴随类管理动态内存，都定义在头文件 <strong>memory</strong> 中：</p>
<ol>
<li><strong>shared_ptr</strong>：允许多个指针指向一个对象</li>
<li><strong>unique_tpr</strong>：独占所指的对象</li>
<li><strong>weak_ptr</strong>：一种弱引用，指向 shared_ptr 所管理的对象</li>
</ol>
<p>要注意到：智能指针实际上是一个<strong>类模板</strong>。但是它的操作与指针十分相似</p>
<p><strong>12.1.1 shared_ptr类</strong></p>
<p>智能指针也是模板，类似 vector。在创建模板时，必须<strong>提供指针指向的类型</strong>。</p>
<p>​                shared_ptr<string> p1;       // 可以指向 string shared_ptr&lt;vector<int>&gt; p2;  // 可以指向 int 的 vector              </p>
<p>默认初始化的智能指针中保存着空指针。</p>
<p><strong>定义 shared_ptr 的方式</strong></p>
<p>可以使用另一个 shared_ptr 或一个 unique_ptr 或 new 的指针来初始化一个 shared_ptr。</p>
<p>​                shared_ptr<int> p;              // 默认初始化为空指针 shared_ptr<int> p(q);           // q 也是一个 shared_ptr,p 是 q 的拷贝，此操作会递增 q 中的计数器。 shared_ptr<int> p(qnew);        // qnew 是一个指向动态内存的内置指针（qnew = new int;)） shared_ptr<int> p(u);           // u 是一个 unique_ptr。p 从 u 接管了对象的所有权，u 被置为空 shared_ptr<int> p(q, deleter);  // q 是一个内置指针。p 将使用可调用对象 deleter 来代替 delete shared_ptr<int> p(p2, deleter); // p2 是一个 shared_ptr，p 是 p2 的拷贝，唯一的区别是 p 将可调用对象 d 来代替 delete。 auto p = make_shared<int>(10);  //返回一个 shared_ptr，指向一个初始化为 10 的动态分配的 int 对象。注意不同于 make_pair              </p>
<p><strong>shared_ptr 操作</strong></p>
<p>​                sp              // 智能指针作为 if 的判断条件时检查其是否为空，若 sp 指向一个对象，则为 true sp-&gt;mem;        // 等价于 (*p).mem。用于当 sp 指向一个类时 sp.get();       // 返回 sp 中保存的指针。要小心使用！ swap(p, q);     // 交换 p 和 q 中的指针 p.swap(q);      // 同上 p = q;          // 此操作会递增 q 中的计数器，递减 p 原来的计数器，若其变为 0，则释放。 p.unique();     // 若 p.use_count() 为 1，返回 true，否则返回 false p.use_count();  // 返回与 p 共享对象的智能指针数量。可能运行很慢，主要用于调试 p.reset();     // 将 p 置为空，如果 p 计数值为 1，释放对象。 p.reset(q);    // q 是一个内置指针，令 p 指向 q。 p.reset(q, d); // 调用可调用对象 d 而不是 delete 来释放 q              </p>
<p><strong>make_shared 函数</strong></p>
<p><strong>这是最安全的分配和使用动态内存的方法</strong></p>
<p>make_shared 类似顺序容器的 emplace 成员，用参数来构造对象。</p>
<p>通常用 auto 来定义一个对象保存 make_shared 的结果。</p>
<p><strong>make_shared 是函数模板，要提供模板参数</strong></p>
<p>​                shared_ptr<int> p1 = make_shared<int>(10); auto p2 = make_shared<string>(10,’s’);              </p>
<p><strong>shared_ptr 的拷贝和赋值</strong></p>
<p>每个 shared_ptr 都有一个关联的计数器，如果拷贝一个 shared_ptr，计数器就会递增。</p>
<p>例如初始化，或作为参数传递给函数，或<strong>作为函数返回值时</strong>。</p>
<p>如果 shared_ptr 的计数器变为 0，就会自动释放管理的对象。</p>
<p>​                auto r = make_shared<int>(42);  // r 指向的 int 只有一个引用者 r = q; // 给 r 赋值，令它指向另一个地址。    //这会递增 q 指向的对象的引用计数，并递减 r 原来指向的对象的引用计数。因为 r 原来指向的对象没有已经没有引用者，所以会自动释放。              </p>
<p><strong>shared_ptr 自动销毁所管理的对象</strong></p>
<p>shared_ptr 通过析构函数来完成销毁。</p>
<p>它的<strong>析构函数</strong>会递减对象的引用计数，如果计数变为 0，则销毁对象并释放内存。</p>
<p><strong>shared_ptr 自动释放相关联的内存</strong></p>
<p>由于最后一个 shared_ptr 销毁前内存都不会释放，所以要保证 shared_ptr 无用之后就不要再保留了。</p>
<p>如果忘记销毁不再需要的 shared_ptr，程序不会出错，但会浪费内存。</p>
<p>一种常量的情况是将 shared_ptr 存放在一个容器中，后来其中有一部分元素不再用到了，这时要注意用 erase 删除不需要的元素。</p>
<p><strong>析构函数</strong></p>
<p>每个类都有析构函数。析构函数控制对象销毁时执行什么操作。</p>
<p>析构函数一般用来释放对象分配的资源。如 vector 的析构函数销毁它的元素并释放内存。</p>
<p><strong>使用动态内存的三种情况</strong></p>
<ol>
<li>不知道需要使用多少对象。例如容器类</li>
<li>不知道对象的准确类型。</li>
<li>需要在多个对象间共享内存。</li>
</ol>
<p><strong>使用动态内存在多个对象间共享内存</strong></p>
<p>定义一个类，类的数据成员为一个 shared_ptr。使用此 shared_ptr 来管理一个 vector，即可实现在多个类对象间共享同一个 vector。当所有类对象都被销毁时 vector 才会被销毁。注意一个类只会与它的拷贝共享一个 vector，单独定义的两个类是不共享的。</p>
<p><strong>一个实例：StrBlob类</strong></p>
<p>StrBlob 类是一个使用动态内存在多个对象间共享内存的例子。</p>
<p>StrBlob 类中仅有一个 shared_ptr 成员，这个 shared_ptr 指向一个 string 的 vector。</p>
<p>​                #include <vector> #include <string> #include <initializer_list> #include <memory> #include <exception> using std::vector; using std::string; class StrBlob { public:   using size_type = vector<string>::size_type;      // 灵活使用类型别名   StrBlob():data(std::make_shared&lt;vector<string>&gt;()) { }   StrBlob(std::initializer_list<string> il):data(std::make_shared&lt;vector<string>&gt;(il)) { }  //定义了一个接受初始化列表的转换构造函数（注意不是 explicit 的）   size_type size() const { return data-&gt;size(); }   // size() 函数不改变数据成员，所以声明为 const 的   bool empty() const { return data-&gt;empty(); }      // 声明为 const 的   void push_back(const string &amp;t) { data-&gt;push_back(t); }   void pop_back() {     check(0, “pop_back on empty StrBlob”);     data-&gt;pop_back();   }   std::string&amp; front() {     check(0, “front on empty StrBlob”);     return data-&gt;front();   }   std::string&amp; back() {     check(0, “back on empty StrBlob”);     return data-&gt;back();   }   const std::string&amp; front() const {       //在普通的 front() 函数外又重载了一个 const 的版本     check(0, “front on empty StrBlob”);     return data-&gt;front();   }   const std::string&amp; back() const {       //在普通的 back() 函数外又重载了一个 const 的版本     check(0, “back on empty StrBlob”);     return data-&gt;back();   } private:   void check(size_type i, const string &amp;msg) const {   //定义了一个 check 函数来检查索引是否超出边界     if (i &gt;= data-&gt;size()) throw std::out_of_range(msg);  //不检查 i 是否小于 0 是因为 i 的类型是 size_type，是无符号类型，如果 i&lt;0 会被自动转换为大于 0 的数   } private:   std::shared_ptr&lt;vector<string>&gt; data; };              </p>
<p>在实现上面这个类时要注意的几点：</p>
<ol>
<li>对于不改变类的成员的函数，要声明为 const 的。</li>
<li>对于 front(), back() 等返回成员的函数，既要定义返回普通引用的版本，也要定义返回常量引用的版本。返回常量引用的版本要声明为 const 的，这样才能成功地进行重载，不然只有返回值类型不同，编译器无法区分。</li>
<li>check 函数不检查 i 是否小于 0 是因为 i 的类型是 size_type，是无符号类型，如果 i&lt;0 会被自动转换为大于 0 的数</li>
<li>这里的接受 initializer_list 的转换构造函数没有定义为 explicit 的，这样的好处是使用方便，可以进行隐式的转换。缺点是不易调试。</li>
</ol>
<p><strong>12.1.2 直接管理内存</strong></p>
<p>可以使用 new 和 delete 来直接管理内存。相比于智能指针，它们非常容易出错。</p>
<p>自己直接管理内存的类不能依赖默认合成的拷贝控制成员，通常都需要自己定义。而使用了智能指针的类则可以使用默认合成的版本。</p>
<p><strong>使用new动态分配和初始化对象</strong></p>
<p>new 无法为分配的对象命名，只是返回一个指针。</p>
<p>默认情况下，动态分配的对象被默认初始化。可以用直接初始化或列表初始化或值初始化初始动态分配的对象。</p>
<p>​                int* p = new int;   //默认初始化 string* sp = new string(10,’g’);//直接初始化 vector<int>* vp = new vector<int>{0,1,2,3};//列表初始化              </p>
<p><strong>区分值初始化和默认初始化</strong></p>
<p>对于类来说，值初始化与默认初始化没有什么区别，<strong>对于内置类型来说，值初始化对象会有一个良好的值</strong>，默认初始化对象值未定义。</p>
<p>值初始化只需加括号即可。</p>
<p>​                int* p1 = new int;   // 默认初始化，p1 所指对象的值是未定义的 int* p2 = new int(); // 值初始化，p2 所指对象的值初始化为 0              </p>
<p><strong>建议对动态分配的对象进行值初始化</strong>，如同变量初始化一样。</p>
<p><strong>使用 auto</strong></p>
<p>当用括号提供了单个初始化器，就可以使用 auto（前后都用 auto）</p>
<p>​                auto p1 = new auto(a);        // p1 指向一个与 a 类型相同的对象，该对象用 a 初始化 auto p1 = new auto{a, b, c};  // 错误，不是单一初始化器，有多个。              </p>
<p><strong>动态分配的 const 对象</strong></p>
<p>可以使用 new 分配 const 对象，前后都要加 const</p>
<p>​                const int* pci = new const int(10);              </p>
<p>动态分配的 const 对象必须初始化，类类型可以隐式初始化。</p>
<p><strong>内存耗尽</strong></p>
<p>如果没有可用内存了，new 就会失败。</p>
<p>默认情况下，如果 new 失败，会爆出一个 <strong>bad_alloc</strong> 类型的异常。</p>
<p>使用<strong>定位 new</strong> 可以向 new 传递参数，传递 <strong>nothrow</strong> 可以阻止 new 在分配失败的情况下抛出异常。</p>
<p>bad_alloc 和 nothrow 都定义在<strong>头文件 new</strong> 中</p>
<p>​                int* p = new(nothrow) int;//如果分配失败，返回一个空指针              </p>
<p><strong>释放动态内存</strong></p>
<p>使用 delete 表达式来释放动态内存，包括动态分配的 const 对象也是直接 delete 即可。</p>
<p>delete执行两个动作：</p>
<ol>
<li>销毁指针所指对象（但没有销毁指针本身）</li>
<li>释放对应内存</li>
</ol>
<p>​                delete p; // p 必须指向一个动态分配的对象或是一个空指针              </p>
<p>释放一个不是动态分配的指针和相同的指针释放多次的行为都是<strong>未定义</strong>的。</p>
<p>通常编译器不能分辨 delete 的对象是动态还是静态分配的对象，也不能分辨一个指针所指的内存是否已被释放。</p>
<p>动态对象直到被显式释放前都是存在的。</p>
<p><strong>两种特殊情况：</strong></p>
<ol>
<li><p>指针不在内存还在</p>
</li>
<li><ol>
<li>当指针是一个局部变量，因超出作用域而被销毁时，其指向的动态内存不会自动释放。当没有指针指向这块内存时，就无法再释放了。这就是忘记 delete 产生的内存泄漏的问题。</li>
</ol>
</li>
<li><p>指针还在内存不在</p>
</li>
<li><ol>
<li><p>delete一个指针后，指针值已经无效，但是指针还是保存着地址，此时就变成了<strong>空悬指针</strong>。有两个解决方法</p>
</li>
<li><ol>
<li><strong>delete 之后将指针置为空指针</strong></li>
<li><strong>在指针作用域的末尾 delete</strong></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>如果有多个指针指向同一块动态内存，只能 delete 一个指针，因为 delete 的是空间，如果 delete 两个指针，可能会破坏自由空间。但必须将多个指针都重置。</p>
<p><strong>使用 new 和 delete 的三个常见错误：</strong></p>
<ol>
<li>忘记 delete 内存：内存泄漏。</li>
<li>使用已释放的的对象。</li>
<li>同一块内存释放两次。</li>
</ol>
<p><strong>一个会导致内存泄漏的例子</strong></p>
<p>​                bool b() {    int* p = new int; // p 是一个 int 型指针    return p;     // 函数返回值是 bool 类型，将 int 型指针转换为 bool 类型会使内存无法释放，造成内存泄漏 }              </p>
<p><strong>12.1.3 shared_ptr和new结合使用</strong></p>
<p>可以使用 new 初始化智能指针。但是最好还是用 make_shared</p>
<p><strong>接受指针参数的智能指针构造参数是 explicit 的，不能将内置指针隐式地转换为智能指针****。</strong>因此不能使用赋值，只能用直接初始化。</p>
<p>​                shared_ptr<double> p1(new int(42));  // 正确：调用了转换构造函数 shared_ptr<double> p2 = new int(42); // 错误：转换构造函数是 explicit 的，不能隐式转换              </p>
<p>默认情况下用于初始化智能指针的普通指针只能指向动态内存，因为智能指针默认使用 delete 释放对象。</p>
<p>如果将智能指针绑定到一个指向其他类型资源的指针上，要定义自己的删除器(函数) 来代替 delete</p>
<p><strong>建议不要混用智能指针和普通指针</strong></p>
<p>shared_ptr 可以协调对象的析构，但仅限于自身的拷贝之间。这就是推荐使用 make_shared 而不是 new 的原因。</p>
<p>使用普通指针（即 new 返回的指针）来创建一个 shared_ptr 有两个易错之处：</p>
<ol>
<li>使用普通指针创建 shared_ptr 后，又使用该普通指针访问动态对象。普通指针并不知道该对象何时被 shared_ptr 所释放，随时可能变成空悬指针。</li>
<li>使用同一个普通指针创建了多个 shared_ptr ，这就将同一块内存绑定到多个独立创建的 shared_ptr 上了。</li>
</ol>
<p>当将一个 shared_ptr 绑定到一个普通指针后，就不要再用内置指针来访问所指内存了。</p>
<p><strong>不要使用 get 初始化另一个智能指针或为智能指针赋值</strong></p>
<p>智能指针的 get 函数返回一个内置指针。</p>
<p>​                shared_ptr<int> p(new int(42)); int* q = p.get();   // 这是正确的，但是要极小心地使用，这会非常容易出错。              </p>
<p>注意：不要使用 get 初始化另一个智能指针或为智能指针赋值。也不能通过 get 返回的指针来 delete 此指针。</p>
<p>shared_ptr 的关联计数只应用于自己的拷贝，如果使用某智能指针的 get 函数初始化另一个智能指针，两个指针的计数是不关联的，销毁一个就会直接释放内存使另一个成为空悬指针。</p>
<p><strong>一个错误的例子</strong></p>
<p>​                auto sp = make_shared<int>(); auto p = sp.get(); delete p;   //错误，这会造成 double free。              </p>
<p><strong>12.1.4 智能指针和异常</strong></p>
<p>使用异常处理的程序能在异常发生后令程序流程继续，它需要确保在异常发生后资源能被正确地释放，一种简单的方法是使用智能指针。</p>
<p>使用智能指针时发生异常，智能指针管理的内存会被释放掉，而如果是直接管理内存时，在 new 和 delete 之间发生了异常，则内存不会被释放。</p>
<p><strong>智能指针和哑类</strong></p>
<p>所有标准库类都定义了析构函数，负责清理对象使用的资源。</p>
<p>但是那些为 C 和 C++ 两种语言设计的类，通常都没有良好定义的析构函数，必须显式释放资源。</p>
<p>如果在资源分配和释放之间发生了异常，或程序员忘记释放资源，程序也会发生资源泄漏。</p>
<p>例如网络连接中的在释放连接前发生了异常，那么连接就不会被释放了。</p>
<p><strong>使用自己的释放操作</strong></p>
<p>默认情况下，shared_ptr 假定它们指向的是动态内存，在销毁时会使用 delete 操作。</p>
<p>但也可以使用 shared_ptr 管理其他对象，如网络连接，这时就需要定义一个相应的删除器函数来代替 delete。</p>
<p>可以定义一个函数来代替 delete，称为<strong>删除器</strong>。</p>
<p>​                share_ptr<T> p(&amp;t, deleter);  //deleter 必须是一个接受一个 T* 类型参数的函数              </p>
<p>使用 shared_ptr 管理网络连接</p>
<p>​                shared_ptr<connection> p(&amp;c, end_connection);// end_connection 是 p 的删除器，它接受一个 connection* 参数              </p>
<p><strong>智能指针陷阱</strong></p>
<ol>
<li>不使用相同的内置指针值初始化或 reset 多个智能指针</li>
<li>不 delete get() 返回的指针</li>
<li>不使用 get() 初始化或 reset 另一个智能指针</li>
<li>如果使用 get() 返回的指针，当最后一个对应的智能指针被销毁后，指针就变为无效的了</li>
<li>如果智能指针管理的不是 new 分配的内存，记住传递给它一个删除器</li>
</ol>
<p><strong>12.1.5 unique_ptr</strong></p>
<p>同一时刻只能有一个 unique_ptr 指向一个给定对象。</p>
<p>当 unique_ptr 被销毁时，指向对象也被销毁。</p>
<p>定义 unique_ptr 时，需要<strong>绑定到一个 new 返回的指针上</strong>（不同于 shared_ptr)。c++14 中加入了 make_unique</p>
<p>类似 shared_ptr，初始化 unique_ptr 必须采用直接初始化。（这里指使用 new 初始化）</p>
<p>因为 unique_ptr 独有它指向的对象，所有它不支持拷贝和赋值操作。实际上 unique_ptr 的拷贝构造函数被定义为删除的。</p>
<p><strong>unique_ptr 定义和初始化</strong></p>
<p>​                unique_ptr<int> u1;             // 定义一个空 unique_ptr unique_ptr<int> u1(new int());  // 正确 unique_ptr&lt;int,deleter&gt; u;      // 定义一个空 unqiue，用可调用对象 deleter 代替 delete unique_ptr&lt;int,deleter&gt; u(d);   // 空 unique，用类型为 deleter 的对象 d 代替delete unique_ptr&lt;int,decltype(d)*&gt; u(new int(42),d); unique_ptr<int> u2(u1);         // 错误：不支持拷贝              </p>
<p>注意 unique_ptr 管理删除器的方式与 shared_ptr 不一样。<strong>unique_ptr 将删除器放在尖括号中</strong></p>
<p><strong>unique_ptr 操作</strong></p>
<p>​                u.get(); u1.swap(u2);swap(u1,u2); u = nullptr;             // 释放 u 指向的对象并将 u 置为空 auto u2 = u.release();   // u 放弃对指针的控制权，返回 u 中保存的内置指针，并将 u 置为空，注意 u2 的类型是内置指针，而不是 unique_ptr u.reset();               // 释放 u 指向的对象 u.reset(nullptr);        // 释放 u 指向的对象，并将 u 置为空，等价于 u = nullptr; u.reset(q);              // 令 u 指向内置指针 q 指向的对象              </p>
<p>可以通过 release 或 reset 将指针的所有权从一个 unique_ptr 转移给另一个 unique</p>
<p>​                unique_ptr<int> u2(u1.release());  // 控制器转移给 u2，u1 置为空 u3.reset(u1.release());            // 释放 u3 原来指向的内存，u3 接管 u1 指向的对象。              </p>
<p><strong>release的使用</strong></p>
<p>release 返回的指针通常用来初始化其他智能指针或给其他智能指针赋值。</p>
<p>release 返回的指针不能空闲，必须有其他指针接管对象。如果是一个内置指针接管了 release 返回的指针，那么程序就要负责资源的释放。</p>
<p>​                u.release();             // 错误：release 不会释放内存，没有其他指针接管内存。 auto u2 = u1.release();  // 正确，但必须记得 delete p              </p>
<p><strong>传递unique_ptr参数和返回unique_ptr</strong></p>
<p>不能拷贝 unique_ptr 参数的规则有一个例外：可以拷贝或赋值一个将要被销毁的 unique_ptr。如从函数返回一个 unique_ptr</p>
<p>​                unique_ptr<int> clone(int p) {    unique_ptr<int> ret(new int(p));    return ret; }              </p>
<p>上面这种情况，编译器知道要返回的对象将要被销毁，在此情况下，编译器执行一种特殊的拷贝。</p>
<p><strong>向 unique_ptr 传递删除器</strong></p>
<p>类似 shared_ptr，unique_ptr 默认情况下使用 delete 释放它指向的对象。可以重载 unique_ptr 中默认的删除器。</p>
<p>但 unique_ptr 管理删除器的方式与 shared_ptr 不一样。<strong>unique_ptr 将删除器放在尖括号中</strong></p>
<p>因为对于 unique_ptr 来说，删除器的类型是构成 unique_ptr 类型的一部分。</p>
<p><strong>auto_ptr</strong></p>
<p>auto_ptr 是标准库的较早版本包含的一个类，它具有 unique_ptr 的部分特性。相比于 unique_ptr，不能在容器中保存 auto_ptr，也不能从函数返回 auto_ptr。</p>
<p><strong>错误案例</strong></p>
<p>​                int ix = 1024, *pi = &amp;ix, *pi2 = new int(2048); unique_ptr<int> p0(ix);      // 错误：从 int 到 unique_ptr<int> 的无效的转换 unique_ptr<int> p1(pi);      // 运行时错误：当 p1 被销毁时会对 pi 调用 delete，这是一个对非动态分配返回的指针调用 delete 的错误。 unique_ptr<int> p2(pi2);     // 不会报错，但当 p2 被销毁后会使 pi2 成为一个悬空指针 unique_ptr<int> p3(new int(2048));   // 正确，推荐的用法              </p>
<p><strong>12.1.6 weak_ptr</strong></p>
<p>weak_ptr 指向一个由 shared_ptr 管理的对象，它不控制所指向对象的生存期。</p>
<p>将一个 weak_ptr 绑定到 shared_ptr 不会改变 shared_ptr 的引用计数。</p>
<p>如果 shared_ptr 都被销毁，即使还有 weak_ptr 指向对象，对象依然会释放（因此不能使用 weak_ptr 直接访问对象）。</p>
<p><strong>weak_ptr 初始化</strong></p>
<p>创建 weak_ptr 时，要用 shared_ptr 来初始化它。</p>
<p>​                weak_ptr<T> w;         // 默认初始化，定义一个空 weak_ptr w，w 可以指向类型为 T 的对象 w = p;                 // p 可以是一个 shared_ptr 或 weak_ptr，赋值后 w 与 p 共享对象 weak_ptr<T> w(sp);     // 定义一个与 shared_ptr sp 指向相同对象的 weak_ptr。T 必须能转换成 sp 指向的类型（不必相同）              </p>
<p><strong>weak_ptr 操作</strong></p>
<p>因为 weak_ptr 的对象可能被释放的，因此不能直接访问对象，必须调用 lock()。lock() 检查 weak_ptr 所指的对象是否仍存在，如果存在，返回一个指向共享对象的 shared_ptr。</p>
<p>理解：返回的这个 shared_ptr 会使引用计数加 1。</p>
<p>​                w = p;            // p 可以是一个 shared_ptr 或 weak_ptr。赋值后 w 与 p 共享对象。 w.reset();        // 将 w 置为空 w.use_count();    // 返回与 w 共享对象的 shared_ptr 的数量 w.expired();      // 若 w.use_count() 为 0，返回 true，否则返回 false。expired 是 “过期的” 意思 w.lock();         // 如果 w.expired 为 true，返回一个空 shared_ptr；否则返回一个指向 w 的对象的 shared_ptr              </p>
<p><strong>weak_ptr 操作的应用</strong></p>
<p>​                if(shared_ptr<int> np = wp.lock())  // 如果 np 不为空则条件成立              </p>
<p><strong>一个实例：StrBlobPtr类</strong></p>
<p>StrBlobPtr 类起到一个充当 StrBlob 迭代器的作用，指向 StrBlob 管理的容器中的某个元素。</p>
<p>StrBlobPtr 构造函数接受的是 StrBlob 的非常量引用，因此无法使用 const StrBlob，如果想要使用，那需要再定一个 ConstStrBlobPtr 类。</p>
<p>​                class StrBlobPtr { public:   StrBlobPtr() : curr(0) {}   StrBlobPtr(StrBlob &amp;a, size_t sz = 0) : wptr(a.data), curr(sz) {}    string &amp;deref() const;   StrBlobPtr &amp;incr();   bool operator!=(const StrBlobPtr &amp;rhs) const { return this-&gt;curr != rhs.curr; } private:   shared_ptr&lt;vector<string>&gt; check(std::size_t, const string &amp;msg) const; //不能在 const 成员函数内调用本类的非 const 成员函数，调用的必须也是 const 成员函数 private:   weak_ptr&lt;vector<string>&gt; wptr;   size_t curr; }; shared_ptr&lt;vector<string>&gt; StrBlobPtr::check(std::size_t sz, const string &amp;msg) const{   auto ret = wptr.lock();   if (!ret) throw std::runtime_error(“unbound StrBlobPtr”);    //检查 wptr 是否绑定了一个 StrBlob   if (sz &gt;= ret-&gt;size()) throw std::out_of_range(“msg”);   return ret; } string &amp;StrBlobPtr::deref() const {    //const 成员函数在定义时也要加上 const   auto p = check(curr, “dereference past end”);   return (*p)[curr]; } StrBlobPtr &amp;StrBlobPtr::incr(){   check(curr, “increment past end of StrBlobPtr”);   ++curr;   return *this; }              </p>
<p><strong>12.2 动态数组</strong></p>
<p>new 和 delete 运算符一次分配/释放一个对象。</p>
<p>C++ 中提供了两种<strong>一次分配一个对象数组</strong>的方法：</p>
<ol>
<li>使用如 new int[10] 来分配一个对象数组；</li>
<li>使用 <strong>allocator 类</strong>。allocator 类的优点是可以实现<strong>内存分配与对象构造的分离</strong>，更灵活地管理内存。</li>
</ol>
<p>一般不需要使用动态分配的数组，而是使用如 vector 之类的 STL 容器。使用容器的类可以使用默认版本的拷贝、赋值、析构等操作，而分配动态数组的类必须定义自己版本的函数在相关操作时管理内存。</p>
<p><strong>12.2.1 new和数组</strong></p>
<p>使用方括号来分配一个对象数组，new 分配成功后返回指向第一个对象的指针。</p>
<p>方括号中的大小必须是整型，但不必是常量。</p>
<p>​                int *pia = new int[get_size()];   // pia 指向第一个 int              </p>
<p>也可以使用一个表示数组类型的类型别名来分配一个数组。</p>
<p>​                typedef int arrT[42];   // arrT 表示 42 个 int 的数组类型。 int *p = new arrT;      //分配一个包含 42 个 int 的数组；p 指向第一个 int              </p>
<p><strong>分配一个数组得到一个元素类型的指针</strong></p>
<p>虽然常把 new T[] 分配的内存叫做动态数组，但是实际上它并不是一个数组，而只是返回<strong>第一个元素的指针</strong>。</p>
<p>理解：数组类型是包含其维度的，而 new 分配动态数组时提供的大小不必是常量，这正是因为它并非分配了一个“数组类型”。</p>
<p>因为动态数组不是数组类型所以不能对它调用 begin() 或 end() 函数（这两个函数根据数组维度返回指向首元素和尾后元素的指针），也不能使用范围 for 语句来处理动态数组。</p>
<p><strong>初始化动态分配对象的数组</strong></p>
<p>默认情况下 new 分配的对象不管是单个的还是动态数组，都是默认初始化的。</p>
<p>可以对动态数组进行值初始化和列表初始化</p>
<p>​                int *pia = new int[10];       // 10 个未初始化的 int int *pia2 = new int<a href="">10</a>;    // 10 个值初始化为 0 的 int int *pia3 = new int[10]{0, 1, 2, 3, 4, 5};  // 前 5 个元素用给定的值初始化，剩余的进行值初始化              </p>
<p>可以用空括号对数组中的元素进行值初始化，但不能在括号中给出初始化器，因此也不能使用 auto 分配数组。</p>
<p>因为值初始化时不能提供参数，所以没有默认构造函数的类是无法动态分配数组的。</p>
<p><strong>动态分配一个空数组是合法的</strong></p>
<p>虽然不能创建一个大小为 0 的数组对象，但当 n=0 时，调用 new int[n] 是合法的，它返回一个合法的非空指针。此指针保证与 new 返回的其他任何指针都不相同。</p>
<p>对零长度的数组来说，此指针就像尾后指针一样，不能解引用，但是可以用在循环的终止条件判断中。</p>
<p><strong>释放动态数组</strong></p>
<p>使用 delete [] 来释放动态数组</p>
<p>​                delete p;           // p 必须指向一个动态分配的对象或为空 delete [] pa;       // pa 必须指向一个动态分配的数组或为空              </p>
<p>使用 delete [] 会将动态数组中的元素按逆序销毁并释放内存。</p>
<p>如果在 delete 一个指向动态数组的指针时忽略了方括号，行为是未定义的。</p>
<p><strong>智能指针和动态数组-unique_ptr</strong></p>
<p>标准库提供了一个可以管理 new 分配的数组的 unique_ptr 版本。这一版本的 unique_ptr 自动使用 delete[] 来释放数组。</p>
<p>​                unique_ptr&lt;int[]&gt; up(new int[10]);          // up 指向一个包含 10 个未初始化 int 的数组 for(size_t i=0; i!=10; ++i)   up[i] = i;    // 可以通过 up 使用下标运算符来访问数组中的元素 up.release();                               // 自动使用 delete[] 销毁其指针              </p>
<p>指向数组的 unique_ptr 不支持成员访问运算符（点和箭头），但支持通过下标访问数组中的元素。</p>
<p>​                unique_ptr&lt;T[]&gt; u      // u 可以指向一个动态分配的数组，数组元素类型为 T unique_ptr&lt;T[]&gt; u(p)   // u 指向内置指针 p 所指向的动态分配的数组，p 必须能转换为类型 T* u[i]                   // 返回 u 拥有的数组中位置 i 处的对象              </p>
<p><strong>智能指针和动态数组-shared_ptr</strong></p>
<p>shared_ptr 不支持直接管理动态数组。如果希望使用 shared_ptr 管理动态数组，需要为它提供一个删除器。</p>
<p>​                shared_ptr<int> sp(new int[10], [](int* p) { delete[] p; }); sp.reset();    //使用上面提供的 lambda 释放数组              </p>
<p>如果不提供删除器，shared_ptr 将会使用 delete 来销毁动态数组，这种行为是未定义的。</p>
<p>shared_ptr 不直接支持动态数组管理，所以要访问数组中的元素需要使用 get()</p>
<p>​                for(size_t i = 0; i != 10; ++i)    *(sp.get() + i) = i;    // 使用 get() 获取一个内置指针，然后来访问元素。              </p>
<p><strong>12.2.2 allocator类</strong></p>
<p>new 有一个局限性是它将内存分配和对象构造结合在了一起，对应的 delete 将对象析构和内存释放结合在了一起。</p>
<p>标准库 <strong>allocator 类</strong>定义在<strong>头文件 memory</strong> 中，可以实现内存分配与对象构造的分离。</p>
<p><strong>allocator 是一个类模板</strong>。定义时需指出这个 allocator 可以分配的对象类型，它会根据对象类型来分配恰当的内存。</p>
<p><strong>allocator 的定义与操作</strong></p>
<p>下面的 string 可以替换为其他类型。</p>
<p>​                allocator<string> alloc;            // 定义一个可以分配 string 的 allocator 对象 auto const p = alloc.allocate(n);   // 分配 n 个未初始化的 string，返回一个 string* 指针 alloc.construct(p, args);           // p 是一个 string* 指针，指向原始内存。arg 被传递给 string 的构造函数，用来在 p 指向的内存中构造对象。 alloc.destory(p);                   // p 是一个 string* 指针，此算法对 p 指向的对象执行析构函数  alloc.deallocate(p, n);             // 释放从 p 开始的长度为 n 的内存。p 是一个 allocate() 返回的指针，n 是 p 创建时要求的大小。                                    // 在 deallocate 之前必须先 destory 掉这块内存中创建的每个对象。                 </p>
<p>理解：定义的 allocator 对象是一个工具，这个工具可以管理指定类型的内存分配、对象构造、对象销毁、内存释放四种操作，且这四种操作是分开的，分别对应一个函数。</p>
<p><strong>allocator 分配未构造的内存</strong></p>
<p>allocator 分配的内存是未构造的，需要使用 <strong>construct 成员函数</strong>按需在内存中构造对象。</p>
<p>construct 成员函数接受一个指针和零个或多个额外参数，在给定位置构造一个元素，额外参数用来初始化构造的对象。</p>
<p>​                alloc.construct(q++);               // 在 q 指向的位置构造一个空字符串并递增 q。q 应该指向最后构造的元素之后的位置。 alloc.construct(q++, 5, ‘c’);       // 在 q 指向的位置构造一个 “ccccc” 并递增 q。              </p>
<p>还未构造对象就使用原始内存的结果是未定义的，可能造成严重后果。</p>
<p><strong>destory 销毁对象</strong></p>
<p>使用完对象后，必须对每个构造的元素都调用 destory 来摧毁它们。</p>
<p>destory 接受一个指针，对指向的对象执行析构函数。注意只能对构造了的元素执行 destory 操作。</p>
<p>元素被销毁后可以重新在这块内存构造对象也可以释放掉内存。</p>
<p>construct 和 destory 一次都只能构造或销毁一个对象，要想完成对所有元素的操作，需要通过指针来遍历对每个元素进行操作。</p>
<p><strong>deallocate 释放内存</strong></p>
<p>传递给 deallocate 的 p 必须指向由 allocate 分配的内存，大小参数 n 必须与 allocate 分配内存时提供的大小参数一样。</p>
<p>​                alloc.deallocate(p, n);              </p>
<p><strong>拷贝和填充未初始化内存的算法</strong></p>
<p>除了使用 construct 构造对象外，标准库还提供了两个伴随算法，定义在<strong>头文件 memory</strong> 中，他们在给定的位置创建元素。</p>
<p>​                uninitialized_copy(b, e, b2);     // 从迭代器 b 和 e 指定的输入范围中拷贝元素到从迭代器 b2 开始的未构造的原始内存中。b2 指向的内存需要足够大。 uninitialized_copy_n(b, n, b2);   // 从迭代器 b 指向的元素开始，拷贝 n 个元素到 b2 开始的内存中。 uninitialized_fill(b, e, t);      // 在 b 和 e 指定的范围内创建对象，对象均为 t 的拷贝 uninitialized_fill_n(b, n, t);    // 在从 b 开始的 n 个位置创建对象，对象均为 t 的拷贝。              </p>
<p>uninitialized_copy 函数返回指向构造的最后一个元素之后位置的指针。</p>
<p>比如希望将一个 vector 拷贝到动态内存中，并对后一半空间用给定值填充。</p>
<p>​                allocator<int> alloc; auto p = alloc.allocate( v.size() * 2 ); auto q = uninitialized_copy( v.begin(), v.end(), p ); uninitialized_fill_n( q,v.size(),42);              </p>
<p><strong>12.3 使用标准库：文本查询程序</strong></p>
<p>文本查询程序要实现的功能：允许用户在一个给定文件中查询单词。查询结果是单词在文件中出现的次数及其所在行的列表（包括行号及对应文本），如果一个单词在一行中出现多次，此行只列出一次。</p>
<p><strong>12.3.1 文本查询程序设计</strong></p>
<p><strong>需求分析</strong></p>
<p>要实现以上功能，此文本查询程序要做的工作：</p>
<ol>
<li>程序读取输入文件时，需要记住单词出现的每一行，并将每一行分解为独立的单词。</li>
<li>程序生成输出时，需要能提取每个单词关联的行号，行号按升序出现且无重复，且能打印给定行号中的文本。</li>
</ol>
<p><strong>数据结构设计</strong></p>
<p>使用以下成员存储所需数据：</p>
<ol>
<li>一个 vector：按行存储从文件中读取的文本，每一个 string 元素代表一行。</li>
<li>使用 istringstraem 来将行文本分解为单词。</li>
<li>一个 map&gt;：存储文件中的每个单词及其对应的行号列表，键 string 为单词，键值 set 为对应的行号列表，set 保证每行只出现一次且行号按升序保存。</li>
</ol>
<p><strong>类的设计</strong></p>
<p>定义两个类：一个类 TextQuery 负责保存从输入文件读取到的内容，提供 “读取输入文件” 和 “查询内容” 两个接口；</p>
<p>此外，因为我们要的返回结果包含多种内容（单词出现次数、所有关联行号及对应文本），为了一次性地将查询结果返回（而不是一个又一个的变量），还要<strong>定义一个类 QueryResult 用来保存所有查询结果</strong>。这个类有一个 print 函数，完成结果打印工作。</p>
<p><strong>在类之间共享数据</strong></p>
<p>进一步地设计：</p>
<ol>
<li>QueryResult 要包含的内容包括单词出现次数、所有关联行号及对应文本，如果这些数据都拷贝得话会浪费时间，因此最好通过获取指针来避免拷贝操作。</li>
<li>使用了指针后 QueryResult 就和 TextQuery 共享了数据，这时如果 TextQuery 先销毁了就会导致 QueryResult 引用不存在地数据。因此应该使用 shared_ptr 来共享数据。</li>
</ol>
<p><strong>使用TextQuery类</strong></p>
<p>设计一个类时，在真正实现类的成员前先编写使用这个类的程序，是一种非常有用的方法。这可以看到类是否具有我们所需要的操作。</p>
<p>​                void runQueries(ifstream&amp; infile) {    TextQuery tq(infile);  // 用指向文件的输入流初始化类，初始化时完成保存文件、建立查询 map 的工作。    while(true) {        cout &lt;&lt; “enter word to look for, or q to quit: “;        string s;        if(!(cin &gt;&gt; s) || s == “q”) break;        print(cout, tq.query(s)) &lt;&lt; endl; // 查询并打印结果    } }              </p>
<p><strong>12.3.2 文本查询程序类的定义</strong></p>
<p><strong>TextQuery的定义</strong></p>
<p>​                class TextQuery {   friend class QueryResult;   using line_no = std::vector<a class="link"   href="std::string" >std::string<i class="fas fa-external-link-alt"></i></a>::size_type; public:   TextQuery(std::ifstream &amp;in_file);   ~TextQuery() = default;       QueryResult query(const std::string &amp;word) const; private:   std::shared_ptr&lt;std::vector<a class="link"   href="std::string" >std::string<i class="fas fa-external-link-alt"></i></a>&gt; text_lines_;   std::map&lt;std::string, std::shared_ptr&lt;std::set<line_no>&gt;&gt; word_indexs_; };              </p>
<p><strong>TextQuery构造函数</strong></p>
<p>​                TextQuery::TextQuery(std::ifstream &amp;in_file) : text_lines_(std::make_shared&lt;std::vector<a class="link"   href="std::string" >std::string<i class="fas fa-external-link-alt"></i></a>&gt;()) {   std::string line_temp;   while (std::getline(in_file, line_temp))   {     text_lines_-&gt;push_back(line_temp);     int line_num = text_lines_-&gt;size() - 1; // 当前行号     std::istringstream in_line(line_temp);     std::string word;     while (in_line &gt;&gt; word) // 读取空格分隔的单词直接用 &gt;&gt; 运算符即可     {       auto &amp;lines = word_indexs_[word];     // lines 是一个 shared_ptr 的引用       if (!lines)                // 如果 word_indexs_ 中不存在 word，那么 lines 会是一个空指针         lines.reset(new std::set<line_no>()); // 分配一个新的 set       lines-&gt;insert(line_num);         // 插入当前行号     }   } }              </p>
<p><strong>QueryResult的定义</strong></p>
<p>​                class QueryResult {   friend std::ostream &amp;print(std::ostream &amp;os, const QueryResult &amp;qr);   using line_no = std::vector<a class="link"   href="std::string" >std::string<i class="fas fa-external-link-alt"></i></a>::size_type; public:   QueryResult(std::string word,         std::shared_ptr&lt;std::set<line_no>&gt; word_index,         std::shared_ptr&lt;std::vector<a class="link"   href="std::string" >std::string<i class="fas fa-external-link-alt"></i></a>&gt; text_lines) : word_(word), word_index_(word_index), text_lines_(text_lines) {} private:   std::string word_;   std::shared_ptr&lt;std::set<line_no>&gt; word_index_;   std::shared_ptr&lt;std::vector<a class="link"   href="std::string" >std::string<i class="fas fa-external-link-alt"></i></a>&gt; text_lines_; };              </p>
<p><strong>query函数</strong></p>
<p>直接返回 QueryResult 即可，不必将其作为参数传入其中。</p>
<p>​                QueryResult TextQuery::query(const std::string &amp;word) const // 注意：函数定义时也要加 const {   if (word_indexs_.find(word) == word_indexs_.end())     return QueryResult(word, std::make_shared&lt;std::set<line_no>&gt;(), text_lines_);   else     return QueryResult(word, word_indexs_.at(word), text_lines_); }              </p>
<p><strong>打印结果</strong></p>
<p>print 函数的定义遵循了标准库中 print 函数的惯例，第一个参数和返回值都是流。</p>
<p>​                std::ostream &amp;print(std::ostream &amp;os, const QueryResult &amp;qr) {   os &lt;&lt; qr.word_ &lt;&lt; “ occurs “ &lt;&lt; qr.word_index_-&gt;size() &lt;&lt; “ times “ &lt;&lt; std::endl;   for (auto num : *qr.word_index_)     os &lt;&lt; “\t(line “ &lt;&lt; num + 1 &lt;&lt; “) “ &lt;&lt; *(qr.text_lines_-&gt;begin() + num) &lt;&lt; std::endl;   return os; }              </p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第十一章 关联容器</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第一章 开始</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">王秋鹏</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
