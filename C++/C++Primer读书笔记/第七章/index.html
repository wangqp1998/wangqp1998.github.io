<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="王秋鹏">
    
    <title>
        
            C++ Primer 第七章 类 |
        
        wangqp
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                wangqp
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/c/"
                            >
                                C++
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/Codeing/"
                            >
                                数据结构与算法
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                            >
                                系统编程与网络编程
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%95%B0%E6%8D%AE%E5%BA%93/"
                            >
                                数据库
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E9%A1%B9%E7%9B%AE"
                            >
                                项目
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/c/">C++</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/Codeing/">数据结构与算法</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">系统编程与网络编程</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E9%A1%B9%E7%9B%AE">项目</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">C++ Primer 第七章 类</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">王秋鹏</span>
                        
                            <span class="author-label">Lv3</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2021-09-10 00:00:00</span>
        <span class="mobile">2021-09-10 00:00</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <p>类的基本思想：数据抽象和封装</p>
<p>封装：将接口和实现分离</p>
<h5 id="7-0-积累总结"><a href="#7-0-积累总结" class="headerlink" title="7.0 积累总结"></a><strong>7.0 积累总结</strong></h5><h6 id="7-0-0-类的-const-成员函数"><a href="#7-0-0-类的-const-成员函数" class="headerlink" title="7.0.0 类的 const 成员函数"></a><strong>7.0.0 类的 const 成员函数</strong></h6><p>const 成员函数不会修改类的数据成员。</p>
<p>const 成员函数的声明和定义处都要加 const，声明方式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">age</span><span class="params">()</span> <span class="type">const</span></span>;<span class="comment">//在类内的声明</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Student::age</span><span class="params">()</span> <span class="type">const</span> </span>&#123;&#125;;<span class="comment">//在类外的定义</span></span><br></pre></td></tr></table></figure>

<p>使用 const 成员函数要注意，<strong>不能用它调用本类的非 const 成员函数</strong>，调用的也必须是 const 成员函数。</p>
<h6 id="7-0-1-关于类的-private-成员的访问权限"><a href="#7-0-1-关于类的-private-成员的访问权限" class="headerlink" title="7.0.1 关于类的 private 成员的访问权限"></a><strong>7.0.1 关于类的 private 成员的访问权限</strong></h6><p>在类的成员函数中<strong>可以访问同类型实例的私有成员。</strong></p>
<h5 id="7-1-定义抽象数据类型"><a href="#7-1-定义抽象数据类型" class="headerlink" title="7.1 定义抽象数据类型"></a><strong>7.1 定义抽象数据类型</strong></h5><h6 id="7-1-1-设计sales-data类"><a href="#7-1-1-设计sales-data类" class="headerlink" title="7.1.1 设计sales_data类"></a><strong>7.1.1 设计sales_data类</strong></h6><p>设计类的接口时，要考虑如何使类易于使用。当使用类时，不应该顾及类的实现机理。</p>
<h6 id="7-1-2-定义改进的sales-data类"><a href="#7-1-2-定义改进的sales-data类" class="headerlink" title="7.1.2 定义改进的sales_data类"></a><strong>7.1.2 定义改进的sales_data类</strong></h6><p>定义在类内部的函数是隐式的inline函数</p>
<h6 id="7-1-3-定义类相关的非成员函数"><a href="#7-1-3-定义类相关的非成员函数" class="headerlink" title="7.1.3 定义类相关的非成员函数"></a><strong>7.1.3 定义类相关的非成员函数</strong></h6><p>空</p>
<h6 id="7-1-4-构造函数"><a href="#7-1-4-构造函数" class="headerlink" title="7.1.4 构造函数"></a><strong>7.1.4 构造函数</strong></h6><p>构造函数用来初始化类对象的数据成员。当类的对象被创建时，就会执行构造函数</p>
<p>构造函数没有返回类型。</p>
<p>构造函数可以重载。</p>
<p>如果类没有任何构造函数则编译器自己会创建默认构造函数（适用范围很小，尽量不要如此）</p>
<h6 id="7-1-5-拷贝、赋值和折构"><a href="#7-1-5-拷贝、赋值和折构" class="headerlink" title="7.1.5 拷贝、赋值和折构"></a><strong>7.1.5 拷贝、赋值和折构</strong></h6><p>对于拷贝、赋值和销毁对象等操作，类都通过相应的成员函数实现其功能，如果不主动定义这些操作，编译器就合成默认的版本。</p>
<p>对于某些类来说，无法使用默认合成的版本，比如管理动态内存的类就不能。</p>
<h5 id="7-2-访问控制与封装"><a href="#7-2-访问控制与封装" class="headerlink" title="7.2 访问控制与封装"></a><strong>7.2 访问控制与封装</strong></h5><p>class 和 struct 的<strong>唯一一点区别</strong>就是默认访问权限不同。</p>
<p><strong>当希望类的所有成员是 public 时，用struct</strong></p>
<h6 id="7-2-1-友元"><a href="#7-2-1-友元" class="headerlink" title="7.2.1 友元"></a><strong>7.2.1 友元</strong></h6><p>类可以允许其他类或函数访问它的非公有成员，方法就是令其他函数或类成为它的<strong>友元****。</strong></p>
<p>要将一个函数作为类的友元，只需在类内部加一条关键字 friend 开头的函数声明语句即可。</p>
<p><strong>友元声明只能出现在类的内部</strong>，但是具体位置不限，不是类的成员，<strong>不受public、private 限制</strong>。</p>
<p>最好在类的开始或结束位置集中声明友元。</p>
<p><strong>友元的声明</strong></p>
<p>类内对友元的声明只是指定了访问权限，并<strong>不是通常意义上的函数声明</strong>。如果要调用友元函数，还需要在类的外部再次声明。<strong>并且要在调用位置之前声明。</strong></p>
<h5 id="7-3-类的其他特性"><a href="#7-3-类的其他特性" class="headerlink" title="7.3 类的其他特性"></a><strong>7.3 类的其他特性</strong></h5><p>类的其他特性还有：类型成员、类的成员的类内初始值、可变数据成员、内联成员函数、从成员函数返回 *this</p>
<h6 id="7-3-1-类成员再探"><a href="#7-3-1-类成员再探" class="headerlink" title="7.3.1 类成员再探"></a><strong>7.3.1 类成员再探</strong></h6><p><strong>定义类型成员</strong></p>
<p>类可以自定义某种类型在类内的别名。类型成员一样有访问限制。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type pos;<span class="comment">//</span></span><br><span class="line"><span class="keyword">using</span> pos = string::size_type;<span class="comment">//使用类型别名，两种方式都可以</span></span><br></pre></td></tr></table></figure>

<p><strong>类型成员必须先定义后使用</strong>，因此类型成员应该出现在类开始的地方。</p>
<p><strong>默认构造函数</strong></p>
<p>当定义了构造函数，不会再有默认构造函数，如果需要必须显式声明，如下</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Student</span>() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>

<p><strong>类内初始值</strong></p>
<p>成员变量可以在类内定义的时候直接初始化。</p>
<p>此时构造函数的初始化列表可以不包含该成员变量，隐式使用其类内初始值。</p>
<p>类内初始值必须使用等号或花括号初始化。</p>
<p><strong>内联成员函数</strong></p>
<p><strong>4</strong>种方式使成员成为内联函数：</p>
<ol>
<li>在类内定义函数，为隐式内联。</li>
<li>在类内用关键字 inline 显式声明成员函数。</li>
<li>在类外用关键字 inline 定义成员函数。</li>
<li>同时在类内类外用 inline 修饰</li>
</ol>
<p>inline 成员函数应该与类定义在同一个头文件中</p>
<p><strong>可变数据成员</strong></p>
<p>const 成员函数不能修改成员变量。</p>
<p>但是用 <strong>mutable</strong> 将成员修饰为可变数据成员，就可以修改了。</p>
<h6 id="7-3-2-返回-this的成员函数"><a href="#7-3-2-返回-this的成员函数" class="headerlink" title="7.3.2 返回*this的成员函数"></a><strong>7.3.2 返回*this的成员函数</strong></h6><p>this 指针指向类本身，即 this 是类的地址，*this 就是类本身。</p>
<p>可以<strong>定义****返回类型为类对象的引用的函数</strong>。如果定义的返回类型不是引用，返回的就是*this 的副本了。</p>
<p>const 函数如果以引用的形式返回 this，返回类型就是一个常量引用。</p>
<h6 id="7-3-3-类类型"><a href="#7-3-3-类类型" class="headerlink" title="7.3.3 类类型"></a><strong>7.3.3 类类型</strong></h6><p>一个类的成员类型不能是它自己，但是类允许包含指向它自身类型的引用或指针。</p>
<h6 id="7-3-4-友元再探"><a href="#7-3-4-友元再探" class="headerlink" title="7.3.4 友元再探"></a><strong>7.3.4 友元再探</strong></h6><p>可以把其他的类定义成友元，也可以把其他类的成员函数定义成友元。</p>
<p>如果一个类指定了友元类。则友元类的成员函数可以访问此类的所有成员。</p>
<p>友元关系不具有传递性。</p>
<p>重载函数名字相同，但是是不同的函数。如果想把一组重载函数声明为类的友元，需要对每一个分别声明。</p>
<h5 id="7-4-类的作用域"><a href="#7-4-类的作用域" class="headerlink" title="7.4 类的作用域"></a><strong>7.4 类的作用域</strong></h5><p>当类的成员函数的返回类型也是类的成员时，在定义它时要指明类</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Student::age <span class="title">Student::Getage</span><span class="params">()</span></span>&#123;&#125;     </span><br></pre></td></tr></table></figure>

<h6 id="7-4-1-名字查找与类的作用域"><a href="#7-4-1-名字查找与类的作用域" class="headerlink" title="7.4.1 名字查找与类的作用域"></a><strong>7.4.1 名字查找与类的作用域</strong></h6><p><strong>普通程序名字查找的过程</strong></p>
<ol>
<li>首先在名字所在的块中寻找声明语句</li>
<li>如果没找到，继续查找外层作用域</li>
<li>如果最终还是没找到，报错</li>
</ol>
<p><strong>类的定义过程</strong></p>
<ol>
<li>首先，编译成员的声明。</li>
<li>直到全部类可见后才编译函数体。</li>
</ol>
<p>特殊：在类内定义的类型名要放在类的开始，放在后面其他成员是看不见的。</p>
<p>类型名如果在类外已经定义过，不能在类内重定义。</p>
<p>不建议使用其他成员的名字作为某个成员函数的参数。</p>
<h5 id="7-5-构造函数再探"><a href="#7-5-构造函数再探" class="headerlink" title="7.5 构造函数再探"></a><strong>7.5 构造函数再探</strong></h5><h6 id="7-5-1-构造函数初始值列表"><a href="#7-5-1-构造函数初始值列表" class="headerlink" title="7.5.1 构造函数初始值列表"></a><strong>7.5.1 构造函数初始值列表</strong></h6><p>使用初始值列表对类的成员初始化才是真正的初始化，在构造函数的函数体内赋值并不是初始化。</p>
<p>如果定义构造函数，必须对类的所有数据成员初始化或赋值。</p>
<p>如果成员是 <strong>const 或者是引用的话，必须初始化</strong>。</p>
<p>如果成员是类并且该类没有定义构造函数的话，必须初始化。（如果该类定义了构造函数的话，就不用了）</p>
<p>使用初始值列表初始成员时，成员初始化的顺序是按照类定义种出现的顺序初始化的。</p>
<p><strong>默认实参和构造函数</strong></p>
<p>如果一个构造函数为所有参数提供了默认实参，则<strong>它实际上相当于定义了默认构造函数</strong>。</p>
<h6 id="7-5-2-委托构造函数"><a href="#7-5-2-委托构造函数" class="headerlink" title="7.5.2 委托构造函数"></a><strong>7.5.2 委托构造函数</strong></h6><p><strong>委托构造函数</strong>通过其他构造函数来执行自己的初始化过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Student</span>(string nameIn,<span class="type">int</span> ageIn):<span class="built_in">name</span>(nameIn),<span class="built_in">age</span>(ageIn)&#123;&#125;</span><br><span class="line">    <span class="built_in">Student</span>():<span class="built_in">Student</span>(<span class="string">&quot; &quot;</span>,<span class="number">18</span>)&#123;&#125; <span class="comment">//这就是委托构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(string s):<span class="built_in">Student</span>(s,<span class="number">18</span>)&#123;&#125; <span class="comment">//这也是委托构造函数</span></span><br><span class="line">&#125;        </span><br></pre></td></tr></table></figure>

<h6 id="7-5-3-默认构造函数的作用"><a href="#7-5-3-默认构造函数的作用" class="headerlink" title="7.5.3 默认构造函数的作用"></a><strong>7.5.3 默认构造函数的作用</strong></h6><p>在实际中，如果定义了其他构造函数，<strong>最好也提供一个默认构造函数</strong>。</p>
<h6 id="7-5-4-隐式的类类型转换"><a href="#7-5-4-隐式的类类型转换" class="headerlink" title="7.5.4 隐式的类类型转换"></a><strong>7.5.4 隐式的类类型转换</strong></h6><p>如果构造函数只接受一个实参，则称作<strong>转换构造函数</strong>，它实际上定义了转换为此类类型的隐式转换机制。</p>
<p><strong>一个实参的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则</strong></p>
<p><strong>只允许一步类型转换</strong></p>
<p>在进行隐式转换时，编译器只会自动地执行一步类型转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string null_book = <span class="string">&quot;9-999&quot;</span>;</span><br><span class="line">item.<span class="built_in">combine</span>(null_book); <span class="comment">//conbine 函数接受 Sales_data 类类型，但该类定义了一个接受 string 参数的转换构造函数，所以这里会执行从 string 到该类类型的隐式转换，是正确的。</span></span><br><span class="line"></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="string">&quot;9-999&quot;</span>); <span class="comment">//隐式地使用了两种转换规则，所以是错误的。</span></span><br><span class="line">item.<span class="built_in">combine</span>(<span class="built_in">string</span>(<span class="string">&quot;9-999&quot;</span>)); <span class="comment">//先显示地转换为 string，再隐式地转换为 Sales_data 类类型。是正确的。</span></span><br></pre></td></tr></table></figure>

<p><strong>explicit-抑制构造函数定义的隐式转换</strong></p>
<p>将转换构造函数声明为 explicit 会阻止隐式转换。</p>
<p>关键字 explicit 只对一个实参的构造函数有效。因为需要多个实参的构造函数本来就不执行隐式转换。</p>
<p>explicit 只在类内声明构造函数时使用，在类外定义时不加。类似 static 成员函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Sales_data</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:    </span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="type">const</span> string&amp; s)</span> : bookNo(s) &#123;</span> &#125; <span class="comment">//不能再执行从 string 到 Sales_data 的隐式转换。</span></span><br><span class="line"><span class="keyword">private</span>    </span><br><span class="line">    string bookNo;   </span><br><span class="line">&#125;</span><br><span class="line">iter.<span class="built_in">combine</span>(null_book);   <span class="comment">//错误，不能执行从 string 到 Sales_data 的隐式初始化 </span></span><br></pre></td></tr></table></figure>

<p><strong>explicit 构造函数只能用于直接初始化</strong></p>
<p>explicit 构造函数只能用于直接初始化，不能用于使用 “=” 的拷贝初始化。理解：因为 “=” 实际上是采用了拷贝赋值运算符，在传参时会进行隐式转换。</p>
<p>理解：不加 explicit 的转换构造函数，可以在赋值、传参、从函数返回等场合执行隐式转换，加了 explicit 后，就不能隐式转换了，也就是加了 explicit 的转换构造函数的意义就只是定义了一个新的构造函数，不具有提供隐式转换机制的额外功能了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data <span class="title">item1</span><span class="params">(null_book)</span></span>;  <span class="comment">//正确</span></span><br><span class="line">Sales_data item2 = null_book; <span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<p><strong>为转换显式地使用构造函数</strong></p>
<p>explicit 只是阻止了构造函数进行隐式转换，但是在传递实参时可以显式转换。</p>
<p>可以使用 explicit 的构造函数显式地强制进行转换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iter.<span class="built_in">combine</span>(<span class="built_in">static_cast</span>&lt;Sales_data&gt;(null_book));  <span class="comment">//正确，static_cast 可以使用 explicit 的构造函数。</span></span><br><span class="line">iter.<span class="built_in">combine</span>(<span class="built_in">Sales_data</span>(null_book));  <span class="comment">//正确</span></span><br></pre></td></tr></table></figure>

<p><strong>标准库中有显式构造函数的类</strong></p>
<p>下面是常见的两个例子：</p>
<ol>
<li>接受一个单参数的 const char* 的 string 构造函数：不是 explicit 的</li>
<li>接受一个容量参数的 vector 构造函数：是 explicit 的</li>
</ol>
<h6 id="7-5-5-聚合类"><a href="#7-5-5-聚合类" class="headerlink" title="7.5.5 聚合类"></a><strong>7.5.5 聚合类</strong></h6><p>满足以下四个条件的类是聚合类：</p>
<ol>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类和 virtual 函数</li>
</ol>
<p>聚合类可以像结构体一样用花括号初始值列表初始化。如果花括号内元素数量少于类成员数量，靠后的成员将被值初始化。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student stu = &#123;<span class="string">&quot;Li Ming&quot;</span>,<span class="number">18</span>&#125;;</span><br></pre></td></tr></table></figure>

<h6 id="7-5-6-字面值常量类"><a href="#7-5-6-字面值常量类" class="headerlink" title="7.5.6 字面值常量类"></a><strong>7.5.6 字面值常量类</strong></h6><p><strong>constexpr 函数</strong>的参数和返回值都必须是字面值类型。</p>
<p>算术类型、引用和指针都是字面值类型，此外<strong>字面值常量类</strong>也是字面值类型。</p>
<p>字面值类型属于常量表达式，constexpr 就是用来声明常量表达式的。</p>
<p>聚合类属于字面值常量类。</p>
<p>如果不是聚合类，满足以下四个条件的类也是字面值常量类：</p>
<ol>
<li>数据成员都是字面值类型。</li>
<li><strong>类至少含有一个 constexpr 构造函数</strong></li>
<li>如果一个数据成员有类内初始值，则初始值必须是常量表达式（如果成员是类，则初始值必须使用成员自己的 constexpr 构造函数）</li>
<li>类必须使用析构函数的默认定义。</li>
</ol>
<p><strong>constexpr 构造函数</strong></p>
<p>类的构造函数不能是 const 的，但字面值常量类的构造函数可以是 constexpr 函数。</p>
<p>constexpr 构造函数可以声明成 =default 或 =delete。</p>
<p>constexpr 构造函数的函数体应该是空的（原因：constexpr 函数的函数体只能包含一条返回语句，而构造函数不能包含返回语句）</p>
<p>constexpr 构造函数必须初始化所有数据成员。初始值必须是常量表达式或使用其自己的 constexpr 构造函数。</p>
<p>使用前置关键字 constexpr 来声明 constexpr 构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Debug</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">Debug</span><span class="params">(<span class="type">bool</span> b=<span class="literal">true</span>)</span>:a(b)&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> a;</span><br><span class="line">&#125;;<span class="comment">//定义一个类记得加分号</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> Debug <span class="title">prod</span><span class="params">(<span class="literal">false</span>)</span></span>;<span class="comment">//定义一个 Debug 类型的对象。实参应为常量表达式。</span></span><br></pre></td></tr></table></figure>

<h5 id="7-6-类的静态成员"><a href="#7-6-类的静态成员" class="headerlink" title="7.6 类的静态成员"></a><strong>7.6 类的静态成员</strong></h5><p><strong>类的静态成员与类本身直接关联</strong>，而不是与类的对象保持关联。</p>
<p>静态成员可以是 public 或 private 的。</p>
<p>静态成员不与任何对象绑定在一起。</p>
<p>静态数据成员可以是常量、引用、指针、类等。</p>
<p>静态成员函数不包含 this 指针，不能声明为 const 的，不能在 static 函数体内使用 this 指针。</p>
<p>理解：因为 static 函数不能使用 this 指针，所以它是无法使用类的非 static 数据成员的。</p>
<p>使用作用域运算符可以直接访问静态成员。类的对象也可以直接访问静态成员</p>
<p><strong>定义静态成员</strong></p>
<p>可以在类内或类外定义静态成员。当在类外定义时，<strong>不能重复 static 关键字</strong>，static 只出现在类内的声明中。</p>
<p>只有 constexpr 类型的静态数据成员可以在类内初始化，但是也需要在类外定义。</p>
<p>其他的静态数据成员<strong>都在类内声明，类外定义并初始化</strong>。</p>
<p><strong>静态成员可以用的特殊场景</strong></p>
<p>静态数据成员可以是<strong>不完全类型</strong>，比如静态数据成员的类型可以是它所属的类类型本身。</p>
<p>静态成员可以作为默认实参。</p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AD%E7%AB%A0/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第六章 函数</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/C++/C++Primer%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E7%AC%AC%E5%85%AB%E7%AB%A0/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++ Primer 第八章 IO库</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">王秋鹏</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-5"><a class="nav-link" href="#7-0-%E7%A7%AF%E7%B4%AF%E6%80%BB%E7%BB%93"><span class="nav-text">7.0 积累总结</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#7-0-0-%E7%B1%BB%E7%9A%84-const-%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">7.0.0 类的 const 成员函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-0-1-%E5%85%B3%E4%BA%8E%E7%B1%BB%E7%9A%84-private-%E6%88%90%E5%91%98%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="nav-text">7.0.1 关于类的 private 成员的访问权限</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-1-%E5%AE%9A%E4%B9%89%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.1 定义抽象数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#7-1-1-%E8%AE%BE%E8%AE%A1sales-data%E7%B1%BB"><span class="nav-text">7.1.1 设计sales_data类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-1-2-%E5%AE%9A%E4%B9%89%E6%94%B9%E8%BF%9B%E7%9A%84sales-data%E7%B1%BB"><span class="nav-text">7.1.2 定义改进的sales_data类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-1-3-%E5%AE%9A%E4%B9%89%E7%B1%BB%E7%9B%B8%E5%85%B3%E7%9A%84%E9%9D%9E%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">7.1.3 定义类相关的非成员函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-1-4-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">7.1.4 构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-1-5-%E6%8B%B7%E8%B4%9D%E3%80%81%E8%B5%8B%E5%80%BC%E5%92%8C%E6%8A%98%E6%9E%84"><span class="nav-text">7.1.5 拷贝、赋值和折构</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-2-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="nav-text">7.2 访问控制与封装</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#7-2-1-%E5%8F%8B%E5%85%83"><span class="nav-text">7.2.1 友元</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-3-%E7%B1%BB%E7%9A%84%E5%85%B6%E4%BB%96%E7%89%B9%E6%80%A7"><span class="nav-text">7.3 类的其他特性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#7-3-1-%E7%B1%BB%E6%88%90%E5%91%98%E5%86%8D%E6%8E%A2"><span class="nav-text">7.3.1 类成员再探</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-3-2-%E8%BF%94%E5%9B%9E-this%E7%9A%84%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="nav-text">7.3.2 返回*this的成员函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-3-3-%E7%B1%BB%E7%B1%BB%E5%9E%8B"><span class="nav-text">7.3.3 类类型</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-3-4-%E5%8F%8B%E5%85%83%E5%86%8D%E6%8E%A2"><span class="nav-text">7.3.4 友元再探</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-4-%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">7.4 类的作用域</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#7-4-1-%E5%90%8D%E5%AD%97%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%B1%BB%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="nav-text">7.4.1 名字查找与类的作用域</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-5-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%8D%E6%8E%A2"><span class="nav-text">7.5 构造函数再探</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#7-5-1-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%88%9D%E5%A7%8B%E5%80%BC%E5%88%97%E8%A1%A8"><span class="nav-text">7.5.1 构造函数初始值列表</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-5-2-%E5%A7%94%E6%89%98%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">7.5.2 委托构造函数</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-5-3-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="nav-text">7.5.3 默认构造函数的作用</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-5-4-%E9%9A%90%E5%BC%8F%E7%9A%84%E7%B1%BB%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="nav-text">7.5.4 隐式的类类型转换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-5-5-%E8%81%9A%E5%90%88%E7%B1%BB"><span class="nav-text">7.5.5 聚合类</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#7-5-6-%E5%AD%97%E9%9D%A2%E5%80%BC%E5%B8%B8%E9%87%8F%E7%B1%BB"><span class="nav-text">7.5.6 字面值常量类</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#7-6-%E7%B1%BB%E7%9A%84%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-text">7.6 类的静态成员</span></a></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
