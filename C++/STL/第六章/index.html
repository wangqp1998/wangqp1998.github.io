<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="王秋鹏">
    
    <title>
        
        wangqp
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                wangqp
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/c/"
                            >
                                C++
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/Codeing/"
                            >
                                数据结构与算法
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                            >
                                系统编程与网络编程
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%95%B0%E6%8D%AE%E5%BA%93/"
                            >
                                数据库
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E9%A1%B9%E7%9B%AE"
                            >
                                项目
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"
                            >
                                杂七杂八
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about/"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/c/">C++</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/Codeing/">数据结构与算法</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">系统编程与网络编程</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E9%A1%B9%E7%9B%AE">项目</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/">杂七杂八</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about/">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation"></span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">王秋鹏</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-09-12 19:59:39</span>
        <span class="mobile">2022-09-12 19:59</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><p>质变算法是指运算过程中会改变区间内（迭代器所指）的元素内容。诸如拷贝（copy）、互换（swap）、替换（replace）、填写（fill）、删除（remove）、排列组合（permutation）、分割（partition）、随机重排（random shuffling）、排序（sort）等算法。</p>
<p>对应的非质变算法是指在运算过程中不会更改区间内（迭代器所指）的元素内容。诸如查找（find）、匹配（search）、计数（count）、巡访（for_each）、比较（equal，mismatch）寻找极值（max、min）等算法。</p>
<h2 id="数值算法"><a href="#数值算法" class="headerlink" title="数值算法"></a>数值算法</h2><h3 id="accumulate"><a href="#accumulate" class="headerlink" title="accumulate"></a>accumulate</h3><p>算法<code>accumulate</code>用来计算<code>init</code>和区间<code>[first, last)</code>内所有元素的总和。注意，一定需要提供一个初始值<code>init</code>，即便是区间所指内容为空时也能返回一个确定有意义的数值，而非一个随机数。当<code>init</code>为0时，即求解区间内的所有数之和。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ia[5] = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">vector&lt;int&gt; iv(ia, ia+5);</span><br><span class="line">cout &lt;&lt; accumulate(iv.bengin(), iv.end(), 0) &lt;&lt; endl;</span><br><span class="line">// 15,  i.e. 0+1+2+3+4+5</span><br><span class="line">cout &lt;&lt; accumulate(iv.bengin(). iv.end(), 0, minus&lt;int&gt;()) &lt;&lt; endl;</span><br><span class="line">// -15, i.e. 0-1-2-3-4-5</span><br></pre></td></tr></table></figure>

<h3 id="adjacent-difference"><a href="#adjacent-difference" class="headerlink" title="adjacent_difference"></a>adjacent_difference</h3><p>算法<code>adjacent_difference</code>用来计算区间<code>[first, last)</code>中相邻元素的差额。也就是说，它将<code>*first</code>赋值给<code>*result</code>，并针对<code>[first, last)</code>内的每个迭代器i，将<code>(i-*(i-1)</code>之值赋值给<code>*(result+(i-first))</code>。</p>
<p><code>adjacent_difference</code>是存储第一元素之值，然后储存后继元素之差值。这么做可以有足够的信息重建输入区间的原始内容。如果对区间值<code>1,2,3,4,5</code>执行<code>adjacent_difference</code>操作，得到的结果是<code>1,1,1,1,1</code>。（<code>adjacent_difference</code>和<code>partial_sum</code>互为逆运算，所以对此结果再次执行<code>partial_sum</code>时，便会获得原始区间值<code>1,2,3,4,5</code>）</p>
<h3 id="inner-product"><a href="#inner-product" class="headerlink" title="inner_product"></a>inner_product</h3><p>算法<code>inner_product</code>是能够计算区间<code>[first1, last1)</code>和区间<code>[first2, first2 + (last1 - first1))</code>的一般内积。同样需要提供一个明确的<code>init</code>值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int ia[5] = &#123; 1, 2, 3, 4, 5 &#125;;</span><br><span class="line">vector&lt;int&gt; iv(ia, ia+5);</span><br><span class="line">cout &lt;&lt; inner_product(iv.begin(), iv.end(), iv.begin(), 10) &lt;&lt; endl;</span><br><span class="line">// 65,  i.e. 10 + 1*1 + 2*2 + 3*3 + 4*4 + 5*5</span><br><span class="line">cout &lt;&lt; inner_product(iv.begin(), iv.end(), iv.begin(), 10, minus&lt;int&gt;(), plus&lt;int&gt;()) &lt;&lt; endl;</span><br><span class="line">// -20, i.e. 10 - 1+1 - 2+2 - 3+3 - 4+4 - 5+5</span><br></pre></td></tr></table></figure>

<h3 id="partial-sum"><a href="#partial-sum" class="headerlink" title="partial_sum"></a>partial_sum</h3><p>算法<code>partial_sum</code>用来计算局部总和。本算法返回输出区间的最尾端位置：<code>result+(last-first)</code>。</p>
<p>如果对区间<code>1,2,3,4,5</code>执行<code>partial_sum</code>，获得的结果为：<code>1,3,6,10,15</code>，再对此结果执行<code>adjacent_difference</code>就会得到原始区间：<code>1,2,3,4,5</code>。</p>
<hr>
<h2 id="基本算法"><a href="#基本算法" class="headerlink" title="基本算法"></a>基本算法</h2><h3 id="equal"><a href="#equal" class="headerlink" title="equal"></a>equal</h3><p>如果两个序列在区间<code>[first1, last1)</code>内相等，<code>equal()</code>返回true。如果第二序列的元素比较多，则不予以考虑。根据源码，如果第二序列比第一序列的元素烧，则会超越序列的尾端，造成不可预测的结果。</p>
<h3 id="fill"><a href="#fill" class="headerlink" title="fill"></a>fill</h3><p>将区间<code>[first1, last1)</code>内的所有元素都改填指定的新值。</p>
<h3 id="fill-n"><a href="#fill-n" class="headerlink" title="fill_n"></a>fill_n</h3><p>将区间<code>[first1, last1)</code>内的前n个元素改填指定的新值，返回的迭代器指向被填入的最后一个元素的下一个位置。如果n超越了容器的大小，由于每次迭代执行的是一个<code>assignment</code>操作，是一个覆写（overwrite）操作，所以一旦操作超越了容器大小，就会造成不可预期的结果。解决办法之一是，利用<code>inserter()</code>产生的一个具有插入而非覆写能力的迭代器。<code>inserter()</code>可产生一个用来修饰迭代器的配接器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int ia[3] = &#123; 0, 1, 2 &#125;;</span><br><span class="line">vector&lt;int&gt; iv(ia, ia+3);</span><br><span class="line">fill_n(inserter(iv, iv.begin()), 5, 7);</span><br><span class="line">// 7 7 7 7 7 0 1 2</span><br></pre></td></tr></table></figure>

<h3 id="mismatch"><a href="#mismatch" class="headerlink" title="mismatch"></a>mismatch</h3><p>用来平行比较两个序列，之处两者之间的第一个不匹配点。返回一个迭代器，分别指向两序列中的不匹配的点。如果两个序列相等，则返回的是两个序列各自的last迭代器。如果第二序列更长，则多出的部分被忽略，如果更短，则会发现不可预知的错误。</p>
<h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p><img src="https://pica.zhimg.com/v2-6ad3ef4cf107f7efd07032307241452d_720w.jpg?source=d16d100b"></p>
<p>copy算法是一一进行元素赋值操作，如果输出区间的起点位于输入区间内，copy算法便可能会在输入区间的某些元素尚未被复制之前，就覆盖其值，导致错误结果。</p>
<p><img src="https://pic4.zhimg.com/v2-b3b354af7fd81c5f3a3f72e0cbbad5af_720w.jpg?source=d16d100b"></p>
<p>如果copy算法根据接收的迭代器的特性决定调用<code>memmove()</code>来执行任务，就不会造成上述错误，因为<code>memmove()</code>会先将整个输入区间的内容复制下来，没有被覆盖的危险。</p>
<p>如果使用vector取代deque进行测试，复制结果将是正确的，因为vector迭代器其实是个原生指针，这导致调用的copy算法以<code>memmove()</code>执行实际复制操作。</p>
<p>copy更改的是<code>[result, result+(last-first))</code>中的迭代器所指对象，而非更改迭代器本身，他会为输出区间内的元素赋予新值，而不是产生新的元素。他不能改变输出区间的迭代器个数。换句话说，copy不能直接用来将元素插入空容器中。</p>
<p><strong>copy_backward</strong></p>
<p>将区间<code>[first, last)</code>内的每一个元素，以逆行的方向复制到以result-1为起点，方向亦为逆行的区间上。</p>
<p><img src="https://pic1.zhimg.com/v2-90251075ae97c5e6659002fcae70646b_720w.jpg?source=d16d100b"></p>
<hr>
<h2 id="set相关算法"><a href="#set相关算法" class="headerlink" title="set相关算法"></a>set相关算法</h2><p>STL一共提供了四种与set（集合）相关的算法，分别是并集（union）、交集（intersection）、差集（difference）、对称差集（symmetric difference）。数学上的set允许元素重复而未经排序，而STL则要求元素不能重复，并且经过排序。本节的四个算法所接受的set，必须是有序区间，元素值得重复出现。也即可以接受STL的set/multiset容器作为输入区间。</p>
<p>unordered_set与unordered_multiset底层以hashtable为实现机制，其内的元素并未呈现出排序状态，所以不可以应用于本节的四个算法。</p>
<h3 id="set-union"><a href="#set-union" class="headerlink" title="set_union"></a>set_union</h3><p>能够构造出集合<code>S1 ∪ S2</code>。S1、S2及并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p>
<p>由于S1，S2内的每一个元素都不需要唯一，因此，如果某个值在S1中出现n次，在S2中出现m次，那么该值在输出区间中会出现max(m,n)次，其中n个来自S1，其余的来自S2。同样，此方法提供两个两个版本，一个是使用<code>operator&lt;</code>进行比较，第二个版本是采用仿函数comp进行比较。set_union是一种稳定的操作。</p>
<p><img src="https://picx.zhimg.com/v2-fb519cd2dcd67bab4261c0ac527594b0_720w.jpg?source=d16d100b"></p>
<h3 id="set-intersection"><a href="#set-intersection" class="headerlink" title="set_intersection"></a>set_intersection</h3><p>能够构造出集合<code>S1 ∩ S2</code>。S1、S2及并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p>
<p>由于S1，S2内的每一个元素都不需要唯一，因此，如果某个值在S1中出现n次，在S2中出现m次，那么该值在输出区间中会出现min(m,n)次，并且全部来自于S1。同样，此方法提供两个两个版本，一个是使用<code>operator&lt;</code>进行比较，第二个版本是采用仿函数comp进行比较。set_union是一种稳定的操作。</p>
<p><img src="https://pic1.zhimg.com/v2-a8776cf95b1142ad30dcb70d9766a618_720w.jpg?source=d16d100b"></p>
<h3 id="set-difference"><a href="#set-difference" class="headerlink" title="set_difference"></a>set_difference</h3><p>能够构造出集合<code>S1 - S2</code>。S1、S2及并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p>
<p>由于S1，S2内的每一个元素都不需要唯一，因此，如果某个值在S1中出现n次，在S2中出现m次，那么该值在输出区间中会出现min(n-m, 0)次，并且全部来自于S1。同样，此方法提供两个两个版本，一个是使用<code>operator&lt;</code>进行比较，第二个版本是采用仿函数comp进行比较。set_union是一种稳定的操作。</p>
<p><img src="https://pic2.zhimg.com/v2-a3c403685a2c406da4766310172ffe2b_720w.jpg?source=d16d100b"></p>
<h3 id="set-symmetric-difference"><a href="#set-symmetric-difference" class="headerlink" title="set_symmetric_difference"></a>set_symmetric_difference</h3><p>能够构造出集合<code>(S1-S2) ∪ (S2-S1)</code>，对称差集。出现在S1但不出现于S2中，以及出现在S2但不出现在S1中的数的集合。S1、S2及并集都是以排序区间表示。返回值为一个迭代器，指向输出区间的尾端。</p>
<p>由于S1，S2内的每一个元素都不需要唯一，因此，如果某个值在S1中出现n次，在S2中出现m次，那么该值在输出区间中会出现<code>|n-m|</code>次。如果<code>n &gt; m</code>，输出区间内的最后n-m个元素将由S1复制而来，如果<code>n &lt; m</code>则输出区间内的最后m-n个元素将由S2复制而来。同样，此方法提供两个两个版本，一个是使用<code>operator&lt;</code>进行比较，第二个版本是采用仿函数comp进行比较。set_union是一种稳定的操作。</p>
<p><img src="https://pica.zhimg.com/v2-18bc529a3deea547c0c3cfb3b6f52d4c_720w.jpg?source=d16d100b"></p>
<hr>
<h2 id="其他算法-低阶"><a href="#其他算法-低阶" class="headerlink" title="其他算法-低阶"></a>其他算法-低阶</h2><p><strong>adjacent_find</strong></p>
<p>找出第一组满足条件的相邻元素。</p>
<p><strong>count</strong></p>
<p>运用equality操作符，将区间<code>[first, last)</code>内的每一个元素拿来和指定值value比较，并返回与value相等的元素个数。</p>
<p><strong>count_if</strong></p>
<p>将指定操作（一个仿函数）pred实施于区间<code>[first, last)</code>内的每一个元素，并将“造成pred之计算结果为true”的所有元素的个数返回。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (pred(*first))  // 将元素带入pred的运算结果为true</span><br><span class="line">    ++n;           // 计数器累加1</span><br></pre></td></tr></table></figure>

<p><strong>find</strong></p>
<p>运用equality操作符，循序查找区间<code>[first, last)</code>内的所有元素，找出第一个匹配者。</p>
<p><strong>find_if</strong></p>
<p>将指定操作（一个仿函数）pred实施于区间<code>[first, last)</code>内的每一个元素，找出第一个令pred运算结果为true者。</p>
<p><strong>find_end</strong></p>
<p>在序列<code>[first1, last1)</code>所涵盖的区间中，查找序列二<code>[first2, last2)</code>的最后一次出现点。如果序列一之内不存在“完全匹配序列二”的子序列，便返回迭代器last1。</p>
<p><strong>find_last_of</strong></p>
<p>以<code>[first2, last2)</code>区间内的某些元素作为查找目标，寻找他们在<code>[first1, last1)</code>区间内的第一次出现地点。例如打算在序列<code>synesthesia</code>的第一个元音，我们可以定义第二序列为<code>aeiou</code>。此时就会返回指向元音序列中任一元素首次出现于第一序列的地点，此例将指向字符序列的第一个e。如果第一序列并未内含第二序列的任何元素，返回的将是last1。</p>
<p><strong>for_each</strong></p>
<p>将仿函数f实施于区间<code>[first, last)</code>内的每一个元素身上。f不可以改变元素内容。</p>
<p><strong>generate</strong></p>
<p>将仿函数的结果填写在区间<code>[first, last)</code>内的所有元素身上。所谓的填写就是用迭代器所指元素之assignment操作符。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tmplate &lt;class ForwardIterator, class Generator&gt;</span><br><span class="line">void generate(ForwardIterator first, ForwardIterator last, Generator gen) &#123;</span><br><span class="line">    for ( ; first != last; ++first ) &#123;</span><br><span class="line">        *first = gen();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>generate_n</strong></p>
<p>将仿函数的结果填写在区间<code>[first, last)</code>内的前n个元素身上。所谓的填写就是用迭代器所指元素之assignment操作符。</p>
<p><strong>includes(应用于有序区间)</strong></p>
<p>判断序列二S2是否涵盖于序列一S1。S1和S2必须是有序集合，其中的元素都可以重复（不必唯一）。所谓涵盖，意思是“S2的每一个元素都出现于S1”。由于判断两个元素是否相等，必须以less或者greater运算为依据（当S1元素不小于S2元素且S2元素不小于S1元素，两者即相等；或说当S1元素不大于S2元素且S2元素不大于S1元素，两者即相等），因此配合着两个序列S1和S2的排序方式（递增或者递减），includes算法可供用户选择采用less或greater进行两元素的比较（comparison）。</p>
<p>如果是S1和S2是递增排序（以<code>operator&lt;</code>执行比较操作）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">includes(S1.begin(), S1.end(), S2.begin(), S2.end());</span><br><span class="line">// 默认的情况就是这种</span><br><span class="line">includes(S1.begin(), S1.end(), S2.begin(), S2.end(), less&lt;int&gt;());</span><br><span class="line">// 如果是递减排序（以`operator&gt;`执行比较操作）</span><br><span class="line">includes(S1.begin(), S1.end(), S2.begin(), S2.end(), greater&lt;int&gt;());</span><br></pre></td></tr></table></figure>

<p><img src="https://pic1.zhimg.com/v2-2fbc97e7f48179be15ee394c7e552904_720w.jpg?source=d16d100b"></p>
<p><strong>max_element/min_element</strong></p>
<p>返回一个迭代器，指向序列之中数值最大/小的元素。</p>
<p><strong>merge</strong></p>
<p>将两个经过排序的集合S1和S2，合并起来置于另外一段空间。所得的结果也是一个有序序列。返回一个迭代器，指向最后结果序列的最后一个元素的下一个位置。</p>
<p><img src="https://pic3.zhimg.com/v2-0cd426796dc97ca9aecedb290f14f10d_720w.jpg?source=d16d100b"></p>
<p><strong>partition</strong></p>
<p>partition会将区间<code>[first, last)</code>中的元素重新排列。所有被一元条件运算pred判定为true的元素，都会被放在区间的前端，被判定为false的元素，都会被放在区间的后段。这个算法是不稳定的。但是可以实现成稳定版，即stable_partition。</p>
<p>如果将仿函数设定为是否为偶数时，算法运行如下：</p>
<p><img src="https://pic3.zhimg.com/v2-b17b6404100d48c096c61644c4100ba7_720w.jpg?source=d16d100b"></p>
<p><strong>remove移除（但不删除）</strong></p>
<p>移除<code>[first, last)</code>之中所有与value相等的元素。这一算法并不是真正从容器中删除那些元素，而是将每一个不与value相等的元素轮番赋值给first之后的空间。如序列<code>&#123;0,1,0,2,0,3,0,4&#125;</code>移除所有0元素，执行结果为：<code>&#123;1,2,3,4,0,3,0,4&#125;</code>。如果要删除那些残余数据，可将返回的迭代器交给区间所在之容器的erase()。由于array无法缩小尺寸，所以不适用remove()和remove_if()。更多的是使用remove_copy()和remove_copy_if()。</p>
<p><img src="https://pica.zhimg.com/v2-73a552b53f12bea13accc574fd13c5ce_720w.jpg?source=d16d100b"></p>
<p><strong>reverse</strong></p>
<p>将序列<code>[first, last)</code>的元素在原容器中颠倒重排。</p>
<p><strong>rotate</strong></p>
<p>将<code>[first, middle)</code>内的元素和<code>[middle, last)</code>内的元素互换。middle所指的元素将会成为容器的第一个元素。</p>
<p>rotate forward iterator版操作示意：</p>
<p><img src="https://pic1.zhimg.com/v2-207e38f5f6c35f6b0b747fa4d6b17aaa_720w.jpg?source=d16d100b"></p>
<p>rotate bidirectional iterator版操作示意</p>
<p><img src="https://pica.zhimg.com/v2-2653fea0db9623c4cad28ae3df361d98_720w.jpg?source=d16d100b"></p>
<p><strong>unique</strong></p>
<p>算法unique能够移除（remove）重复的元素。每当在<code>[first, last]</code>内遇到有重复元素群，他便移除该元素群中第一个以后的所有元素。注意，unique只移除相邻的重复元素，所以接收的为已经排序的序列。</p>
<hr>
<h2 id="其他算法-高阶"><a href="#其他算法-高阶" class="headerlink" title="其他算法-高阶"></a>其他算法-高阶</h2><p><strong>lower_bound/upper_bound</strong></p>
<p>应用于有序区间，试图在已排序的<code>[first, last)</code>区间中寻找元素value。如果<code>[first, last)</code>具有与value相等的元素，便返回一个迭代器，指向其中第一个元素。如果没有这样的元素存在，便返回“假设这样的元素存在时应该出现的位置”。也就是说它会返回一个迭代器，指向第一个“不小于value”的元素。如果value大于<code>[first, last)</code>内的任何一个元素，则返回last。在不破坏排序状态的原则下，可插入value的第一个位置。而对于upper_bound，则是返回在不破坏排序状态的原则下，可插入value的最后一个合适位置。</p>
<p><img src="https://pic1.zhimg.com/v2-7f0585319e85abbdb224a87b57c1a454_720w.jpg?source=d16d100b"></p>
<p><strong>binary_search</strong></p>
<p>二分查找，试图在已排序的<code>[first, last)</code>区间中寻找元素value。binary_search利用lower_bound先找出“假设value存在的话，应该出现的位置”，然后再比对该位置上的值是否为我们所要查找的目标，并返回对比结果。</p>
<p><strong>next_permutation</strong></p>
<p>STL提供了</p>
<p>三个不同的字符有6种排列，这个数字是从<code>3*2*1</code>得到的。一般来说，n个不同的字 符有n!种排列，n!是<code>nx(n_1)x(n-2)...x2x1</code>。很容易明白为什么要这样算。有n个对象时，在序列的第一个位置就有n种可能的选择。对于第一个对象的每一种选择，序列的第二个位置还剩下<code>n-1</code>种选择，因此前两个有<code>nx((n-1)</code>种可能选择。在选择了前两个之后， 第三个位置还剩下<code>n-2</code>种选择，因此前三个有<code>nx(n-1)x(n-2)</code> 种可能选择，以此类推。序列的末尾是Hobson选择，因为只剩下1种选择。</p>
<p>对于包含相同元素的序列来说，只要一个序列中的元素顺序不同，就是一种排列。next_permutation() 会生成一个序列的重排列，它是所有可能的字典序中的下一个排列，默认使用<code>&lt;</code> 运算符来做这些事情。它的参数为定义序列的迭代器和一个返回布尔值的函数，这个函数在下一个排列大于上一个排列时返回true，如果上一个排列是序列中最大的，它返回false，所以会生成字典序最小的排列。</p>
<p><strong>random_shuffle</strong></p>
<p>将<code>[first, last)</code>的元素次序随机重排。也就是说，在N!种可能的元素排列顺序中选出一种，此处N为last-first。</p>
<p>random_shuffle会产生一个均匀分布，因此任何一个排列被选中的机率为1/N!。这很重要，因为不少算法在其第一阶段过程中必须获得序列的随机重排。</p>
<p>random_shuffle有两个版本，差别在于随机数的取得。版本一使用内部随机数产生器，版本二使用一个会产生随机随机数的仿函数。该仿函数的传递方式是引用传递，而非值传递，因为随机随机数产生器有一个重要特质：它拥有局部状态，每次被调用时都会有所改变，并因此保障产生出来的随机数能够随机。</p>
<p><strong>sort</strong></p>
<p>使用partial_sort而非sort的唯一理由就是效率。只挑出前N个最小元素来排序，当然比对整个序列排序快上许多。</p>
<p>STL的sort算法。数据量大时采用quick sort，分段递归排序。一旦分段后的数据量小于某个门槛，为避免quick sort的递归调用带来过大的额外负荷（overhead），就改用insertion sort。如果递归层次过深，还会改用heap sort。</p>
<p><strong>equal_range（应用于有序区间）</strong></p>
<p>算法equal_range是一个二分查找法的一个版本，试图在已经排序的<code>[first, last)</code>区间中寻找value。它返回一对迭代器i和j。其中i是在不破坏次序的前提下，value可插入的第一个位置（亦即lower_bound），j则是在不破坏次序的前提下，value可插入的最后一个位置（亦即upper_bound）。因此，<code>[i, j)</code>内的每个元素都等于value，而且<code>[i, j)</code>是<code>[first, last)</code>之中符合此一性质的最大子区间。</p>
<p><strong>inplace_merge（应用于有序区间）</strong></p>
<p>如果两个链接在一起的序列<code>[first, middle)</code>和<code>[middle, last)</code>都已排序，那么inplace_merge可将它们结合成单一一个序列，并仍然保持有序。</p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item"></span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/C++/STL/%E7%AC%AC%E4%B8%83%E7%AB%A0/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item"></span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">王秋鹏</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E7%AE%97%E6%B3%95"><span class="nav-text">算法</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E5%80%BC%E7%AE%97%E6%B3%95"><span class="nav-text">数值算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#accumulate"><span class="nav-text">accumulate</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#adjacent-difference"><span class="nav-text">adjacent_difference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#inner-product"><span class="nav-text">inner_product</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#partial-sum"><span class="nav-text">partial_sum</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95"><span class="nav-text">基本算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#equal"><span class="nav-text">equal</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fill"><span class="nav-text">fill</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#fill-n"><span class="nav-text">fill_n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mismatch"><span class="nav-text">mismatch</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#copy"><span class="nav-text">copy</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95"><span class="nav-text">set相关算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#set-union"><span class="nav-text">set_union</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-intersection"><span class="nav-text">set_intersection</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-difference"><span class="nav-text">set_difference</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#set-symmetric-difference"><span class="nav-text">set_symmetric_difference</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95-%E4%BD%8E%E9%98%B6"><span class="nav-text">其他算法-低阶</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E7%AE%97%E6%B3%95-%E9%AB%98%E9%98%B6"><span class="nav-text">其他算法-高阶</span></a></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
