<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="王秋鹏">
    
    <title>
        
            C++面经总结 |
        
        wangqp
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/avatar.jpg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"example.com","root":"/","language":"en"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":true,"init_open":true},"style":{"primary_color":"#0066CC","avatar":"/images/avatar.jpg","favicon":"/images/avatar.jpg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":false,"background_img":"/images/bg.svg","description":"Keep writing and Keep loving."},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":false,"preload":false},"code_copy":{"enable":false,"style":"default"},"pjax":{"enable":true},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 5.4.2"></head>


<body>
<div class="progress-bar-container">
    

    
        <span class="pjax-progress-bar"></span>
        <span class="pjax-progress-icon">
            <i class="fas fa-circle-notch fa-spin"></i>
        </span>
    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                wangqp
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                首页
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/c/"
                            >
                                C++
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/Codeing/"
                            >
                                数据结构与算法
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"
                            >
                                系统编程与网络编程
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%95%B0%E6%8D%AE%E5%BA%93/"
                            >
                                数据库
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E9%A1%B9%E7%9B%AE"
                            >
                                项目
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/"
                            >
                                杂七杂八
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/about/"
                            >
                                关于
                            </a>
                        </li>
                    
                    
                </ul>
            </div>
            <div class="mobile">
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">首页</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/c/">C++</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/Codeing/">数据结构与算法</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">系统编程与网络编程</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E9%A1%B9%E7%9B%AE">项目</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/%E6%9D%82%E4%B8%83%E6%9D%82%E5%85%AB/">杂七杂八</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/about/">关于</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="article-content-container">

        <div class="article-title">
            <span class="title-hover-animation">C++面经总结</span>
        </div>

        
            <div class="article-header">
                <div class="avatar">
                    <img src="/images/avatar.jpg">
                </div>
                <div class="info">
                    <div class="author">
                        <span class="name">王秋鹏</span>
                        
                            <span class="author-label">Lv4</span>
                        
                    </div>
                    <div class="meta-info">
                        <div class="article-meta-info">
    <span class="article-date article-meta-item">
        <i class="fas fa-edit"></i>&nbsp;
        <span class="pc">2022-03-10 00:00:00</span>
        <span class="mobile">2022-03-10 00:00</span>
    </span>
    
    

    
    
    
    
</div>

                    </div>
                </div>
            </div>
        

        <div class="article-content markdown-body">
            <h1 id="一-C"><a href="#一-C" class="headerlink" title="一 C++"></a>一 C++</h1><h2 id="1-1-关键字"><a href="#1-1-关键字" class="headerlink" title="1.1 关键字"></a>1.1 关键字</h2><h3 id="1-1-1-static"><a href="#1-1-1-static" class="headerlink" title="1.1.1 static"></a>1.1.1 static</h3><ul>
<li><p><strong>函数体内 static 变量</strong>：作⽤范围为该函数体，不同于 auto 变量，该变量的内存只被分配⼀次，因此其值在下次调⽤时仍维持上次的值；</p>
</li>
<li><p><strong>在模块内的 static 全局变量</strong>：可以被模块内所⽤函数访问，但不能被模块外其它函数访问； </p>
</li>
<li><p><strong>在模块内的 static 函数</strong>：只可被这⼀模块内的其它函数调⽤，这个函数的使⽤范围被限制在声明它的模块内； </p>
</li>
<li><p><strong>在类中的 static 成员变量</strong>：属于整个类所拥有，对类的所有对象只有⼀份拷⻉； </p>
</li>
<li><p><strong>在类中的 static 成员函数</strong> ：属于整个类所拥有，这个函数不接收 this 指针，因⽽只能访问类的 static 成员变量。</p>
</li>
<li><p><strong>static 类对象</strong> ： 必须要在类外进⾏初始化，static 修饰的变量先于对象存在，所以 static 修饰的变量要在类外初始化；</p>
<p>由于 static 修饰的类成员属于类，不属于对象，因此 static 类成员函数是没有 this 指针，this 指针是指向本对象的指针，正因为没有 this 指针，所以 static 类成员函数不能访问⾮ static 的类成员，只能访问 static修饰的类成员</p>
<p>static 成员函数不能被 virtual 修饰，static 成员不属于任何对象或实例，所以加上 virtual 没有任何实际意义；静态成员函数没有 this 指针，虚函数的实现是为每⼀个对象分配⼀个 vptr 指针，⽽ vptr 是通过 this 指针调⽤的，所以不能为 virtual；虚函数的调⽤关系，<code>this-&gt;vptr-&gt;ctable-&gt;virtual function</code>。</p>
</li>
</ul>
<h3 id="1-1-2-const"><a href="#1-1-2-const" class="headerlink" title="1.1.2 const"></a>1.1.2 const</h3><p><strong>const 修饰基本类型数据类型</strong>：基本数据类型，修饰符 const 可以⽤在类型说明符前，也可以⽤在类型说明符后，其结果是⼀样的。在使⽤这些常量的时候，只要不改变这些常量的值即可。</p>
<p><strong>const 修饰指针变量和引⽤变量</strong>：如果 const 位于⼩星星的左侧，则 const 就是⽤来修饰指针所指向的变量，即指针指向为常量；如果 const 位于⼩星星的右侧，则 const 就是修饰指针本身，即指针本身是常量。</p>
<p><strong>const应⽤到函数中</strong>：作为参数的 const 修饰符：调⽤函数的时候，⽤相应的变量初始化 const 常量，则在函数体中，按照 const 所修饰的部分进⾏常量化，保护了原对象的属性。 [注意]：参数 const 通常⽤于参数为指针或引⽤的情况; 作为函数返回值的 const 修饰符：声明了返回值后，const 按照”修饰原则”进⾏修饰，起到相应的保护作⽤。</p>
<p><strong>const在类中的⽤法</strong>：const 成员变量，只在某个对象⽣命周期内是常量，⽽对于整个类⽽⾔是可以改变的。因为类可以创建多个对象，不同的对象其 const 数据成员值可以不同。所以不能在类的声明中初始化 const 数据成员，因为类的对象在没有创建时候，编译器不知道 const 数据成员的值是什么。const 数据成员的初始化只能在类的构造函数的初始化列表中进⾏。const 成员函数：const 成员函数的主要⽬的是防⽌成员函数修改对象的内容。要注意，const 关键字和 static 关键字对于成员函数来说是不能同时使⽤的，因为 static 关键字修饰静态成员函数不含有 this 指针，即不能实例化，const 成员函数⼜必须具体到某⼀个函数。</p>
<p><strong>const 修饰类对象，定义常量对象</strong>：常量对象只能调⽤常ᰁ函数，别的成员函数都不能调⽤。</p>
<h3 id="1-1-3-volatile"><a href="#1-1-3-volatile" class="headerlink" title="1.1.3 volatile"></a>1.1.3 volatile</h3><p><strong>易变性：</strong>在汇编层⾯反映出来，就是两条语句，下⼀条语句不会直接使⽤上⼀条语句对应的 volatile 变量的寄存器内容，⽽是重新从内存中读取。</p>
<p><strong>不可优化性：</strong>volatile 告诉编译器，不要对我这个变量进⾏各种激进的优化，甚⾄将变量直接消除，保证程序员写在代码中的指令，⼀定会被执⾏。</p>
<p><strong>顺序性：</strong>能够保证 volatile 变量之间的顺序性，编译器不会进⾏乱序优化。</p>
<h3 id="1-1-4-extern"><a href="#1-1-4-extern" class="headerlink" title="1.1.4 extern"></a>1.1.4 extern</h3><p>在 C 语⾔中，修饰符 extern ⽤在变ᰁ或者函数的声明前，⽤来说明 “此变ᰁ/函数是在别处定义的，要在此处引⽤”。</p>
<p>注意 extern 声明的位置对其作⽤域也有关系，如果是在 main 函数中进⾏声明的，则只能在 main 函数中调⽤，在其它函数中不能调⽤。其实要调⽤其它⽂件中的函数和变量，只需把该⽂件⽤ #include 包含进来即可，为啥要⽤extern？因为⽤ extern 会加速程序的编译过程，这样能节省时间。</p>
<p>在 C++ 中 extern 还有另外⼀种作⽤，⽤于指示 C 或者 C＋＋函数的调⽤规范。⽐如在 C＋＋ 中调⽤ C 库函数，就需要在 C＋＋ 程序中⽤ extern “C” 声明要引⽤的函数。这是给链接器⽤的，告诉链接器在链接的时候⽤C 函数规范来链接。主要原因是 C＋＋ 和 C 程序编译完成后在⽬标代码中命名规则不同，⽤此来解决名字匹配的问题。</p>
<h3 id="1-1-5-define"><a href="#1-1-5-define" class="headerlink" title="1.1.5 define"></a>1.1.5 define</h3><h3 id="1-1-7-define和const区别"><a href="#1-1-7-define和const区别" class="headerlink" title="1.1.7 define和const区别"></a>1.1.7 define和const区别</h3><p><strong>对于</strong> <strong>define</strong> <strong>来说，</strong>宏定义实际上是在预编译阶段进⾏处理，没有类型，也就没有类型检查，仅仅做的是遇到宏定义进⾏字符串的展开，遇到多少次就展开多少次，⽽且这个简单的展开过程中，很容易出现边界效应，达不到预期的效果。因为 define 宏定义仅仅是展开，因此运⾏时系统并不为宏定义分配内存，但是从汇编 的⻆度来讲，define 却以⽴即数的⽅式保留了多份数据的拷⻉。</p>
<p><strong>对于</strong> <strong>const</strong> <strong>来说，</strong>const 是在编译期间进⾏处理的，const 有类型，也有类型检查，程序运⾏时系统会为 const 常量分配内存，⽽且从汇编的⻆度讲，const 常量在出现的地⽅保留的是真正数据的内存地址，只保留了⼀份数据的拷⻉，省去了不必要的内存空间。⽽且，有时编译器不会为普通的 const 常ᰁ分配内存，⽽是直接将 const 常量添加到符号表中，省去了读取和写⼊内存的操作，效率更⾼。</p>
<h2 id="1-2-智能指针"><a href="#1-2-智能指针" class="headerlink" title="1.2 智能指针"></a>1.2 智能指针</h2><h3 id="1-2-1-auto-ptr"><a href="#1-2-1-auto-ptr" class="headerlink" title="1.2.1 auto_ptr"></a>1.2.1 auto_ptr</h3><p>采用所有权模式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">auto_ptr&lt;std::string&gt; <span class="title">p1</span> <span class="params">(<span class="keyword">new</span> string (<span class="string">&quot;hello&quot;</span>))</span></span>;</span><br><span class="line">auto_ptr&lt;std::string&gt; p2;</span><br><span class="line">p2 = p1; <span class="comment">//auto_ptr 不会报错.</span></span><br></pre></td></tr></table></figure>

<p>此时不会报错，p2 剥夺了 p1 的所有权，但是当程序运⾏时访问 p1 将会报错。所以 auto_ptr 的缺点是：存在潜 在的内存崩溃问题！</p>
<h3 id="1-2-2-unique-ptr"><a href="#1-2-2-unique-ptr" class="headerlink" title="1.2.2 unique_ptr"></a>1.2.2 unique_ptr</h3><p>unique_ptr 实现独占式拥有或严格拥有概念，保证同⼀时间内只有⼀个智能指针可以指向该对象。它对于避免资源泄露特别有⽤。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;string&gt; <span class="title">p3</span> <span class="params">(<span class="keyword">new</span> string (<span class="keyword">auto</span>))</span></span>;<span class="comment">//#4</span></span><br><span class="line">unique_ptr&lt;string&gt; p4；<span class="comment">//#5</span></span><br><span class="line">p4 = p3;<span class="comment">//此时会报错</span></span><br></pre></td></tr></table></figure>

<p>编译器认为p4 = p3非法，避免了p3不再指向有效数据的问题</p>
<h3 id="1-2-3-shared-ptr"><a href="#1-2-3-shared-ptr" class="headerlink" title="1.2.3  shared_ptr"></a>1.2.3  shared_ptr</h3><p>shared_ptr 实现共享式拥有概念，多个智能指针可以指向相同对象，该对象和其相关资源会在“最后⼀个引⽤被销毁”时候释放。从名字 share 就可以看出了资源可以被多个指针共享，它使⽤计数机制来表明资源被⼏个指针共享。</p>
<h3 id="1-2-4-weak-ptr"><a href="#1-2-4-weak-ptr" class="headerlink" title="1.2.4 weak_ptr"></a>1.2.4 weak_ptr</h3><p>weak_ptr 是⼀种不控制对象⽣命周期的智能指针，它指向⼀个 shared_ptr 管理的对象。进⾏该对象的内存管理的是那个强引⽤的 shared_ptr</p>
<p> weak_ptr 只是提供了对管理对象的⼀个访问⼿段。weak_ptr 设计的⽬的是为配合 shared_ptr ⽽引⼊的⼀种智能指针来协助 shared_ptr ⼯作，它只可以从⼀个 shared_ptr 或另⼀个 weak_ptr 对象构造,，它的构造和析构不会引起引⽤记数的增加或减少。</p>
<h2 id="1-3-C-中内存分配情况"><a href="#1-3-C-中内存分配情况" class="headerlink" title="1.3 C++ 中内存分配情况"></a>1.3 C++ 中内存分配情况</h2><h3 id="1-3-1-C-中内存分配情况"><a href="#1-3-1-C-中内存分配情况" class="headerlink" title="1.3.1 C++ 中内存分配情况"></a>1.3.1 <strong>C++ 中内存分配情况</strong></h3><p><strong>栈：</strong>由编译器管理分配和回收，存放局部变量和函数参数。</p>
<p><strong>堆：</strong>由程序员管理，需要⼿动 new malloc delete free 进⾏分配和回收，空间较⼤，但可能会出现内存泄漏和空闲碎⽚的情况。</p>
<p><strong>全局/静态存储区：</strong>分为初始化和未初始化两个相邻区域，存储初始化和未初始化的全局变量和静态变量。</p>
<p><strong>常量存储区：</strong>存储常量，⼀般不允许修改。</p>
<p><strong>代码区：</strong>存放程序的⼆进制代码。</p>
<h3 id="1-3-2-说⼀下C-⾥是怎么定义常量的？常量存放在内存的哪个位置？"><a href="#1-3-2-说⼀下C-⾥是怎么定义常量的？常量存放在内存的哪个位置？" class="headerlink" title="1.3.2 说⼀下C++⾥是怎么定义常量的？常量存放在内存的哪个位置？"></a>1.3.2 说⼀下C++⾥是怎么定义常量的？常量存放在内存的哪个位置？</h3><p>对于局部常量，存放在栈区；</p>
<p>对于全局常量，编译期⼀般不分配内存，放在符号表中以提⾼访问效率；</p>
<p>字⾯值常量，⽐如字符串，放在常量区</p>
<h3 id="1-3-3-new-delete-malloc-free-区别"><a href="#1-3-3-new-delete-malloc-free-区别" class="headerlink" title="1.3.3 new/delete , malloc/free 区别"></a>1.3.3 new/delete , malloc/free 区别</h3><p>都可以⽤来在堆上分配和回收空间。new /delete 是操作符，malloc/free 是库函数。</p>
<p><strong>执⾏</strong> <strong>new</strong> <strong>实际上执⾏两个过程</strong>：1.分配未初始化的内存空间（malloc）；2.使⽤对象的构造函数对空间进⾏初始</p>
<p>化；返回空间的⾸地址。如果在第⼀步分配空间中出现问题，则抛出 std::bad_alloc 异常，或被某个设定的异常处</p>
<p>理函数捕获处理；如果在第⼆步构造对象时出现异常，则⾃动调⽤ delete 释放内存。</p>
<p><strong>执⾏</strong> <strong>delete</strong> <strong>实际上也有两个过程</strong>：1. 使⽤析构函数对对象进⾏析构；2.回收内存空间（free）。</p>
<p>以上也可以看出 new 和 malloc 的区别，new 得到的是经过初始化的空间，⽽ malloc 得到的是未初始化的空间。</p>
<p>所以 new 是 new ⼀个类型，⽽ malloc 则是malloc ⼀个字节⻓度的空间。delete 和 free 同理，delete 不仅释放</p>
<p>空间还析构对象，delete ⼀个类型，free ⼀个字节⻓度的空间。</p>
<p><strong>为什么有了</strong> <strong>malloc／free</strong> 还需要 <strong>new／delete</strong>？**因为对于⾮内部数据类型⽽⾔，光⽤ malloc／free ⽆法满⾜动</p>
<p>态对象的要求。对象在创建的同时需要⾃动执⾏构造函数，对象在消亡以前要⾃动执⾏析构函数。由于 malloc／</p>
<p>free 是库函数⽽不是运算符，不在编译器控制权限之内，不能够把执⾏的构造函数和析构函数的任务强加于</p>
<p>malloc／free，所以有了 new／delete 操作符。</p>
<h3 id="1-3-4-结构体内存对⻬⽅式和为什么要进⾏内存对⻬？"><a href="#1-3-4-结构体内存对⻬⽅式和为什么要进⾏内存对⻬？" class="headerlink" title="1.3.4 结构体内存对⻬⽅式和为什么要进⾏内存对⻬？"></a>1.3.4 <strong>结构体内存对⻬⽅式和为什么要进⾏内存对⻬？</strong></h3><p>⾸先我们来说⼀下结构体中<strong>内存对⻬的规则</strong>：</p>
<ul>
<li>对于结构体中的各个成员，第⼀个成员位于偏移为 0 的位置，以后的每个数据成员的偏移ᰁ必须是min(#pragma pack() 制定的数，数据成员本身⻓度) 的倍数。</li>
<li>在所有的数据成员完成各⾃对⻬之后，结构体或联合体本身也要进⾏对⻬，整体⻓度是 min(#pragma pack()制定的数，⻓度最⻓的数据成员的⻓度) 的倍数。</li>
</ul>
<p>那么<strong>内存对⻬的作⽤</strong>是什么呢？</p>
<p>经过内存对⻬之后，CPU 的内存访问速度⼤⼤提升。因为 CPU 把内存当成是⼀块⼀块的，块的⼤⼩可以是2，4，8，16 个字节，因此 CPU 在读取内存的时候是⼀块⼀块进⾏读取的，块的⼤⼩称为内存读取粒度。⽐如说 CPU 要读取⼀个 4 个字节的数据到寄存器中（假设内存读取粒度是 4），如果数据是从 0 字节开始的，那么直接将 0-3 四个字节完全读取到寄存器中进⾏处理即可。</p>
<p>如果数据是从 1 字节开始的，就⾸先要将前 4 个字节读取到寄存器，并再次读取 4-7 个字节数据进⼊寄存器，接着把 0 字节，5，6，7 字节的数据剔除，最后合并 1，2，3，4 字节的数据进⼊寄存器，所以说，当内存没有对⻬时，寄存器进⾏了很多额外的操作，⼤⼤降低了 CPU 的性能。</p>
<p>另外，还有⼀个就是，有的 CPU 遇到未进⾏内存对⻬的处理直接拒绝处理，不是所有的硬件平台都能访问任意地址上的任意数据，某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。所以内存对⻬还有利于平台移植。</p>
<h3 id="1-3-5、内存泄漏的定义，如何检测与避免？"><a href="#1-3-5、内存泄漏的定义，如何检测与避免？" class="headerlink" title="1.3.5、内存泄漏的定义，如何检测与避免？**"></a>1.3.5、内存泄漏的定义，如何检测与避免？**</h3><p><strong>定义</strong>：内存泄漏简单的说就是申请了⼀块内存空间，使⽤完毕后没有释放掉。 它的⼀般表现⽅式是程序运⾏时间越</p>
<p>⻓，占⽤内存越多，最终⽤尽全部内存，整个系统崩溃。由程序申请的⼀块内存，且没有任何⼀个指针指向它，那</p>
<p>么这块内存就泄漏了。</p>
<p><strong>如何检测内存泄漏</strong></p>
<ul>
<li>⾸先可以通过观察猜测是否可能发⽣内存泄漏，Linux 中使⽤ swap 命令观察还有多少可⽤的交换空间，在⼀两分钟内键⼊该命令三到四次，看看可⽤的交换区是否在减少。</li>
<li>还可以使⽤ 其他⼀些 /usr/bin/stat ⼯具如 netstat、vmstat 等。如发现波段有内存被分配且从不释放，⼀个可能的解释就是有个进程出现了内存泄漏。</li>
<li>当然也有⽤于内存调试，内存泄漏检测以及性能分析的软件开发⼯具 valgrind 这样的⼯具来进⾏内存泄漏的检测</li>
</ul>
<h2 id="1-4-C-与其他语言的区别"><a href="#1-4-C-与其他语言的区别" class="headerlink" title="1.4 C++与其他语言的区别"></a>1.4 C++与其他语言的区别</h2><h3 id="1-4-1-C-与C的区别"><a href="#1-4-1-C-与C的区别" class="headerlink" title="1.4.1 C++与C的区别"></a>1.4.1 C++与C的区别</h3><p>⾸先，C 和 C++ 在基本语句上没有过⼤的区别。</p>
<p>C++ 有新增的<strong>语法和关键字</strong>，语法的区别有头⽂件的不同和命名空间的不同，C++ 允许我们⾃⼰定义⾃⼰的空间，C 中不可以。关键字⽅⾯⽐如 C++ 与 C 动态管理内存的⽅式不同，C++ 中在 malloc 和 free 的基础上增加了 new 和 delete，⽽且 C++ 中在指针的基础上增加了引⽤的概念，关键字例如 C++中还增加了 auto，explicit 体现显示和隐式转换上的概念要求，还有 dynamic_cast 增加类型安全⽅⾯的内容。</p>
<p><strong>函数⽅⾯</strong> <strong>C++</strong> <strong>中有重载和虚函数的概念</strong>：C++ ⽀持函数᯿载⽽ C 不⽀持，是因为 C++ 函数的名字修饰与 C 不同，C++ 函数名字的修饰会将参数加在后⾯，例如，int func(int,double)经过名字修饰之后会变成_func_int_double， ⽽ C 中则会变成 _func，所以 C++ 中会⽀持不同参数调⽤不同函数。</p>
<p><strong>C++</strong> <strong>还有虚函数概念，⽤以实现多态。</strong></p>
<p>类⽅⾯，C <strong>的</strong> <strong>struct</strong> <strong>和</strong> <strong>C++</strong> <strong>的类也有很⼤不同</strong>：C++ 中的 struct 不仅可以有成员变ᰁ还可以成员函数，⽽且对于 struct 增加了权限访问的概念，struct 的默认成员访问权限和默认继承权限都是 public，C++ 中除了 struct 还有 class 表示类，struct 和 class 还有⼀点不同在于 class 的默认成员访问权限和默认继承权限都是 private。</p>
<p><strong>C++</strong> <strong>中增加了模板还᯿⽤代码，提供了更加强⼤的</strong> <strong>STL</strong> <strong>标准库。</strong></p>
<p>最后补充⼀点就是 C 是⼀种结构化的语⾔，᯿点在于算法和数据结构。C 程序的设计⾸先考虑的是如何通过⼀个代码，⼀个过程对输⼊进⾏运算处理输出。⽽ C++ ⾸先考虑的是如何构造⼀个对象模型，让这个模型能够契合与之对应的问题领域，这样就能通过获取对象的状态信息得到输出。</p>
<h3 id="1-4-2-C-与JAVA的区别"><a href="#1-4-2-C-与JAVA的区别" class="headerlink" title="1.4.2 C++与JAVA的区别"></a>1.4.2 C++与JAVA的区别</h3><p><strong>指针：</strong>Java 语⾔让程序员没法找到指针来直接访问内存，没有指针的概念，并有内存的⾃动管理功能，从⽽有效的防⽌了 C++ 语⾔中的指针操作失误的影响。但并⾮ Java 中没有指针，Java 虚拟机内部中还是⽤了指针，保证了Java 程序的安全。</p>
<p><strong>多重继承：</strong>C++ ⽀持多重继承但 Java 不⽀持，但⽀持⼀个类继承多个接⼝，实现 C++ 中多᯿继承的功能，⼜避免了 C++ 的多᯿继承带来的不便。</p>
<p><strong>数据类型和类：</strong>Java 是完全⾯向对象的语⾔，所有的函数和变ᰁ必须是类的⼀部分。除了基本数据类型之外，其余的都作为类对象，对象将数据和⽅法结合起来，把它们封装在类中，这样每个对象都可以实现⾃⼰的特点和⾏为。Java 中取消了 C++ 中的 struct 和 union 。</p>
<p><strong>⾃动内存管理：</strong>Java 程序中所有对象都是⽤ new 操作符建⽴在内存堆栈上，Java ⾃动进⾏⽆⽤内存回收操作，不需要程序员进⾏⼿动删除。⽽ C++ 中必须由程序员释放内存资源，增加了程序设计者的负担。Java 中当⼀个对象不再被⽤到时， ⽆⽤内存回收器将给他们加上标签。Java ⾥⽆⽤内存回收程序是以线程⽅式在后台运⾏的，利⽤空闲时间⼯作来删除。</p>
<p>Java 不⽀持操作符᯿载。操作符᯿载被认为是 C++ 的突出特性。</p>
<p>Java 不⽀持预处理功能。C++ 在编译过程中都有⼀个预编译阶段，Java 没有预处理器，但它提供了 import 与 C++预处理器具有类似功能。</p>
<p><strong>类型转换：</strong>C++ 中有数据类型隐含转换的机制，Java 中需要限时强制类型转换。</p>
<h2 id="1-5-C-的四种强制转换"><a href="#1-5-C-的四种强制转换" class="headerlink" title="1.5 C++的四种强制转换"></a>1.5 C++的四种强制转换</h2><p><strong>static_cast：</strong>明确指出类型转换，⼀般建议将隐式转换都替换成显示转换，因为没有动态类型检查，上⾏转换（派⽣类-&gt;基类）安全，下⾏转换（基类-&gt;派⽣类） 不安全，所以主要执⾏⾮多态的转换操作；</p>
<p><strong>dynamic_cast：</strong>专⻔⽤于派⽣类之间的转换，type-id 必须是类指针，类引⽤或 void*，对于下⾏转换是安全的，当类型不⼀致时，转换过来的是空指针，⽽static_cast，当类型不⼀致时，转换过来的事错误意义的指针，可能造成⾮法访问等问题。</p>
<p><strong>const_cast：</strong>专⻔⽤于 const 属性的转换，去除 const 性质，或增加 const 性质， 是四个转换符中唯⼀⼀个可以操作常量的转换符。</p>
<p><strong>reinterpret_cast：</strong>不到万不得已，不要使⽤这个转换符，⾼危操作。使⽤特点： 从底层对数据进⾏重新解释，依赖具体的平台，可移植性差； 可以将整形转 换为指针，也可以把指针转换为数组；可以在指针和引⽤之间进⾏肆⽆忌惮的转换。</p>
<h2 id="1-6-指针"><a href="#1-6-指针" class="headerlink" title="1.6 指针"></a>1.6 指针</h2><h3 id="1-6-1-指针和引用的区别"><a href="#1-6-1-指针和引用的区别" class="headerlink" title="1.6.1 指针和引用的区别"></a>1.6.1 指针和引用的区别</h3><h3 id="1-6-2-野指针与悬空指针有什么区别？如何避免？"><a href="#1-6-2-野指针与悬空指针有什么区别？如何避免？" class="headerlink" title="1.6.2 野指针与悬空指针有什么区别？如何避免？"></a>1.6.2 野指针与悬空指针有什么区别？如何避免？</h3><h3 id="1-6-3-函数指针"><a href="#1-6-3-函数指针" class="headerlink" title="1.6.3 函数指针"></a>1.6.3 函数指针</h3><p>⾸先是定义：函数指针是指向函数的指针变量。函数指针本身⾸先是⼀个指针变量，该指针变量指向⼀个具体的函数。这正如⽤指针变量可指向整型变量、字符型、数组⼀样，这⾥是指向函数。</p>
<p>在编译时，每⼀个函数都有⼀个⼊⼝地址，该⼊⼝地址就是函数指针所指向的地址。有了指向函数的指针变量后，可⽤该指针变量调⽤函数，就如同⽤指针变量可引⽤其他类型变量⼀样，在这些概念上是⼤体⼀致的。</p>
<p>其次是⽤途：调⽤函数和做函数的参数，⽐如回调函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> * <span class="title">fun</span><span class="params">(<span class="type">char</span> * p)</span> </span>&#123;…&#125; <span class="comment">// 函数fun</span></span><br><span class="line"><span class="type">char</span> * (*pf)(<span class="type">char</span> * p); <span class="comment">// 函数指针pf</span></span><br><span class="line">pf = fun; <span class="comment">// 函数指针pf指向函数fun</span></span><br><span class="line"><span class="built_in">pf</span>(p); <span class="comment">// 通过函数指针pf调⽤函数fun</span></span><br></pre></td></tr></table></figure>



<h2 id="1-7-虚函数相关"><a href="#1-7-虚函数相关" class="headerlink" title="1.7 虚函数相关"></a>1.7 虚函数相关</h2><h3 id="1-7-1-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理"><a href="#1-7-1-虚函数相关（虚函数表，虚函数指针），虚函数的实现原理" class="headerlink" title="1.7.1 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理"></a>1.7.1 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</h3><p>⾸先我们来说⼀下，C++中多态的表象，在基类的函数前加上 virtual 关键字，在派⽣类中重写该函数，运⾏时将会根据对象的实际类型来调⽤相应的函数。如果对象类型是派⽣类，就调⽤派⽣类的函数，如果是基类，就调⽤基类的函数。</p>
<p>实际上，当⼀个类中包含虚函数时，编译器会为该类⽣成⼀个虚函数表，保存该类中虚函数的地址，同样，派⽣类继承基类，派⽣类中⾃然⼀定有虚函数，所以编译器也会为派⽣类⽣成⾃⼰的虚函数表。当我们定义⼀个派⽣类对象时，编译器检测该类型有虚函数，所以为这个派⽣类对象⽣成⼀个虚函数指针，指向该类型的虚函数表，这个虚函数指针的初始化是在构造函数中完成的。</p>
<p>后续如果有⼀个基类类型的指针，指向派⽣类，那么当调⽤虚函数时，就会根据所指真正对象的虚函数表指针去寻</p>
<p>找虚函数的地址，也就可以调⽤派⽣类的虚函数表中的虚函数以此实现多态。</p>
<h3 id="1-7-2-编译器处理虚函数表应该如何处理"><a href="#1-7-2-编译器处理虚函数表应该如何处理" class="headerlink" title="1.7.2 编译器处理虚函数表应该如何处理"></a>1.7.2 <strong>编译器处理虚函数表应该如何处理</strong></h3><p>对于派⽣类来说，编译器建⽴虚函数表的过程其实⼀共是三个步骤：</p>
<ul>
<li>拷⻉基类的虚函数表，如果是多继承，就拷⻉每个有虚函数基类的虚函数表</li>
<li>当然还有⼀个基类的虚函数表和派⽣类⾃身的虚函数表共⽤了⼀个虚函数表，也称为某个基类为派⽣类的主基类</li>
<li>查看派⽣类中是否有重写基类中的虚函数， 如果有，就替换成已经重写的虚函数地址；查看派⽣类是否有⾃身的虚函数，如果有，就追加⾃身的虚函数到⾃身的虚函数表中。</li>
</ul>
<p>Derived *pd = new D(); B *pb = pd; C *pc = pd; 其中 pb，pd，pc 的指针位置是不同的，要注意的是派⽣类的⾃身的内容要追加在主基类的内存块后</p>
<h3 id="1-7-3、纯虚函数-（应⽤于接⼝继承和实现继承"><a href="#1-7-3、纯虚函数-（应⽤于接⼝继承和实现继承" class="headerlink" title="1.7.3、纯虚函数 （应⽤于接⼝继承和实现继承)"></a>1.7.3、纯虚函数 （应⽤于接⼝继承和实现继承)</h3><p>实际上，纯虚函数的出现就是为了让继承可以出现多种情况：</p>
<ul>
<li>有时我们希望派⽣类只继承成员函数的接⼝</li>
<li>有时我们⼜希望派⽣类既继承成员函数的接⼝，⼜继承成员函数的实现，⽽且可以在派⽣类中可以重写成员函数以实现多态</li>
<li>有的时候我们⼜希望派⽣类在继承成员函数接⼝和实现的情况下，不能᯿写缺省的实现。</li>
</ul>
<p>其实，声明⼀个纯虚函数的⽬的就是为了让派⽣类只继承函数的接⼝，⽽且派⽣类中必需提供⼀个这个纯虚函数的实现，否则含有纯虚函数的类将是抽象类，不能进⾏实例化。</p>
<p>对于纯虚函数来说，我们其实是可以给它提供实现代码的，但是由于抽象类不能实例化，调⽤这个实现的唯⼀⽅式是在派⽣类对象中指出其 class 名称来调⽤</p>
<h2 id="1-8-C-中重载和重写、重定义的区别"><a href="#1-8-C-中重载和重写、重定义的区别" class="headerlink" title="1.8 C++中重载和重写、重定义的区别"></a>1.8 C++中重载和重写、重定义的区别</h2><h2 id="1-9-介绍-C-所有的构造函数"><a href="#1-9-介绍-C-所有的构造函数" class="headerlink" title="1.9 介绍 C++ 所有的构造函数"></a>1.9 <strong>介绍</strong> <strong>C++</strong> 所有的构造函数</h2><p>类的对象被创建时，编译系统为对象分配内存空间，并⾃动调⽤构造函数，由构造函数完成成员的初始化⼯作。</p>
<p>即构造函数的作⽤：初始化对象的数据成员。</p>
<p><strong>⽆参数构造函数：</strong>即默认构造函数，如果没有明确写出⽆参数构造函数，编译器会⾃动⽣成默认的⽆参数构造函数，函数为空，什么也不做，如果不想使⽤⾃动⽣成的⽆参构造函数，必需要⾃⼰显示写出⼀个⽆参构造函数。</p>
<p><strong>⼀般构造函数：</strong>也称重载构造函数，⼀般构造函数可以有各种参数形式，⼀个类可以有多个⼀般构造函数，前提是参数的个数或者类型不同，创建对象时根据传⼊参数不同调⽤不同的构造函数。</p>
<p><strong>拷⻉构造函数：</strong>拷⻉构造函数的函数参数为对象本身的引⽤，⽤于根据⼀个已存在的对象复制出⼀个新的该类的对象，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。如果没有显示的写拷⻉构造函数，则系统会默认创建⼀个拷⻉构造函数，但当类中有指针成员时，最好不要使⽤编译器提供的默认的拷⻉构造函数，最好⾃⼰定义并且在函数中执⾏深拷⻉。</p>
<p><strong>类型转换构造函数：</strong>根据⼀个指定类型的对象创建⼀个本类的对象，也可以算是⼀般构造函数的⼀种，这⾥提出来，是想说有的时候不允许默认转换的话，要记得将其声明为 explict 的，来阻⽌⼀些隐式转换的发⽣。</p>
<p><strong>赋值运算符的重载</strong>：注意，这个类似拷⻉构造函数，将＝右边的本类对象的值复制给＝左边的对象，它不属于构造函数，＝左右两边的对象必需已经被创建。如果没有显示的写赋值运算符的重载，系统也会⽣成默认的赋值运算符，做⼀些基本的拷⻉⼯作。</p>
<h2 id="1-10-面向对象的三大特性"><a href="#1-10-面向对象的三大特性" class="headerlink" title="1.10 面向对象的三大特性"></a>1.10 面向对象的三大特性</h2><h3 id="1-10-1-封装"><a href="#1-10-1-封装" class="headerlink" title="1.10.1 封装"></a>1.10.1 封装</h3><p>就是把客观事物封装成抽象的类，并且类可以把⾃⼰的数据和⽅法只让信任的类或者对象操作，对不可信的进⾏信息隐藏。⼀个类就是⼀个封装了数据以及操作这些数据的代码的逻辑实体。在⼀个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种⽅式，对象对内部数据提供了不同级别的保护，以防⽌程序中⽆关的部分意外的改变或错误的使⽤了对象的私有部分。</p>
<h3 id="1-10-2-继承"><a href="#1-10-2-继承" class="headerlink" title="1.10.2 继承"></a>1.10.2 继承</h3><p>是指可以让某个类型的对象获得另⼀个类型的对象的属性的⽅法。它⽀持按级分类的概念。继承是指这样⼀种能⼒：它可以使⽤现有类的所有功能，并在⽆需᯿新编写原来的类的情况下对这些功能进⾏扩展。通过继承创建的新类称为“⼦类”或者“派⽣类”，被继承的类称为“基类”、“⽗类”或“超类”。继承的过程，就是从⼀般到特殊的过程。要实现继承，可以通过“继承”和“组合”来实现。</p>
<p>继承概念的实现⽅式有两类：</p>
<p><strong>实现继承：</strong>实现继承是指直接使⽤基类的属性和⽅法⽽⽆需额外编码的能⼒。</p>
<p><strong>接⼝继承：</strong>接口继承是指仅使⽤属性和⽅法的名称、但是⼦类必需提供实现的能⼒</p>
<h3 id="1-10-3-多态"><a href="#1-10-3-多态" class="headerlink" title="1.10.3 多态"></a>1.10.3 多态</h3><p>就是向不同的对象发送同⼀个消息，不同对象在接收时会产⽣不同的⾏为（即⽅法）。即⼀个接⼝，可以实现多种⽅法。</p>
<p>多态与⾮多态的实质区别就是函数地址是早绑定还是晚绑定的。如果函数的调⽤，在编译器编译期间就可以确定函数的调⽤地址，并产⽣代码，则是静态的，即地址早绑定。⽽如果函数调⽤的地址不能在编译器期间确定，需要在运⾏时才确定，这就属于晚绑定。</p>
<h3 id="1-10-4-多态的实现"><a href="#1-10-4-多态的实现" class="headerlink" title="1.10.4 多态的实现"></a>1.10.4 多态的实现</h3><p>多态其实⼀般就是指<strong>继承加虚函数实现的多态</strong>，对于᯿载来说，实际上基于的原理是，编译器为函数⽣成符号表时的不同规则，᯿载只是⼀种语⾔特性，与多态⽆关，与⾯向对象也⽆关，但这⼜是 C++中增加的新规则，所以也算属于 C++，所以如果⾮要说᯿载算是多态的⼀种，那就可以说：<strong>多态可以分为静态多态和动态多态。</strong></p>
<p>静态多态其实就是᯿载，因为静态多态是指在编译时期就决定了调⽤哪个函数，根据参数列表来决定；</p>
<p>动态多态是指通过⼦类᯿写⽗类的虚函数来实现的，因为是在运⾏期间决定调⽤的函数，所以称为动态多态，</p>
<p>⼀般情况下我们不区分这两个时所说的多态就是指动态多态。</p>
<p>动态多态的实现与虚函数表，虚函数指针相关。</p>
<h2 id="1-11析构函数和构造函数"><a href="#1-11析构函数和构造函数" class="headerlink" title="1.11析构函数和构造函数"></a>1.11析构函数和构造函数</h2><h3 id="1-11-1-析构函数⼀般写成虚函数的原因"><a href="#1-11-1-析构函数⼀般写成虚函数的原因" class="headerlink" title="1.11.1 析构函数⼀般写成虚函数的原因"></a>1.11.1 <strong>析构函数⼀般写成虚函数的原因</strong></h3><p>直观的讲：是为了降低内存泄漏的可能性。举例来说就是，⼀个基类的指针指向⼀个派⽣类的对象，在使⽤完毕准</p>
<p>备销毁时，如果基类的析构函数没有定义成虚函数，那 么编译器根据指针类型就会认为当前对象的类型是基类，调⽤基类的析构函数 （该对象的析构函数的函数地址早就被绑定为基类的析构函数），仅执⾏基类的析构，派⽣类的⾃身内容将⽆法被析构，造成内存泄漏。</p>
<p>如果基类的析构函数定义成虚函数，那么编译器就可以根据实际对象，执⾏派⽣类的析构函数，再执⾏基类的析构函数，成功释放内存</p>
<h3 id="1-11-2-构造函数为什么⼀般不定义为虚函数"><a href="#1-11-2-构造函数为什么⼀般不定义为虚函数" class="headerlink" title="1.11.2 构造函数为什么⼀般不定义为虚函数"></a>1.11.2 <strong>构造函数为什么⼀般不定义为虚函数</strong></h3><p>虚函数调⽤只需要知道“部分的”信息，即只需要知道函数接⼝，⽽不需要知道对象的具体类型。但是，我们要创建⼀个对象的话，是需要知道对象的完整信息的。特别是，需要知道要创建对象的确切类型，因此，构造函数不应该被定义成虚函数；</p>
<p>⽽且从⽬前编译器实现虚函数进⾏多态的⽅式来看，虚函数的调⽤是通过实例化之后对象的虚函数表指针来找到虚函数的地址进⾏调⽤的，如果说构造函数是虚的，那么虚函数表指针则是不存在的，⽆法找到对应的虚函数表来调⽤虚函数，那么这个调⽤实际上也是违反了先实例化后调⽤的准则。</p>
<h3 id="1-11-3、构造函数或析构函数中调⽤虚函数会怎样"><a href="#1-11-3、构造函数或析构函数中调⽤虚函数会怎样" class="headerlink" title="1.11.3、构造函数或析构函数中调⽤虚函数会怎样"></a>1.11.3、构造函数或析构函数中调⽤虚函数会怎样</h3><p>实际上是不应该在构造函数或析构函数中调⽤虚函数的，因为这样的调⽤其实并不会带来所想要的效果。</p>
<p>举例来说就是，有⼀个动物的基类，基类中定义了⼀个动物本身⾏为的虚函数 action_type()，在基类的构造函数中调⽤了这个虚函数。</p>
<p>派⽣类中重写了这个虚函数，我们期望着根据对象的真实类型不同，⽽调⽤各⾃实现的虚函数，但实际上当我们创建⼀个派⽣类对象时，⾸先会创建派⽣类的基类部分，执⾏基类的构造函数，此时，派⽣类的⾃身部分还没有被初始化，对于这种还没有初始化的东⻄，C++选择当它们还不存在作为⼀种安全的⽅法。</p>
<p>也就是说构造派⽣类的基类部分是，编译器会认为这就是⼀个基类类型的对象，然后调⽤基类类型中的虚函数实现，并没有按照我们想要的⽅式进⾏。即对象在派⽣类构造函数执⾏前并不会成为⼀个派⽣类对象。</p>
<p>在析构函数中也是同理，派⽣类执⾏了析构函数后，派⽣类的⾃身成员呈现未定义的状态，那么在执⾏基类的析构函数中是不可能调⽤到派⽣类᯿写的⽅法的。所以说，我们不应该在构在函数或析构函数中调⽤虚函数，就算调⽤⼀般也不会达到我们想要的结果。</p>
<h3 id="1-11-4-析构函数的作⽤，如何起作⽤？"><a href="#1-11-4-析构函数的作⽤，如何起作⽤？" class="headerlink" title="1.11.4 析构函数的作⽤，如何起作⽤？"></a>1.11.4 析构函数的作⽤，如何起作⽤？</h3><p>构造函数只是起初始化值的作⽤，但实例化⼀个对象的时候，可以通过实例去传递参数，从主函数传递到其他的函数⾥⾯，这样就使其他的函数⾥⾯有值了。规则，只要你⼀实例化对象，系统⾃动回调⽤⼀个构造函数，就是你不写，编译器也⾃动调⽤⼀次。</p>
<p>析构函数与构造函数的作⽤相反，⽤于撤销对象的⼀些特殊任务处理，可以是释放对象分配的内存空间；特点：析构函数与构造函数同名，但该函数前⾯加~。</p>
<p>析构函数没有参数，也没有返回值，⽽且不能᯿载，在⼀个类中只能有⼀个析构函数。 当撤销对象时，编译器也会⾃动调⽤析构函数。 每⼀个类必须有⼀个析构函数，⽤户可以⾃定义析构函数，也可以是编译器⾃动⽣成默认的析构函数。⼀般析构函数定义为类的公有成员</p>
<h3 id="1-11-5、构造函数的执⾏顺序？析构函数的执⾏顺序？"><a href="#1-11-5、构造函数的执⾏顺序？析构函数的执⾏顺序？" class="headerlink" title="1.11.5、构造函数的执⾏顺序？析构函数的执⾏顺序？"></a>1.11.5、构造函数的执⾏顺序？析构函数的执⾏顺序？</h3><ul>
<li><strong>构造函数顺序</strong></li>
</ul>
<ol>
<li>基类构造函数。如果有多个基类，则构造函数的调⽤顺序是某类在类派⽣表中出现的顺序，⽽不是它们在成员初始化表中的顺序。</li>
<li>成员类对象构造函数。如果有多个成员类对象则构造函数的调⽤顺序是对象在类中被声明的顺序，⽽不是它们出现在成员初始化表中的顺序。</li>
<li>派⽣类构造函数。</li>
</ol>
<ul>
<li><strong>析构函数顺序</strong></li>
</ul>
<ol>
<li>调⽤派⽣类的析构函数；</li>
<li>调⽤成员类对象的析构函数；</li>
<li>调⽤基类的析构函数。</li>
</ol>
<h3 id="1-11-6、什么情况下会调⽤拷⻉构造函数-三种情况"><a href="#1-11-6、什么情况下会调⽤拷⻉构造函数-三种情况" class="headerlink" title="1.11.6、什么情况下会调⽤拷⻉构造函数(三种情况)"></a>1.11.6、什么情况下会调⽤拷⻉构造函数(三种情况)</h3><p>类的对象需要拷⻉时，拷⻉构造函数将会被调⽤，以下的情况都会调⽤拷⻉构造函数：</p>
<p>⼀个对象以值传递的⽅式传⼊函数体，需要拷⻉构造函数创建⼀个临时对象压⼊到栈空间中。</p>
<p>⼀个对象以值传递的⽅式从函数返回，需要执⾏拷⻉构造函数创建⼀个临时对象作为返回值。</p>
<p>⼀个对象需要通过另外⼀个对象进⾏初始化。</p>
<h3 id="1-11-7、为什么拷⻉构造函数必需时引⽤传递，不能是值传递？"><a href="#1-11-7、为什么拷⻉构造函数必需时引⽤传递，不能是值传递？" class="headerlink" title="1.11.7、为什么拷⻉构造函数必需时引⽤传递，不能是值传递？"></a>1.11.7、为什么拷⻉构造函数必需时引⽤传递，不能是值传递？</h3><p>为了防⽌递归调⽤。当⼀个对象需要以值⽅式进⾏传递时，编译器会⽣成代码调⽤它的拷⻉构造函数⽣成⼀个副本，如果类 A 的拷⻉构造函数的参数不是引⽤传递，⽽是采⽤值传递，那么就⼜需要为了创建传递给拷⻉构造函数的参数的临时对象，⽽⼜⼀次调⽤类 A 的拷⻉构造函数，这就是⼀个⽆限递归</p>
<h2 id="1-12-静态绑定和动态绑定的介绍"><a href="#1-12-静态绑定和动态绑定的介绍" class="headerlink" title="1.12 静态绑定和动态绑定的介绍"></a>1.12 静态绑定和动态绑定的介绍</h2><p>说起静态绑定和动态绑定，我们⾸先要知道静态类型和动态类型，静态类型就是它在程序中被声明时所采⽤的类型，在编译期间确定。动态类型则是指“⽬前所指对象的实际类型”，在运⾏期间确定。</p>
<p>静态绑定，⼜名早绑定，绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发⽣在编译期间。</p>
<p>动态绑定，⼜名晚绑定，绑定的是动态类型，所对应的函数或属性依赖于动态类型，发⽣在运⾏期间。</p>
<p>⽐如说，virtual 函数是动态绑定的，⾮虚函数是静态绑定的，缺省参数值也是静态绑定的。这⾥呢，就需要注意，我们不应该᯿新定义继承⽽来的缺省参数，因为即使我们᯿定义了，也不会起到效果。因为⼀个基类的指针指向⼀个派⽣类对象，在派⽣类的对象中针对虚函数的参数缺省值进⾏了᯿定义， 但是缺省参数值是静态绑定的，静态绑定绑定的是静态类型相关的内容，所以会出现⼀种派⽣类的虚函数实现⽅式结合了基类的缺省参数值的调⽤效果，这个与所期望的效果不同</p>
<h2 id="1-13-深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）"><a href="#1-13-深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）" class="headerlink" title="1.13 深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）"></a>1.13 <strong>深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）</strong></h2><p>当出现类的等号赋值时，会调⽤拷⻉函数，在未定义显示拷⻉构造函数的情况下， 系统会调⽤默认的拷⻉函数－即浅拷⻉，它能够完成成员的⼀⼀复制。当数据成员中没有指针时，浅拷⻉是可⾏的。</p>
<p>但当数据成员中有指针时，如果采⽤简单的浅拷⻉，则两类中的两个指针指向同⼀个地址，当对象快要结束时，会调⽤两次析构函数，⽽导致指ᰀ指针的问题。</p>
<p>所以，这时必需采⽤深拷⻉。深拷⻉与浅拷⻉之间的区别就在于深拷⻉会在堆内存中另外申请空间来存储数据，从⽽也就解决来ᰀ指针的问题。简⽽⾔之，当数据成员中有指针时，必需要⽤深拷⻉更加安全。</p>
<h1 id="二、网络编程"><a href="#二、网络编程" class="headerlink" title="二、网络编程"></a>二、网络编程</h1><h2 id="2-1-HTTP常见面试题"><a href="#2-1-HTTP常见面试题" class="headerlink" title="2.1 HTTP常见面试题"></a>2.1 HTTP常见面试题</h2><img src="https://img-blog.csdnimg.cn/6b9bfd38d2684b3f9843ebabf8771212.png" alt="提纲" style="zoom:50%;" />

<h3 id="2-1-1-HTTP基本概念"><a href="#2-1-1-HTTP基本概念" class="headerlink" title="2.1.1 HTTP基本概念"></a>2.1.1 HTTP基本概念</h3><p><font color="#dd0000">HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</font><br /></p>
<h3 id="2-1-2-HTTP-常见的状态码有哪些？"><a href="#2-1-2-HTTP-常见的状态码有哪些？" class="headerlink" title="2.1.2 HTTP 常见的状态码有哪些？"></a>2.1.2 HTTP 常见的状态码有哪些？</h3><p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220829203731447.png" alt="image-20220829203731447"></p>
<h3 id="2-1-3-HTTP-常见字段有哪些？"><a href="#2-1-3-HTTP-常见字段有哪些？" class="headerlink" title="2.1.3 HTTP 常见字段有哪些？"></a>2.1.3 HTTP 常见字段有哪些？</h3><ol>
<li><p><em>Host</em>字段 : 客户端发送请求时，用来指定服务器的域名；  <code>Host: www.A.com</code></p>
</li>
<li><p><em>Content-Length 字段</em> ：服务器在返回数据时，会有 <code>Content-Length</code>字段，表明本次回应的数据长度；<code>Content-Length: 1000</code></p>
</li>
<li><p><em>Connection 字段</em> : <code>Connection</code>字段最常用于客户端要求服务器使用 TCP 持久连接，以便其他请求复用。<code>Connection: keep-alive</code>–长连接</p>
</li>
<li><p><em>Content-Type 字段</em> ：<code>Content-Type</code> 字段用于服务器回应时，告诉客户端，本次数据是什么格式。<code>Content-Type: text/html; charset=utf-8</code></p>
<p>客户端请求的时候，可以使用 <code>Accept</code> 字段声明自己可以接受哪些数据格式。<code>Accept: */*</code> 上面代码中，客户端声明自己可以接受任何格式的数据。</p>
</li>
<li><p><em>Content-Encoding 字段</em> : <code>Content-Encoding</code> 字段说明数据的压缩方法。表示服务器返回的数据使用了什么压缩格式。</p>
<p><code>Content-Encoding: gzip</code>上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。</p>
<p>客户端在请求时，用 <code>Accept-Encoding</code> 字段说明自己可以接受哪些压缩方<code>Accept-Encoding: gzip, deflate</code></p>
</li>
</ol>
<h3 id="2-1-4-GET-与-POST"><a href="#2-1-4-GET-与-POST" class="headerlink" title="2.1.4 GET 与 POST"></a>2.1.4 GET 与 POST</h3><h4 id="1-GET-和-POST-有什么区别？"><a href="#1-GET-和-POST-有什么区别？" class="headerlink" title="1 GET 和 POST 有什么区别？"></a>1 GET 和 POST 有什么区别？</h4><p>根据 RFC 规范，<strong>GET 的语义是从服务器获取指定的资源</strong>，这个资源可以是静态的文本、页面、图片视频等。</p>
<p>GET 请求的参数位置一般是写在 URL 中，URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符 ，而且浏览器会对 URL 的长度有限制</p>
<p>根据 RFC 规范，<strong>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</strong>，具体的处理方式视资源类型而不同。POST 请求携带数据的位置一般是写在报文 body 中， body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可，而且浏览器不会对 body 大小做限制。</p>
<h4 id="2-GET-和-POST-方法都是安全和幂等的吗？"><a href="#2-GET-和-POST-方法都是安全和幂等的吗？" class="headerlink" title="2 GET 和 POST 方法都是安全和幂等的吗？"></a>2 GET 和 POST 方法都是安全和幂等的吗？</h4><ul>
<li><p><strong>GET 方法就是安全且幂等的</strong>，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签</strong>。</p>
</li>
<li><p><strong>POST</strong> 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是<strong>不安全</strong>的，且多次提交数据就会创建多个资源，所以<strong>不是幂等</strong>的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</p>
</li>
</ul>
<ul>
<li>可以用 GET 方法实现新增或删除数据的请求，这样实现的 GET 方法自然就不是安全和幂等。</li>
<li>可以用 POST 方法实现查询数据的请求，这样实现的 POST 方法自然就是安全和幂等。</li>
</ul>
<h3 id="2-1-5-HTTP缓存技术"><a href="#2-1-5-HTTP缓存技术" class="headerlink" title="2.1.5 HTTP缓存技术"></a>2.1.5 HTTP缓存技术</h3><p>HTTP 缓存有两种实现方式，分别是<strong>强制缓存和协商缓存</strong>。</p>
<h3 id="2-1-6-HTTP-特性"><a href="#2-1-6-HTTP-特性" class="headerlink" title="2.1.6 HTTP 特性"></a>2.1.6 HTTP 特性</h3><h4 id="1-HTTP（1-1）-的优点有哪些？"><a href="#1-HTTP（1-1）-的优点有哪些？" class="headerlink" title="1. HTTP（1.1） 的优点有哪些？"></a>1. HTTP（1.1） 的优点有哪些？</h4><p>HTTP 最凸出的优点是「简单、灵活和易于扩展、应用广泛和跨平台」</p>
<h4 id="2-HTTP（1-1）-的缺点有哪些？"><a href="#2-HTTP（1-1）-的缺点有哪些？" class="headerlink" title="2.HTTP（1.1） 的缺点有哪些？"></a>2.HTTP（1.1） 的缺点有哪些？</h4><p>HTTP 协议里有优缺点一体的<strong>双刃剑</strong>，分别是「无状态、明文传输」，同时还有一大缺点「不安全」。</p>
<p>对于无状态的问题，解法方案有很多种，其中比较简单的方式用 <strong>Cookie</strong> 技术。</p>
<p><code>Cookie</code> 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<h4 id="3-HTTP-1-1-的性能如何？"><a href="#3-HTTP-1-1-的性能如何？" class="headerlink" title="3. HTTP/1.1 的性能如何？"></a>3. HTTP/1.1 的性能如何？</h4><p>HTTP 协议是基于 <strong>TCP/IP</strong>，并且使用了「<strong>请求 - 应答</strong>」的通信模式，所以性能的关键就在这<strong>两点</strong>里。</p>
<p><em>1. 长连接</em></p>
<p><em>2. 管道网络传输</em></p>
<p><em>3. 队头阻塞</em></p>
<h3 id="2-1-7-HTTP与HTTPS"><a href="#2-1-7-HTTP与HTTPS" class="headerlink" title="2.1.7 HTTP与HTTPS"></a>2.1.7 HTTP与HTTPS</h3><h4 id="1-HTTP与HTTPS有哪些区别"><a href="#1-HTTP与HTTPS有哪些区别" class="headerlink" title="1.HTTP与HTTPS有哪些区别"></a>1.HTTP与HTTPS有哪些区别</h4><ol>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ol>
<h4 id="2-HTTPS解决了HTTP的哪些问题"><a href="#2-HTTPS解决了HTTP的哪些问题" class="headerlink" title="2.HTTPS解决了HTTP的哪些问题"></a>2.HTTPS解决了HTTP的哪些问题</h4><p>HTTP 由于是明文传输，所以安全上存在以下三个风险：</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
<p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
<h2 id="2-2-TCP-常见面试题"><a href="#2-2-TCP-常见面试题" class="headerlink" title="2.2 TCP 常见面试题"></a>2.2 TCP 常见面试题</h2><h3 id="2-2-1-TCP头格式有哪些"><a href="#2-2-1-TCP头格式有哪些" class="headerlink" title="2.2.1 TCP头格式有哪些?"></a>2.2.1 TCP头格式有哪些?</h3><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzYuanBn?x-oss-process=image/format,png" alt="TCP 头格式" style="zoom:80%;" />



<p><strong>序列号</strong>：在建立连接时由计算机生成的随机数作为其初始值，通过 SYN 包传给接收端主机，每发送一次数据，就「累加」一次该「数据字节数」的大小。<strong>用来解决网络包乱序问题。</strong></p>
<p><strong>确认应答号</strong>：指下一次「期望」收到的数据的序列号，发送端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。<strong>用来解决丢包的问题。</strong></p>
<p><strong>控制位：</strong></p>
<ul>
<li><em>ACK</em>：该位为 <code>1</code> 时，「确认应答」的字段变为有效，TCP 规定除了最初建立连接时的 <code>SYN</code> 包之外该位必须设置为 <code>1</code> 。</li>
<li><em>RST</em>：该位为 <code>1</code> 时，表示 TCP 连接中出现异常必须强制断开连接。</li>
<li><em>SYN</em>：该位为 <code>1</code> 时，表示希望建立连接，并在其「序列号」的字段进行序列号初始值的设定。</li>
<li><em>FIN</em>：该位为 <code>1</code> 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 <code>FIN</code> 位为 1 的 TCP 段。</li>
</ul>
<h3 id="2-2-2-为什么需要TCP协议？TCP工作在哪一层？"><a href="#2-2-2-为什么需要TCP协议？TCP工作在哪一层？" class="headerlink" title="2.2.2 为什么需要TCP协议？TCP工作在哪一层？"></a>2.2.2 为什么需要TCP协议？TCP工作在哪一层？</h3><p><code>IP</code> 层是「不可靠」的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzcuanBn?x-oss-process=image/format,png" alt="OSI 参考模型与 TCP/IP 的关系"></p>
<p>如果需要保障网络数据包的可靠性，那么就需要由上层（传输层）的 <code>TCP</code> 协议来负责。</p>
<p>因为 TCP 是一个工作在<strong>传输层</strong>的<strong>可靠</strong>数据传输的服务，它能确保接收端接收的网络包是<strong>无损坏、无间隔、非冗余和按序的。</strong></p>
<h3 id="2-2-3-什么是-TCP-？"><a href="#2-2-3-什么是-TCP-？" class="headerlink" title="2.2.3 什么是 TCP ？"></a>2.2.3 什么是 TCP ？</h3><p>TCP 是<strong>面向连接的、可靠的、基于字节流</strong>的传输层通信协议。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzguanBn?x-oss-process=image/format,png" alt="img"></p>
<ul>
<li><strong>面向连接</strong>：一定是「一对一」才能连接，不能像 UDP 协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的；</li>
<li><strong>可靠的</strong>：无论的网络链路中出现了怎样的链路变化，TCP 都可以保证一个报文一定能够到达接收端；</li>
<li><strong>字节流</strong>：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li>
</ul>
<h3 id="2-2-4-什么是TCP连接"><a href="#2-2-4-什么是TCP连接" class="headerlink" title="2.2.4  什么是TCP连接"></a>2.2.4  什么是TCP连接</h3><h3 id="2-2-5-如何唯一确定一个TCP连接呢？"><a href="#2-2-5-如何唯一确定一个TCP连接呢？" class="headerlink" title="2.2.5 如何唯一确定一个TCP连接呢？"></a>2.2.5 如何唯一确定一个TCP连接呢？</h3><h3 id="2-2-6-UDP和TCP有什么区别呢？分别的应用场景是"><a href="#2-2-6-UDP和TCP有什么区别呢？分别的应用场景是" class="headerlink" title="2.2.6 UDP和TCP有什么区别呢？分别的应用场景是?"></a>2.2.6 UDP和TCP有什么区别呢？分别的应用场景是?</h3><h3 id="2-2-7-TCP三次握手过程是怎么样的？"><a href="#2-2-7-TCP三次握手过程是怎么样的？" class="headerlink" title="2.2.7 TCP三次握手过程是怎么样的？"></a>2.2.7 TCP三次握手过程是怎么样的？</h3><ul>
<li><p>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态</p>
</li>
<li><p>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</p>
</li>
<li><p>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</p>
</li>
<li><p>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</p>
</li>
<li><p>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</p>
</li>
</ul>
<p>==第三次握手是可以携带数据的，前两次握手是不可以携带数据的==</p>
<h3 id="2-2-8-如何在Linux系统中查看TCP状态？"><a href="#2-2-8-如何在Linux系统中查看TCP状态？" class="headerlink" title="2.2.8 如何在Linux系统中查看TCP状态？"></a>2.2.8 如何在Linux系统中查看TCP状态？</h3><p>TCP 的连接状态查看，在 Linux 可以通过 <code>netstat -napt</code> 命令查看。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3hpYW9saW5jb2Rlci9JbWFnZUhvc3QyLyVFOCVBRSVBMSVFNyVBRSU5NyVFNiU5QyVCQSVFNyVCRCU5MSVFNyVCQiU5Qy9UQ1AtJUU0JUI4JTg5JUU2JUFDJUExJUU2JThGJUExJUU2JTg5JThCJUU1JTkyJThDJUU1JTlCJTlCJUU2JUFDJUExJUU2JThDJUE1JUU2JTg5JThCLzE4LmpwZw?x-oss-process=image/format,png" alt="TCP 连接状态查看"></p>
<h3 id="2-2-9-为什么是三次握手？不是两次、四次？"><a href="#2-2-9-为什么是三次握手？不是两次、四次？" class="headerlink" title="2.2.9 为什么是三次握手？不是两次、四次？"></a>2.2.9 为什么是三次握手？不是两次、四次？</h3><ul>
<li><p>三次握手才可以阻止重复历史连接的初始化（主要原因）</p>
</li>
<li><p>三次握手才可以同步双方的初始序列号</p>
</li>
<li><p>三次握手才可以避免资源浪费</p>
</li>
<li><p>「两次握手」：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；</p>
</li>
<li><p>「四次握手」：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。</p>
</li>
</ul>
<h3 id="2-2-10-为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？"><a href="#2-2-10-为什么每次建立-TCP-连接时，初始化的序列号都要求不一样呢？" class="headerlink" title="2.2.10 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？"></a>2.2.10 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</h3><ul>
<li>为了防止历史报文被下一个相同四元组的连接接收（主要方面）；</li>
<li>为了安全性，防止黑客伪造的相同序列号的 TCP 报文被对方接收；</li>
</ul>
<h3 id="2-2-11-TCP四次挥手过程"><a href="#2-2-11-TCP四次挥手过程" class="headerlink" title="2.2.11 TCP四次挥手过程"></a>2.2.11 TCP四次挥手过程</h3><ul>
<li>户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSED</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSED</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<h3 id="2-2-12-TCP-重传、滑动窗口、流量控制、拥塞控制"><a href="#2-2-12-TCP-重传、滑动窗口、流量控制、拥塞控制" class="headerlink" title="2.2.12 TCP 重传、滑动窗口、流量控制、拥塞控制"></a>2.2.12 TCP 重传、滑动窗口、流量控制、拥塞控制</h3><h1 id="三、系统编程"><a href="#三、系统编程" class="headerlink" title="三、系统编程"></a>三、系统编程</h1><h2 id="3-1-操作系统特点"><a href="#3-1-操作系统特点" class="headerlink" title="3.1 操作系统特点"></a>3.1 操作系统特点</h2><p>并发性、共享性、虚拟性、不确定性。</p>
<h2 id="3-2-进程"><a href="#3-2-进程" class="headerlink" title="3.2 进程"></a>3.2 进程</h2><h3 id="3-2-2-进程"><a href="#3-2-2-进程" class="headerlink" title="3.2.2 进程"></a>3.2.2 进程</h3><p>进程是程序的⼀次执⾏，该程序可以与其他程序并发执⾏；</p>
<p>进程有运⾏、阻塞、就绪三个基本状态；</p>
<p>进程调度算法：先来先服务调度算法、短作业优先调度算法、⾮抢占式优先级调度算法、抢占式优先级调度算法、</p>
<p>⾼响应⽐优先调度算法、时间⽚轮转法调度算法；</p>
<h3 id="3-2-2-什么是进程"><a href="#3-2-2-什么是进程" class="headerlink" title="3.2.2 什么是进程"></a>3.2.2 什么是进程</h3><ol>
<li><p>进程是指在系统中正在运⾏的⼀个应⽤程序，程序⼀旦运⾏就是进程；</p>
</li>
<li><p>进程可以认为是程序执⾏的⼀个实例，进程是系统进⾏资源分配的最⼩单位，且每个进程拥有独⽴的地址空间；</p>
</li>
<li><p>⼀个进程⽆法直接访问另⼀个进程的变ᰁ和数据结构，如果希望⼀个进程去访问另⼀个进程的资源，需要使⽤进程间的通信，⽐如：管道、消息队列等</p>
</li>
<li><p>线程是进程的⼀个实体，是进程的⼀条执⾏路径；⽐进程更⼩的独⽴运⾏的基本单位，线程也被称为轻量级进程，⼀个程序⾄少有⼀个进程，⼀个进程⾄少有⼀个线程；</p>
</li>
</ol>
<h3 id="3-2-2-进程与线程的区别"><a href="#3-2-2-进程与线程的区别" class="headerlink" title="3.2.2 进程与线程的区别"></a>3.2.2 进程与线程的区别</h3><ol>
<li><p>同⼀进程的线程共享本进程的地址空间，⽽进程之间则是独⽴的地址空间；</p>
</li>
<li><p>同⼀进程内的线程共享本进程的资源，但是进程之间的资源是独⽴的；</p>
</li>
<li><p>⼀个进程崩溃后，在保护模式下不会对其他进程产⽣影响，但是⼀个线程崩溃整个进程崩溃，所以多进程⽐多线程健壮；</p>
</li>
<li><p>进程切换，消耗的资源⼤。所以涉及到频繁的切换，使⽤线程要好于进程；</p>
</li>
<li><p>两者均可并发执⾏；</p>
</li>
<li><p>每个独⽴的进程有⼀个程序的⼊⼝、程序出⼝。但是线程不能独⽴执⾏，必须依存在应⽤程序中，由应⽤程序提供多个线程执⾏控制。</p>
</li>
</ol>
<h3 id="3-2-3-进程状态转换图"><a href="#3-2-3-进程状态转换图" class="headerlink" title="3.2.3 进程状态转换图"></a>3.2.3 进程状态转换图</h3><p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913131748354.png" alt="image-20220913131748354"></p>
<ol>
<li><p>新状态：进程已经创建</p>
</li>
<li><p>就绪态：进程做好了准备，准备执⾏，等待分配处理机</p>
</li>
<li><p>执⾏态：该进程正在执⾏；</p>
</li>
<li><p>阻塞态：等待某事件发⽣才能执⾏，如等待I/O完成；</p>
</li>
<li><p>终⽌状态</p>
</li>
</ol>
<h3 id="3-2-4-进程的创建过程？需要哪些函数？需要哪些数据结构"><a href="#3-2-4-进程的创建过程？需要哪些函数？需要哪些数据结构" class="headerlink" title="3.2.4 进程的创建过程？需要哪些函数？需要哪些数据结构?"></a>3.2.4 进程的创建过程？需要哪些函数？需要哪些数据结构?</h3><ol>
<li><p>fork函数创造的⼦进程是⽗进程的完整副本，复制了⽗亲进程的资源，包括内存的内容task_struct内容；</p>
</li>
<li><p>vfork创建的⼦进程与⽗进程共享数据段，⽽且由vfork创建的⼦进程将先于⽗进程运⾏；</p>
</li>
<li><p>linux上创建线程⼀般使⽤的是pthread库，实际上linux也给我们提供了创建线程的系统调⽤，就是clone；</p>
</li>
</ol>
<h3 id="3-2-5-进程创建⼦进程-fork详解"><a href="#3-2-5-进程创建⼦进程-fork详解" class="headerlink" title="3.2.5 进程创建⼦进程,fork详解"></a>3.2.5 进程创建⼦进程,fork详解</h3><ol>
<li>函数原型</li>
</ol>
<p><code>pid_t fork(void); //void代表没有任何形式参数</code></p>
<ol start="2">
<li><p>除了0号进程（系统创建的）之外，linux系统中都是由其他进程创建的。创建新进程的进程，即调⽤fork函数的进程为⽗进程，新建的进程为⼦进程。</p>
</li>
<li><p>fork函数不需要任何参数，对于返回值有三种情况：</p>
<ul>
<li><p>对于⽗进程，fork函数返回新建⼦进程的pid</p>
</li>
<li><p>对于⼦进程，fork函数返回 0 </p>
</li>
<li><p>如果出错， fork 函数返回 -1</p>
</li>
</ul>
</li>
</ol>
<h3 id="3-2-6-⼦进程和⽗进程怎么通信？"><a href="#3-2-6-⼦进程和⽗进程怎么通信？" class="headerlink" title="3.2.6 ⼦进程和⽗进程怎么通信？"></a>3.2.6 ⼦进程和⽗进程怎么通信？</h3><ol>
<li><p>在 Linux 系统中实现⽗⼦进程的通信可以采⽤ pipe() 和 fork() 函数进⾏实现；</p>
</li>
<li><p>对于⽗⼦进程，在程序运⾏时⾸先进⼊的是⽗进程，其次是⼦进程，在此我个⼈认为，在创建⽗⼦进程的时候程序是先运⾏创建的程序，其次在复制⽗进程创建⼦进程。fork() 函数主要是以⽗进程为蓝本复制⼀个进程，其 ID 号和⽗进程的 ID 号不同。对于结果 fork出来的⼦进程的⽗进程 ID 号是执⾏ fork() 函数的进程的 ID 号。</p>
</li>
<li><p>管道：是指⽤于连接⼀个读进程和⼀个写进程，以实现它们之间通信的共享⽂件，⼜称 pipe ⽂件。</p>
</li>
<li><p>写进程在管道的尾端写⼊数据，读进程在管道的⾸端读出数据。</p>
</li>
</ol>
<h3 id="3-2-7-进程和作业的区别？"><a href="#3-2-7-进程和作业的区别？" class="headerlink" title="3.2.7 进程和作业的区别？"></a>3.2.7 进程和作业的区别？</h3><ol>
<li>进程是程序的⼀次动态执⾏，属于动态概念；</li>
<li>⼀个进程可以执⾏⼀个或⼏个程序，同⼀个程序可由⼏个进程执⾏；</li>
<li>程序可以作为⼀种软件资源⻓期保留，⽽进程是程序的⼀次执⾏；</li>
<li>进程具有并发性，能与其他进程并发执⾏；</li>
<li>进程是⼀个独⽴的运⾏单位；</li>
</ol>
<h3 id="3-2-8-进程间通信⽅式有⼏种，他们之间的区别是什么？"><a href="#3-2-8-进程间通信⽅式有⼏种，他们之间的区别是什么？" class="headerlink" title="3.2.8 进程间通信⽅式有⼏种，他们之间的区别是什么？"></a>3.2.8 进程间通信⽅式有⼏种，他们之间的区别是什么？</h3><ol>
<li>管道</li>
</ol>
<p>管道，通常指⽆名管道。</p>
<p>① 半双⼯的，具有固定的读端和写端；</p>
<p>② 只能⽤于具有亲属关系的进程之间的通信；</p>
<p>③ 可以看成是⼀种特殊的⽂件，对于它的读写也可以使⽤普通的read、write函数。但是它不是普通的⽂件，并不属于其他任何⽂件系统，只能⽤于内存中。</p>
<p>④ Int pipe(int fd[2]);当⼀个管道建⽴时，会创建两个⽂件⽂件描述符，要关闭管道只需将这两个⽂件描述符关闭即可</p>
<ol start="2">
<li>FiFO（有名管道）</li>
</ol>
<p>① FIFO可以再⽆关的进程之间交换数据，与⽆名管道不同；</p>
<p>② FIFO有路径名与之相关联，它以⼀种特殊设备⽂件形式存在于⽂件系统中；</p>
<p>③ Int mkfifo(const char* pathname,mode_t mode);</p>
<ol start="3">
<li>消息队列</li>
</ol>
<p>① 消息队列，是消息的连接表，存放在内核中。⼀个消息队列由⼀个标识符来标识；</p>
<p>② 消息队列是⾯向记录的，其中的消息具有特定的格式以及特定的优先级；</p>
<p>③ 消息队列独⽴于发送与接收进程。进程终⽌时，消息队列及其内容并不会被删除；</p>
<p>④ 消息队列可以实现消息的随机查询</p>
<ol start="4">
<li>信号量</li>
</ol>
<p>① 信号量是⼀个计数器，信号ᰁ⽤于实现进程间的互斥与同步，⽽不是⽤于存储进程间通信数据；</p>
<p>② 信号量⽤于进程间同步，若要在进程间传递数据需要结合共享内存；</p>
<p>③ 信号量基于操作系统的PV操作，程序对信号ᰁ的操作都是原⼦操作；</p>
<ol start="5">
<li>共享内存</li>
</ol>
<p>① 共享内存，指两个或多个进程共享⼀个给定的存储区；</p>
<p>② 共享内存是最快的⼀种进程通信⽅式，因为进程是直接对内存进⾏存取；</p>
<p>③ 因为多个进程可以同时操作，所以需要进⾏同步；</p>
<p>④ 信号量+共享内存通常结合在⼀起使⽤。</p>
<h3 id="3-2-9-线程同步的⽅式？怎么⽤？"><a href="#3-2-9-线程同步的⽅式？怎么⽤？" class="headerlink" title="3.2.9 线程同步的⽅式？怎么⽤？"></a>3.2.9 线程同步的⽅式？怎么⽤？</h3><ol>
<li><p>线程同步是指多线程通过特定的设置来控制线程之间的执⾏顺序，也可以说在线程之间通过同步建⽴起执⾏顺序的关系；</p>
</li>
<li><p>主要四种⽅式，临界区、互斥对象、信号量、事件对象；其中临界区和互斥对象主要⽤于互斥控制，信号量和事件对象主要⽤于同步控制；</p>
</li>
<li><p>临界区：通过对多线程的串⾏化来访问公共资源或⼀段代码，速度快、适合控制数据访问。在任意⼀个时刻只允许⼀个线程对共享资源进⾏访问，如果有多个线程试图访问公共资源，那么在有⼀个线程进⼊后，其他试图访问公共资源的线程将被挂起，并⼀直等到进⼊临界区的线程离开，临界区在被释放后，其他线程才可以抢占。</p>
</li>
<li><p>互斥对象：互斥对象和临界区很像，采⽤互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有⼀个，所以能保证公共资源不会同时被多个线程同时访问。当前拥有互斥对象的线程处理完任务后必须将线程交出，以便其他线程访问该资源。</p>
</li>
<li><p>信号量：它允许多个线程在同⼀时刻访问同⼀资源，但是需要限制在同⼀时刻访问此资源的最⼤线程数⽬。在⽤CreateSemaphore()创建信号量时即要同时指出允许的最⼤资源计数和当前可⽤资源计数。⼀般是将当前可⽤资源计数设置为最 ⼤资源计数，每增加⼀个线程对共享资源的访问，当前可⽤资源计数就会减1 ，只要当前可⽤资源计数是⼤于0 的，就可以发出信号量信号。但是当前可⽤计数减⼩ 到0 时则说明当前占⽤资源的线程数已经达到了所允许的最⼤数⽬，不能在允许其他线程的进⼊，此时的信号ᰁ信号将⽆法发出。线程在处理完共享资源后，应在离开的同时通过ReleaseSemaphore （）函数将当前可⽤资源计数加1 。在任何时候当前可⽤资源计数决不可能⼤于最⼤资源计数</p>
</li>
<li><p>事件对象：通过通知操作的⽅式来保持线程的同步，还可以⽅便实现对多个线程的优先级⽐较的操作。</p>
</li>
</ol>
<h3 id="3-2-10-线程同步的⽅式？怎么⽤？"><a href="#3-2-10-线程同步的⽅式？怎么⽤？" class="headerlink" title="3.2.10 线程同步的⽅式？怎么⽤？"></a>3.2.10 线程同步的⽅式？怎么⽤？</h3><p>1、 ⼀般情况下，⼦进程是由⽗进程创建，⽽⼦进程和⽗进程的退出是⽆顺序的，两者之间都不知道谁先退出。正常情况下⽗进程先结束会调⽤ wait 或者 waitpid 函数等待⼦进程完成再退出，⽽⼀旦⽗进程不等待直接退出，则剩下的⼦进程会被init(pid=1)进程接收，成会孤⼉进程。（进程树中除了init都会有⽗进程）。</p>
<p>2、 如果⼦进程先退出了，⽗进程还未结束并且没有调⽤ wait 或者 waitpid 函数获取⼦进程的状态信息，则⼦进程残留的状态信息（ task_struct 结构和少量资源信息）会变成僵⼫进程。⼦进程退出时向⽗进程发送SIGCHILD信号，⽗进程处理SIGCHILD信号。在信号处理函数中调⽤wait进⾏处理僵⼫进程。</p>
<p>原理是将⼦进程成为孤⼉进程，从⽽其的⽗进程变为init进程，通过init进程可以处理僵⼫进程。</p>
<p>3、 守护进程（ daemon) 是指在后台运⾏，没有控制终端与之相连的进程。它独⽴于控制终端，通常周期性地执⾏某种任务 。守护进程脱离于终端是为了避免进程在执⾏过程中的信息在任何终端上显示并且进程也不会被任何终端所产⽣的终端信息所打断。</p>
<h3 id="3-2-11-孤⼉进程和僵⼫进程的区别？怎么避免这两类进程？守护进程？"><a href="#3-2-11-孤⼉进程和僵⼫进程的区别？怎么避免这两类进程？守护进程？" class="headerlink" title="3.2.11 孤⼉进程和僵⼫进程的区别？怎么避免这两类进程？守护进程？"></a>3.2.11 孤⼉进程和僵⼫进程的区别？怎么避免这两类进程？守护进程？</h3><p>1、 ⼀般情况下，⼦进程是由⽗进程创建，⽽⼦进程和⽗进程的退出是⽆顺序的，两者之间都不知道谁先退出。正常情况下⽗进程先结束会调⽤ wait 或者 waitpid 函数等待⼦进程完成再退出，⽽⼀旦⽗进程不等待直接退出，则剩下的⼦进程会init(pid=1)进程接收，成会孤⼉进程。（进程树中除了init都会有⽗进程）。</p>
<p>2、 如果⼦进程先退出了，⽗进程还未结束并且没有调⽤ wait 或者 waitpid 函数获取⼦进程的状态信息，则⼦进程残留的状态信息（ task_struct 结构和少ᰁ资源信息）会变成僵⼫进程。</p>
<p>⼦进程退出时向⽗进程发送SIGCHILD信号，⽗进程处理SIGCHILD信号。在信号处理函数中调⽤wait进⾏处理僵⼫进程。</p>
<p>原理是将⼦进程成为孤⼉进程，从⽽其的⽗进程变为init进程，通过init进程可以处理僵⼫进程。</p>
<p>3、 守护进程（ daemon) 是指在后台运⾏，没有控制终端与之相连的进程。它独⽴于控制终端，通常周期性地执⾏某种任务 。守护进程脱离于终端是为了避免进程在执⾏过程中的信息在任何终端上显示并且进程也不会被任何终端所产⽣的终端信息所打断。</p>
<h3 id="3-2-12-守护进程是什么？怎么实现？"><a href="#3-2-12-守护进程是什么？怎么实现？" class="headerlink" title="3.2.12 守护进程是什么？怎么实现？"></a>3.2.12 守护进程是什么？怎么实现？</h3><ol>
<li>守护进程（Daemon）是运⾏在后台的⼀种特殊进程。它独⽴于控制终端并且周期性地执⾏某种任务或等待处</li>
</ol>
<p>理某些发⽣的事件。守护进程是⼀种很有⽤的进程。</p>
<ol start="2">
<li>守护进程特点</li>
</ol>
<p>​        a. 守护进程最᯿要的特性是后台运⾏。</p>
<p>​        b. 守护进程必须与其运⾏前的环境隔离开来。这些环境包括未关闭的⽂件描述符，控制终端，会话和进程组，⼯作⽬录以及⽂件创建掩模等。这些环境通常是守护进程从执⾏它的⽗进程（特别是shell）中继承下来的。</p>
<p>​        c. 守护进程的启动⽅式有其特殊之处。它可以在Linux系统启动时从启动脚本/etc/rc.d中启动，可以由作业规划进程crond启动，还可以由⽤户终端（shell）执⾏。</p>
<ol start="3">
<li>实现</li>
</ol>
<p>​        a.在⽗进程中执⾏fork并exit推出；</p>
<p>​        b. 在⼦进程中调⽤setsid函数创建新的会话；</p>
<p>​        c.在⼦进程中调⽤chdir函数，让根⽬录 ”/” 成为⼦进程的⼯作⽬录；</p>
<p>​        d. 在⼦进程中调⽤umask函数，设置进程的umask为0；</p>
<p>​        e.在⼦进程中关闭任何不需要的⽂件描述符</p>
<h3 id="3-2-13-线程和进程的区别？线程共享的资源是什么？"><a href="#3-2-13-线程和进程的区别？线程共享的资源是什么？" class="headerlink" title="3.2.13 线程和进程的区别？线程共享的资源是什么？"></a>3.2.13 线程和进程的区别？线程共享的资源是什么？</h3><ol>
<li><p>⼀个程序⾄少有⼀个进程，⼀个进程⾄少有⼀个线程</p>
</li>
<li><p>线程的划分尺度⼩于进程，使得多线程程序的并发性⾼</p>
</li>
<li><p>进程在执⾏过程中拥有独⽴的内存单元，⽽多个线程共享内存，从⽽极⼤地提⾼了程序的运⾏效率</p>
</li>
<li><p>每个独⽴的线程有⼀个程序运⾏的⼊⼝、顺序执⾏序列和程序的出⼝。但是线程不能够独⽴执⾏，必须依存在应⽤程序中，由应⽤程序提供多个线程执⾏控制</p>
</li>
<li><p>多线程的意义在于⼀个应⽤程序中，有多个执⾏部分可以同时执⾏。但操作系统并没有将多个线程看做多个独⽴</p>
</li>
</ol>
<p>的应⽤，来实现进程的调度和管理以及资源分配</p>
<ol start="6">
<li>⼀个进程中的所有线程共享该进程的地址空间，但它们有各⾃独⽴的（私有的）栈(stack)，Windows 线程的缺省堆栈⼤⼩为1M。堆(heap)的分配与栈有所不同，⼀般是⼀个进程有⼀个C运⾏时堆，这个堆为本进程中所有线程共享，windows 进程还有所谓进程默认堆，⽤户也可以创建⾃⼰的堆</li>
</ol>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913133504386.png" alt="image-20220913133504386"></p>
<ul>
<li>线程私有：线程栈，寄存器，程序寄存器</li>
<li>共享：堆，地址空间，全局变量，静态变量</li>
<li>进程私有：地址空间，堆，全局变量，栈，寄存器</li>
<li>共享：代码段，公共数据，进程⽬录，进程ID</li>
</ul>
<h3 id="3-2-14-线程⽐进程具有哪些优势？"><a href="#3-2-14-线程⽐进程具有哪些优势？" class="headerlink" title="3.2.14 线程⽐进程具有哪些优势？"></a>3.2.14 线程⽐进程具有哪些优势？</h3><ol>
<li><p>线程在程序中是独⽴的，并发的执⾏流，但是，进程中的线程之间的隔离程度要⼩；</p>
</li>
<li><p>线程⽐进程更具有更⾼的性能，这是由于同⼀个进程中的线程都有共性：多个线程将共享同⼀个进程虚拟空间；</p>
</li>
<li><p>当操作系统创建⼀个进程时，必须为进程分配独⽴的内存空间，并分配⼤ᰁ相关资源；</p>
</li>
</ol>
<h3 id="3-2-15-什么时候⽤多进程？什么时候⽤多线程？"><a href="#3-2-15-什么时候⽤多进程？什么时候⽤多线程？" class="headerlink" title="3.2.15 什么时候⽤多进程？什么时候⽤多线程？"></a>3.2.15 什么时候⽤多进程？什么时候⽤多线程？</h3><ol>
<li><p>需要频繁创建销毁的优先⽤线程；</p>
</li>
<li><p>需要进⾏⼤量计算的优先使⽤线程；</p>
</li>
<li><p>强相关的处理⽤线程，弱相关的处理⽤进程；</p>
</li>
<li><p>可能要扩展到多机分布的⽤进程，多核分布的⽤线程；</p>
</li>
</ol>
<h3 id="3-2-16-协程是什么？"><a href="#3-2-16-协程是什么？" class="headerlink" title="3.2.16 协程是什么？"></a>3.2.16 协程是什么？</h3><ol>
<li><p>是⼀种⽐线程更加轻量级的存在。正如⼀个进程可以拥有多个线程⼀样，⼀个线程可以拥有多个协程；协程不是被操作系统内核管理，⽽完全是由程序所控制。</p>
</li>
<li><p>协程的开销远远⼩于线程；</p>
</li>
<li><p>协程拥有⾃⼰寄存器上下⽂和栈。协程调度切换时，将寄存器上下⽂和栈保存到其他地⽅，在切换回来的时候，恢复先前保存的寄存器上下⽂和栈。</p>
</li>
<li><p>每个协程表示⼀个执⾏单元，有⾃⼰的本地数据，与其他协程共享全局数据和其他资源。</p>
</li>
<li><p>跨平台、跨体系架构、⽆需线程上下⽂切换的开销、⽅便切换控制流，简化编程模型；</p>
</li>
<li><p>协程⼜称为微线程，协程的完成主要靠<code>yeild</code>关键字，协程执⾏过程中，在⼦程序内部可中断，然后转⽽执⾏别的⼦程序，在适当的时候再返回来接着执⾏；</p>
</li>
<li><p>协程极⾼的执⾏效率，和多线程相⽐，线程数ᰁ越多，协程的性能优势就越明显；</p>
</li>
<li><p>不需要多线程的锁机制；</p>
</li>
</ol>
<h3 id="3-2-17-线程安全？如何实现？"><a href="#3-2-17-线程安全？如何实现？" class="headerlink" title="3.2.17  线程安全？如何实现？"></a>3.2.17  线程安全？如何实现？</h3><ol>
<li><p>如果你的代码所在的进程中有多个线程在同时运⾏，⽽这些线程可能会同时运⾏这段代码。如果每次运⾏结果和[单线程]运⾏的结果是⼀样的，⽽且其他的变ᰁ的值也和预期的是⼀样的，就是线程安全的。</p>
</li>
<li><p>线程安全问题都是由[全局变ᰁ及[静态变ᰁ]引起的。</p>
</li>
<li><p>若每个线程中对全局变ᰁ、静态变ᰁ只有读操作，⽽⽆写操作，⼀般来说，这个全局变ᰁ是线程安全的；若有多个线程同时执⾏写操作，⼀般都需要考虑[线程同步]，否则的话就可能影响线程安全。</p>
</li>
<li><p>对于线程不安全的对象我们可以通过如下⽅法来实现线程安全：</p>
</li>
</ol>
<p>​        ① 加锁 利⽤Synchronized或者ReenTrantLock来对不安全对象进⾏加锁，来实现线程执⾏的串⾏化，从⽽保证多线程同时操作对象的安全性，⼀个是语法层⾯的互斥锁，⼀个是API层⾯的互斥锁. </p>
<p>​        ② ⾮阻塞同步来实现线程安全。原理就是：通俗点讲，就是先进性操作，如果没有其他线程争⽤共享数据，那操作就成功了；如果共享数据有争⽤，产⽣冲突，那就再采取其他措施(最常⻅的措施就是不断地᯿试，知道成功为⽌)。这种⽅法需要硬件的⽀持，因为我们需要操作和冲突检测这两个步骤具备原⼦性。通常这种指令包括CAS</p>
<p>SC,FAI TAS等。</p>
<p>​        ③ 线程本地化，⼀种⽆同步的⽅案，就是利⽤Threadlocal来为每⼀个线程创造⼀个共享变ᰁ的副本来（副本之间是⽆关的）避免⼏个线程同时操作⼀个对象时发⽣线程安全问题。</p>
<h2 id="3-3-锁"><a href="#3-3-锁" class="headerlink" title="3.3 锁"></a>3.3 锁</h2><h3 id="3-3-1死锁是什么？必要条件？如何解决？"><a href="#3-3-1死锁是什么？必要条件？如何解决？" class="headerlink" title="3.3.1死锁是什么？必要条件？如何解决？"></a>3.3.1<strong>死锁是什么？必要条件？如何解决？</strong></h3><p>所谓死锁，是指多个进程循环等待它⽅占有的资源⽽⽆限期地僵持下去的局⾯。很显然，如果没有外⼒的作⽤，那麽死锁涉及到的各个进程都将永远处于封锁状态。当两个或两个以上的进程同时对多个互斥资源提出使⽤要求时，有可能导致死锁。</p>
<p>〈1〉 互斥条件。即某个资源在⼀段时间内只能由⼀个进程占有，不能同时被两个或两个以上的进程占有。这种独占资源如CD-ROM驱动器，打印机等等，必须在占有该资源的进程主动释放它之后，其它进程才能占有该资源。这是由资源本身的属性所决定的。如独⽊桥就是⼀种独占资源，两⽅的⼈不能同时过桥。</p>
<p>〈2〉 不可抢占条件。进程所获得的资源在未使⽤完毕之前，资源申请者不能强⾏地从资源占有者⼿中夺取资源，⽽只能由该资源的占有者进程⾃⾏释放。如过独⽊桥的⼈不能强迫对⽅后退，也不能⾮法地将对⽅推下桥，必须是桥上的⼈⾃⼰过桥后空出桥⾯（即主动释放占有资源），对⽅的⼈才能过桥。</p>
<p>〈3〉 占有且申请条件。进程⾄少已经占有⼀个资源，但⼜申请新的资源；由于该资源已被另外进程占有，此时该进程阻塞；但是，它在等待新资源之时，仍继续占⽤已占有的资源。还以过独⽊桥为例，甲⼄两⼈在桥上相遇。甲⾛过⼀段桥⾯（即占有了⼀些资源），还需要⾛其余的桥⾯（申请新的资源），但那部分桥⾯被⼄占有（⼄⾛过⼀段桥⾯）。甲过不去，前进不能，⼜不后退；⼄也处于同样的状况。</p>
<p>〈4〉 循环等待条件。存在⼀个进程等待序列{P1，P2，…，Pn}，其中P1等待P2所占有的某⼀资源，P2等待P3所占有的某⼀源，……，⽽Pn等待P1所占有的的某⼀资源，形成⼀个进程循环等待环。就像前⾯的过独⽊桥问题，甲等待⼄占有的桥⾯，⽽⼄⼜等待甲占有的桥⾯，从⽽彼此循环等待。死锁的预防是保证系统不进⼊死锁状态的⼀种策略。它的基本思想是要求进程申请资源时遵循某种协议，从⽽打破产⽣死锁的四个必要条件中的⼀个或⼏个，保证系统不会进⼊死锁状态。</p>
<p>&lt;1&gt;打破互斥条件。即允许进程同时访问某些资源。但是，有的资源是不允许被同时访问的，像打印机等等，这是由资源本身的属性所决定的。所以，这种办法并⽆实⽤价值。</p>
<p>&lt;2&gt;打破不可抢占条件。即允许进程强⾏从占有者那⾥夺取某些资源。就是说，当⼀个进程已占有了某些资源，它⼜申请新的资源，但不能⽴即被满⾜时，它必须释放所占有的全部资源，以后再᯿新申请。它所释放的资源可以分配给其它进程。这就相当于该进程占有的资源被隐蔽地强占了。这种预防死锁的⽅法实现起来困难，会降低系统性能。 </p>
<p>&lt;3&gt;打破占有且申请条件。可以实⾏资源预先分配策略。即进程在运⾏前⼀次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满⾜，则不分配任何资源，此进程暂不运⾏。只有当系统能够满⾜当前进程的全部资源需求时，才⼀次性地将所申请的资源全部分配给该进程。由于运⾏的进程已占有了它所需的全部资源，所以不会发⽣占有资源⼜申请资源的现象，因此不会发⽣死锁。</p>
<p>&lt;4&gt;打破循环等待条件，实⾏资源有序分配策略。采⽤这种策略，即把资源事先分类编号，按号分配，使进程在申请，占⽤资源时不会形成环路。所有进程对资源的请求必须严格按资源序号递增的顺序提出。进程占⽤了⼩号资源，才能申请⼤号资源，就不会产⽣环路，从⽽预防了死锁</p>
<p>死锁避免：银⾏家算法</p>
<h3 id="3-3-2-递归锁？"><a href="#3-3-2-递归锁？" class="headerlink" title="3.3.2 递归锁？"></a>3.3.2 递归锁？</h3><ol>
<li><p>线程同步能够保证多个线程安全访问竞争资源，最简单的同步机制是引⼊互斥锁。互斥锁为资源引⼊⼀个状态：锁定/⾮锁定。某个线程要更改共享数据时，先将其锁定，此时资源的状态为“锁定”，其他线程不能更改；直到该线程释放资源，将资源的状态变成“⾮锁定”，其他的线程才能再次锁定该资源。互斥锁保证了每次只有⼀个线程进⾏写⼊操作，从⽽保证了多线程情况下数据的正确性。</p>
</li>
<li><p>读写锁从⼴义的逻辑上讲，也可以认为是⼀种共享版的互斥锁。如果对⼀个临界区⼤部分是读操作⽽只有少量的写操作，读写锁在⼀定程度上能够降低线程互斥产⽣的代价。</p>
</li>
<li><p>Mutex可以分为递归锁(recursive mutex)和⾮递归锁(non-recursive mutex)。可递归锁也可称为可᯿⼊锁(reentrant mutex)，⾮递归锁⼜叫不可重⼊锁(non-reentrant mutex)。⼆者唯⼀的区别是，同⼀个线程可以多次获取同⼀个递归锁，不会产⽣死锁。⽽如果⼀个线程多次获取同⼀个⾮递归锁，则会产⽣死锁。</p>
</li>
</ol>
<h2 id="3-4-中断"><a href="#3-4-中断" class="headerlink" title="3.4 中断"></a>3.4 中断</h2><h3 id="3-4-1-⽤户态到内核态的转化原理？"><a href="#3-4-1-⽤户态到内核态的转化原理？" class="headerlink" title="3.4.1 ⽤户态到内核态的转化原理？"></a>3.4.1 ⽤户态到内核态的转化原理？</h3><ol>
<li><p>系统调⽤</p>
<p>这是⽤户态进程主动要求切换到内核态的⼀种⽅式，⽤户态进程通过系统调⽤申请使⽤操作系统提供的服务程序完成⼯作，⽐如前例中fork()实际上就是执⾏了⼀个创建新进程的系统调⽤。⽽系统调⽤的机制其核⼼还是使⽤了操作系统为⽤户特别开放的⼀个中断来实现，例如 Linux 的 int 80h 中断。</p>
</li>
<li><p>异常</p>
<p>当 CPU 在执⾏运⾏在⽤户态下的程序时，发⽣了某些事先不可知的异常，这时会触发由当前运⾏进程切换到处理此异常的内核相关程序中，也就转到了内核态，⽐如缺⻚异常。</p>
</li>
<li><p>外围设备的中断</p>
<p>当外围设备完成⽤户请求的操作后，会向 CPU 发出相应的中断信号，这时 CPU 会暂停执⾏下⼀条即将要执⾏的指令转⽽去执⾏与中断信号对应的处理程序，如果先前执⾏的指令是⽤户态下的程序，那么这个转换的过程⾃然也就发⽣了由⽤户态到内核态的切换。⽐如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执⾏后续操作等。</p>
</li>
</ol>
<h3 id="3-4-2-中断的实现与作⽤，中断的实现过程？"><a href="#3-4-2-中断的实现与作⽤，中断的实现过程？" class="headerlink" title="3.4.2 中断的实现与作⽤，中断的实现过程？"></a>3.4.2 中断的实现与作⽤，中断的实现过程？</h3><ol>
<li>关中断，进⼊不可再次响应中断的状态，由硬件实现。</li>
<li>保存断点，为了在[中断处理]结束后能正确返回到中断点。由硬件实现。</li>
<li>将[中断服务程序]⼊⼝地址送PC，转向[中断服务程序]。可由硬件实现，也可由软件实现。</li>
<li>保护现场、置屏蔽字、开中断，即保护CPU中某些寄存器的内容、设置[中断处理]次序、允许更⾼级的中断请求得到响应，实现中断嵌套由软件实现。</li>
<li>设备服务，实际上有效的中断处理⼯作是在此程序段中实现的。由软件程序实现</li>
<li>退出中断。在退出时，⼜应进⼊不可中断状态，即关中断、恢复屏蔽字、恢复现场、开中断、中断返回。由软件实现。</li>
</ol>
<h3 id="3-4-3-系统中断是什么，⽤户态和内核态的区别"><a href="#3-4-3-系统中断是什么，⽤户态和内核态的区别" class="headerlink" title="3.4.3 系统中断是什么，⽤户态和内核态的区别"></a>3.4.3 系统中断是什么，⽤户态和内核态的区别</h3><ol>
<li><p>内核态与⽤户态是操作系统的两种运⾏级别,当程序运⾏在3级特权级上时，就可以称之为运⾏在⽤户态，因为这是最低特权级，是普通的⽤户进程运⾏的特权级，⼤部分⽤户直接⾯对的程序都是运⾏在⽤户态；反之，当程序运⾏在0级特权级上时，就可以称之为运⾏在内核态。运⾏在⽤户态下的程序不能直接访问操作系统内核数据结构和程序。当我们在系统中执⾏⼀个程序时，⼤部分时间是运⾏在⽤户态下的，在其需要操作系统帮助完成某些它没有权⼒和能⼒完成的⼯作时就会切换到内核态。</p>
</li>
<li><p>这两种状态的主要差别是： 处于⽤户态执⾏时，进程所能访问的内存空间和对象受到限制，其所处于占有的处理机是可被抢占的 ； ⽽处于核⼼态执⾏中的进程，则能访问所有的内存空间和对象，且所占有的处理机是不允许被抢占的。</p>
</li>
</ol>
<h3 id="3-4-4-CPU中断"><a href="#3-4-4-CPU中断" class="headerlink" title="3.4.4 CPU中断"></a>3.4.4 CPU中断</h3><ol>
<li>CPU中断是什么</li>
</ol>
<p>​        ① 计算机处于执⾏期间；</p>
<p>​        ② 系统内发⽣了⾮寻常或⾮预期的急需处理事件；</p>
<p>​        ③ CPU暂时中断当前正在执⾏的程序⽽转去执⾏相应的事件处理程序；</p>
<p>​        ④ 处理完毕后返回原来被中断处继续执⾏；</p>
<ol start="2">
<li>CPU中断的作⽤</li>
</ol>
<p>​        ① 可以使CPU和外设同时⼯作，使系统可以及时地响应外部事件；</p>
<p>​        ② 可以允许多个外设同时⼯作，⼤⼤提⾼了CPU的利⽤率；</p>
<p>​        ③ 可以使CPU及时处理各种软硬件故障。</p>
<h3 id="3-4-5-CPU中断"><a href="#3-4-5-CPU中断" class="headerlink" title="3.4.5 CPU中断"></a>3.4.5 CPU中断</h3><p>1．执⾏⽤户程序(如:fork)</p>
<p>2． 根据glibc中的函数实现，取得系统调⽤号并执⾏int $0x80产⽣中断。</p>
<p>3． 进⾏地址空间的转换和堆栈的切换，执⾏SAVE_ALL。（进⾏内核模式）</p>
<p>4． 进⾏中断处理，根据系统调⽤表调⽤内核函数。</p>
<p>5． 执⾏内核函数。</p>
<p>6． 执⾏ RESTORE_ALL 并返回⽤户模式</p>
<h2 id="3-5-虚拟内存"><a href="#3-5-虚拟内存" class="headerlink" title="3.5 虚拟内存"></a>3.5 虚拟内存</h2><h3 id="3-5-1-虚拟内存？使⽤虚拟内存的优点？什么是虚拟地址空间？"><a href="#3-5-1-虚拟内存？使⽤虚拟内存的优点？什么是虚拟地址空间？" class="headerlink" title="3.5.1 虚拟内存？使⽤虚拟内存的优点？什么是虚拟地址空间？"></a>3.5.1 虚拟内存？使⽤虚拟内存的优点？什么是虚拟地址空间？</h3><ol>
<li>虚拟内存，虚拟内存是⼀种内存管理技术，它会使程序⾃⼰认为⾃⼰拥有⼀块很⼤且连续的内存，然⽽，这个程</li>
</ol>
<p>序在内存中不是连续的，并且有些还会在磁盘上，在需要时进⾏数据交换;</p>
<ol start="2">
<li><p>优点：可以弥补物理内存⼤⼩的不⾜；⼀定程度的提⾼反应速度；减少对物理内存的读取从⽽保护内存延⻓内存使⽤寿命；</p>
</li>
<li><p>缺点：占⽤⼀定的物理硬盘空间；加⼤了对硬盘的读写；设置不得当会影响整机稳定性与速度。</p>
</li>
<li><p>虚拟地址空间是对于⼀个单⼀进程的概念，这个进程看到的将是地址从0000开始的整个内存空间。虚拟存储器是⼀个抽象概念，它为每⼀个进程提供了⼀个假象，好像每⼀个进程都在独占的使⽤主存。每个进程看到的存储器都是⼀致的，称为虚拟地址空间。从最低的地址看起：程序代码和数据，堆，共享库，栈，内核虚拟存储器。⼤多数计算机的字⻓都是32位，这就限制了虚拟地址空间为4GB</p>
</li>
</ol>
<h2 id="3-6-IO模型"><a href="#3-6-IO模型" class="headerlink" title="3.6 IO模型"></a>3.6 IO模型</h2><h1 id="四、RPC项目"><a href="#四、RPC项目" class="headerlink" title="四、RPC项目"></a>四、RPC项目</h1><h2 id="4-1-日志系统："><a href="#4-1-日志系统：" class="headerlink" title="4.1 日志系统："></a>4.1 日志系统：</h2><ul>
<li><strong>异步日志</strong>：日志异步打印，不阻塞当前线程。生产者只需要将日志信息放入buffer即可，消费者线程会按照一定时间频率自动将日志同步到磁盘文件中。</li>
<li><strong>日志级别</strong>：日志分级别打印，<strong>当设定级别高于待打印日志的级别时，日志打印是个空操作</strong>，无性能消耗。</li>
<li><strong>文件输出</strong>：日志支持可以输出到文件中，特别是在生产环境上，把日志打印到控制台可不是一个好方法。</li>
<li><strong>滚动日志</strong>：日志文件会自行滚动，当<strong>跨天</strong>或者<strong>单个文件超过一定大小</strong>后，会自动建立新的文件写入日志信息。</li>
<li><strong>崩溃处理</strong>：TinyRPC 的日志库处理了<strong>程序突然崩溃</strong>的情况，简单来说就是当程序崩溃退出前先将日志信息同步到磁盘文件上。这是非常重要的，如果缺失了崩溃那一瞬间的日志内容，那就很难排查具体原因。</li>
<li><strong>日志分类</strong>：TinyRPC 提供了两类日志类型，<strong>RPC 框架日志</strong>以及 <strong>APP 应用日志</strong>。RPC 框架日志以 rpc 后缀结尾，是 TinyRPC 框架在运行中打印的日志信息，通常用来监控框架本身的运行状态。APP 应用日志以 <strong>app</strong> 后缀结尾 专门用来处理用户请求，对于每一个客户端请求，APP 日志会打印出请求的 msg 作为标识。总的来说，如果你只是使用 TinyRPC，关注APP日志即可。</li>
</ul>
<h2 id="4-2-协程"><a href="#4-2-协程" class="headerlink" title="4.2 协程"></a>4.2 协程</h2><h3 id="4-2-1-进程、线程和协程"><a href="#4-2-1-进程、线程和协程" class="headerlink" title="4.2.1 进程、线程和协程"></a>4.2.1 进程、线程和协程</h3><p> a、进程是资源分配，每个进程拥有独立的资源空间，因为进程不共享资源，所以就涉及到进程间通信的方式，常见的方式有：消息队列、管道、信号量、socket套接字等。（这里会引申出几个面试题：<strong>进程间有通信方式有哪些？-&gt; 使用过哪些消息队列？</strong>）</p>
<p>b、线程（英语：thread）是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。线程是在进程下，所以同一进程下的多个线程是能共享资源的。线程能共享的资源有：堆、全局变量、文件描述符和信号处理等，不共享的资源：栈、寄存器等（这里会引申出的面试题：<strong>多线程怎么实现？-&gt; 多线程并发问题 -&gt; 多线程共享哪些资源</strong>）</p>
<p>c、协程是单线程下实现多任务，它通过 yield 关键字来实现，能有效地减少多线程之间切换的开销。它是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。</p>
<h3 id="4-2-2-协程原语"><a href="#4-2-2-协程原语" class="headerlink" title="4.2.2 协程原语"></a>4.2.2 协程原语</h3><ul>
<li>对称协程 :  <strong>由任意一个协程切换到任意另外一个协程</strong>。</li>
<li>非对称协程 ：<strong>从一个协程切换到新协程后，新协程就只能返回到原调用方协程</strong>，一般都需要一个<strong>主协程</strong>。</li>
</ul>
<h3 id="4-2-3-线程-协程模型"><a href="#4-2-3-线程-协程模型" class="headerlink" title="4.2.3 线程:协程模型"></a>4.2.3 线程:协程模型</h3><p>m 个线程共同调度 n 个协程，由于 m 个线程共用一个协程池，因此协程池里的就绪任务总会尽快的被 <strong>Resume</strong>。</p>
<h2 id="4-3-TCPServer"><a href="#4-3-TCPServer" class="headerlink" title="4.3 TCPServer"></a>4.3 TCPServer</h2><h2 id="4-4-TcpConnection"><a href="#4-4-TcpConnection" class="headerlink" title="4.4 TcpConnection"></a>4.4 TcpConnection</h2><h1 id="五-数据结构"><a href="#五-数据结构" class="headerlink" title="五 数据结构"></a>五 数据结构</h1><h2 id="5-1-树"><a href="#5-1-树" class="headerlink" title="5.1 树"></a>5.1 树</h2><h3 id="5-1-1-说⼀下平衡⼆叉树、⾼度平衡⼆叉树（AVL）"><a href="#5-1-1-说⼀下平衡⼆叉树、⾼度平衡⼆叉树（AVL）" class="headerlink" title="5.1.1 说⼀下平衡⼆叉树、⾼度平衡⼆叉树（AVL）"></a>5.1.1 说⼀下平衡⼆叉树、⾼度平衡⼆叉树（AVL）</h3><p>⼆叉树：任何节点最多只允许有两个⼦节点，称为左⼦节点和右⼦节点，以递归的⽅式定义⼆叉树为，⼀个⼆叉树如果不为空，便是由⼀个根节点和左右两个⼦树构成，左右⼦树都可能为空。</p>
<p>⼆叉搜索树：⼆叉搜索树可以<strong>提供对数时间的元素插⼊和访问</strong>。节点的放置规则是：任何节点的键值⼀定⼤于其左⼦树的每⼀个节点的键值，并⼩于其右⼦树中的每⼀个节点的键值。因此⼀直向左⾛可以取得最⼩值，⼀直向右⾛可以得到最⼤值。插⼊：从根节点开始，遇键值较⼤则向左，遇键值较⼩则向右，直到尾端，即插⼊点。删除：如果删除点只有⼀个⼦节点，则直接将其⼦节点连⾄⽗节点。如果删除点有两个⼦节点，以右⼦树中的最⼩值代替要删除的位置。</p>
<p>平衡⼆叉树：其实对于树的平衡与否没有⼀个绝对的标准，“平衡”的⼤致意 思是：没有任何⼀个节点过深，不同的平衡条件会造就出不同的效率表现。以及不同的实现复杂度。有数种特殊结构例如 AVL-tree, RB-tree, AA-tree，均可以实现平衡⼆叉树。</p>
<p>AVL-tree ：⾼度平衡的平衡⼆叉树（严格的平衡⼆叉树）AVL-tree 是要求任何节点的左右⼦树⾼度相差最多为 1的平衡⼆叉树。 当插⼊新的节点破坏平衡性的时候，从下往上找到第⼀个不平衡点，需要进⾏单旋转，或者双旋转进⾏调整。</p>
<h3 id="5-1-2-说⼀下红⿊树（RB-tree）"><a href="#5-1-2-说⼀下红⿊树（RB-tree）" class="headerlink" title="5.1.2 说⼀下红⿊树（RB-tree）"></a>5.1.2 说⼀下红⿊树（RB-tree）</h3><p>红⿊树的定义：</p>
<p><strong>性质1：</strong>每个节点要么是⿊⾊，要么是红⾊。</p>
<p><strong>性质2：</strong>根节点是⿊⾊。</p>
<p><strong>性质3：</strong>每个叶⼦节点（NIL）是⿊⾊。</p>
<p><strong>性质4：</strong>每个红⾊结点的两个⼦结点⼀定都是⿊⾊。</p>
<p><strong>性质5：</strong>任意⼀结点到每个叶⼦结点的路径都包含数ᰁ相同的⿊结点。</p>
<h3 id="5-1-3-二叉树的前序遍历"><a href="#5-1-3-二叉树的前序遍历" class="headerlink" title="5.1.3 二叉树的前序遍历"></a>5.1.3 二叉树的前序遍历</h3><h3 id="5-1-4-二叉树的中序遍历"><a href="#5-1-4-二叉树的中序遍历" class="headerlink" title="5.1.4 二叉树的中序遍历"></a>5.1.4 二叉树的中序遍历</h3><h3 id="5-1-5-二叉树的后序遍历"><a href="#5-1-5-二叉树的后序遍历" class="headerlink" title="5.1.5 二叉树的后序遍历"></a>5.1.5 二叉树的后序遍历</h3><h2 id="5-2-十大排序"><a href="#5-2-十大排序" class="headerlink" title="5.2 十大排序"></a>5.2 十大排序</h2><p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913124950727.png" alt="image-20220913124950727"></p>
<h3 id="5-2-1-冒泡排序"><a href="#5-2-1-冒泡排序" class="headerlink" title="5.2.1 冒泡排序"></a>5.2.1 冒泡排序</h3><p>算法描述：</p>
<ul>
<li>⽐较相邻的元素。如果第⼀个⽐第⼆个⼤，就交换它们两个；</li>
<li>对每⼀对相邻元素作同样的⼯作，从开始第⼀对到结尾的最后⼀对，这样在最后的元素应该会是最⼤的数；</li>
<li>针对所有的元素᯿复以上的步骤，除了最后⼀个；</li>
<li>重复步骤 1~3，直到排序完成。</li>
</ul>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913125506704.png" alt="image-20220913125506704"></p>
<p>可以看出，经过⼀次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进⾏ 6 次这样的冒泡操作就⾏了。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913125604315.png" alt="image-20220913125604315"></p>
<h3 id="5-2-2-插入排序"><a href="#5-2-2-插入排序" class="headerlink" title="5.2.2 插入排序"></a>5.2.2 插入排序</h3><p>算法描述：分为已排序和未排序 初始已排序区间只有⼀个元素 就是数组第⼀个 遍历未排序的每⼀个元素在已排序区间⾥找到合适的位置插⼊并保证数据⼀直有序。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913125627944.png" alt="image-20220913125627944"></p>
<h3 id="5-2-3-选择排序"><a href="#5-2-3-选择排序" class="headerlink" title="5.2.3 选择排序"></a>5.2.3 选择排序</h3><p>算法描述：分已排序区间和未排序区间。每次会从未排序区间中找到最⼩的元素，将其放到已排序区间的末尾。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913125712735.png" alt="image-20220913125712735"></p>
<h3 id="5-2-4-快排排序"><a href="#5-2-4-快排排序" class="headerlink" title="5.2.4 快排排序"></a>5.2.4 快排排序</h3><p>算法描述：先找到⼀个枢纽；在原来的元素⾥根据这个枢纽划分 ⽐这个枢纽⼩的元素排前⾯；⽐这个枢纽⼤的元素排后⾯；两部分数据依次递归排序下去直到最终有序。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913125822546.png" alt="image-20220913125822546"></p>
<h3 id="5-2-5-归并排序"><a href="#5-2-5-归并排序" class="headerlink" title="5.2.5 归并排序"></a>5.2.5 归并排序</h3><p>算法描述：归并排序是⼀个稳定的排序算法，归并排序的时间复杂度任何情况下都是 <code>O(nlogn)</code>，归并排序不是原地</p>
<p>排序算法</p>
<p>⽤两个游标<code> i</code> 和 <code>j</code>，分别指向 <code>A[p…q]</code> 和 <code>A[q+1…r]</code>的第⼀个元素。⽐较这两个元素 <code>A[i] </code>和 <code>A[j]</code>，如果 <code>A[i]&lt;=A[j]</code>，我们就把 A[i] 放⼊到临时数组 <code>tmp</code>，并且<code> i</code> 后移⼀位，否则将<code>A[j]</code>放⼊到数组 <code>tmp</code>，<code>j </code>后移⼀位。</p>
<p><img src="C:\Users\wangq\AppData\Roaming\Typora\typora-user-images\image-20220913130004642.png" alt="image-20220913130004642"></p>
<h3 id="5-2-6-堆排序"><a href="#5-2-6-堆排序" class="headerlink" title="5.2.6 堆排序"></a>5.2.6 堆排序</h3><p>算法描述：利⽤堆这种数据结构所设计的⼀种排序算法。堆积是⼀个近似完全⼆叉树的结构，并同时满⾜堆积的性</p>
<p>质：即⼦结点的键值或索引总是⼩于（或者⼤于）它的⽗节点。堆排序可以⽤到上⼀次的排序结果，所以不像其他</p>
<p>⼀般的排序⽅法⼀样，每次都要进⾏ n-1 次的⽐较，复杂度为<code>O(nlogn)</code>。</p>
<p>算法步骤：</p>
<ol>
<li>利⽤给定数组创建⼀个堆 H[0..n-1]（我们这⾥使⽤最⼩堆），输出堆顶元素</li>
<li>以最后⼀个元素代替堆顶，调整成堆，输出堆顶元素</li>
<li>把堆的尺⼨缩⼩ 1</li>
<li>重复步骤 2，直到堆的尺⼨为 1</li>
</ol>
<p>建堆：将数组原地建成⼀个堆，不借助额外的空间，采⽤从上往下的堆化（对于完全⼆叉树来说，下标是 n/2+1 到n 的节点都是叶⼦节点，不需要堆化）。</p>
<p>排序：”删除堆顶元素“：当堆顶元素移除之后，把下标为 n 的元素放到堆顶，然后在通过堆化的⽅法，将剩下的 n -1 个元素重新构建成堆，堆化完成之后，在取堆顶的元素，放到下标为 n-1 的位置，⼀直重复这个过程，直到最后堆中只剩下标 1 的⼀个元素。</p>
<h3 id="5-2-7-桶排序"><a href="#5-2-7-桶排序" class="headerlink" title="5.2.7 桶排序"></a>5.2.7 桶排序</h3><p>算法描述：将数组分到有限数量的桶⾥。每个桶再个别排序（有可能再使⽤别的排序算法或是以递归⽅式继续使⽤桶排序进⾏排序）</p>
<h3 id="5-2-8-计数排序"><a href="#5-2-8-计数排序" class="headerlink" title="5.2.8  计数排序"></a>5.2.8  计数排序</h3><p>扩展：如果在⾯试中有⾯试官要求你写⼀个 <code>O(n) </code>时间复杂度的排序算法，可不要傻乎乎的说这不可能！虽然前⾯基于⽐较的排序的下限是<code>O(nlogn)</code>。但是确实也有线性时间复杂度的排序，只不过有前提条件，就是待排序的数要满⾜⼀定的范围的整数，⽽且计数排序需要⽐较多的辅助空间。</p>
<p>算法描述：其基本思想是，⽤待排序的数作为计数数组的下标，统计每个数字的个数。然后依次输出即可得到有序序列。</p>
<p>假设有 8 个考⽣，分数在 0 到 5 分之间。这 8 个考⽣的成绩我们放在⼀个数组 A[8]中，它们分别是：2，5，3， 0，2，3，0，3。</p>
<p>考⽣的成绩从 0 到 5 分，我们使⽤⼤⼩为 6 的数组 C[6]表示桶，其中下标对应分数。不过，C[6]内存储的并不是考⽣，⽽是对应的考⽣个数。像我刚刚举的那个例⼦，我们只需要遍历⼀遍考⽣分数，就可以得到 C[6]的值。</p>
<h3 id="5-2-9-基数排序"><a href="#5-2-9-基数排序" class="headerlink" title="5.2.9  基数排序"></a>5.2.9  基数排序</h3><p>算法描述：基数排序对要排序的数据是有要求的，需要可以分割出独⽴的“位”来⽐较，⽽且位之间有递进的关系，如果 a 数据的⾼位⽐ b 数据⼤，那剩下的低位就不⽤⽐较了。除此之外，每⼀位的数据范围不能太⼤，要可以⽤线性排序算法来排序，否则，基数排序的时间复杂度就⽆法做到 O(n) 了。</p>
<p>基数排序相当于通过循环进⾏了多次桶排序。</p>
<h3 id="5-2-10-基数排序"><a href="#5-2-10-基数排序" class="headerlink" title="5.2.10  基数排序"></a>5.2.10  基数排序</h3><p>算法描述：通过将⽐较的全部元素分为⼏个区域来提升插⼊排序的性能。这样可以让⼀个元素可以⼀次性地朝最终位置前进⼀⼤步。然后算法再取越来越⼩的步⻓进⾏排序，算法的最后⼀步就是普通的插⼊排序，但是到了这步，需排序的数据⼏乎是已排好的了</p>

        </div>

        

        

        
            <div class="article-nav">
                
                    <div class="article-prev">
                        <a class="prev"
                           rel="prev"
                           href="/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/20220813%E7%BE%8E%E5%9B%A2%E7%AC%94%E8%AF%95/"
                        >
                            <span class="left arrow-icon flex-center">
                              <i class="fas fa-chevron-left"></i>
                            </span>
                            <span class="title flex-center">
                                <span class="post-nav-title-item">美团笔试</span>
                                <span class="post-nav-item">Prev posts</span>
                            </span>
                        </a>
                    </div>
                
                
                    <div class="article-next">
                        <a class="next"
                           rel="next"
                           href="/c/"
                        >
                            <span class="title flex-center">
                                <span class="post-nav-title-item">C++</span>
                                <span class="post-nav-item">Next posts</span>
                            </span>
                            <span class="right arrow-icon flex-center">
                              <i class="fas fa-chevron-right"></i>
                            </span>
                        </a>
                    </div>
                
            </div>
        

        
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">王秋鹏</a>
        </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    
        <div class="post-tools">
            <div class="post-tools-container">
    <ul class="tools-list">
        <!-- TOC aside toggle -->
        
            <li class="tools-item page-aside-toggle">
                <i class="fas fa-outdent"></i>
            </li>
        

        <!-- go comment -->
        
    </ul>
</div>

        </div>
    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    
        <aside class="page-aside">
            <div class="post-toc-wrap">
    <div class="post-toc">
        <ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%80-C"><span class="nav-text">一 C++</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="nav-text">1.1 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-static"><span class="nav-text">1.1.1 static</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-const"><span class="nav-text">1.1.2 const</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-volatile"><span class="nav-text">1.1.3 volatile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-4-extern"><span class="nav-text">1.1.4 extern</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-5-define"><span class="nav-text">1.1.5 define</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-7-define%E5%92%8Cconst%E5%8C%BA%E5%88%AB"><span class="nav-text">1.1.7 define和const区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88"><span class="nav-text">1.2 智能指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-auto-ptr"><span class="nav-text">1.2.1 auto_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-unique-ptr"><span class="nav-text">1.2.2 unique_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-shared-ptr"><span class="nav-text">1.2.3  shared_ptr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-4-weak-ptr"><span class="nav-text">1.2.4 weak_ptr</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="nav-text">1.3 C++ 中内存分配情况</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-C-%E4%B8%AD%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%83%85%E5%86%B5"><span class="nav-text">1.3.1 C++ 中内存分配情况</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-%E8%AF%B4%E2%BC%80%E4%B8%8BC-%E2%BE%A5%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E7%9A%84%EF%BC%9F%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E5%9C%A8%E5%86%85%E5%AD%98%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BD%8D%E7%BD%AE%EF%BC%9F"><span class="nav-text">1.3.2 说⼀下C++⾥是怎么定义常量的？常量存放在内存的哪个位置？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-new-delete-malloc-free-%E5%8C%BA%E5%88%AB"><span class="nav-text">1.3.3 new&#x2F;delete , malloc&#x2F;free 区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-%E7%BB%93%E6%9E%84%E4%BD%93%E5%86%85%E5%AD%98%E5%AF%B9%E2%BB%AC%E2%BD%85%E5%BC%8F%E5%92%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E2%BE%8F%E5%86%85%E5%AD%98%E5%AF%B9%E2%BB%AC%EF%BC%9F"><span class="nav-text">1.3.4 结构体内存对⻬⽅式和为什么要进⾏内存对⻬？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5%E3%80%81%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%8C%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E4%B8%8E%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-text">1.3.5、内存泄漏的定义，如何检测与避免？**</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-C-%E4%B8%8E%E5%85%B6%E4%BB%96%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.4 C++与其他语言的区别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-1-C-%E4%B8%8EC%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.4.1 C++与C的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-2-C-%E4%B8%8EJAVA%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.4.2 C++与JAVA的区别</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-5-C-%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%BC%BA%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="nav-text">1.5 C++的四种强制转换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-6-%E6%8C%87%E9%92%88"><span class="nav-text">1.6 指针</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-1-%E6%8C%87%E9%92%88%E5%92%8C%E5%BC%95%E7%94%A8%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.6.1 指针和引用的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-2-%E9%87%8E%E6%8C%87%E9%92%88%E4%B8%8E%E6%82%AC%E7%A9%BA%E6%8C%87%E9%92%88%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D%EF%BC%9F"><span class="nav-text">1.6.2 野指针与悬空指针有什么区别？如何避免？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-3-%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88"><span class="nav-text">1.6.3 函数指针</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-7-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3"><span class="nav-text">1.7 虚函数相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-1-%E8%99%9A%E5%87%BD%E6%95%B0%E7%9B%B8%E5%85%B3%EF%BC%88%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%89%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="nav-text">1.7.1 虚函数相关（虚函数表，虚函数指针），虚函数的实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-2-%E7%BC%96%E8%AF%91%E5%99%A8%E5%A4%84%E7%90%86%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8%E5%BA%94%E8%AF%A5%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86"><span class="nav-text">1.7.2 编译器处理虚函数表应该如何处理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-3%E3%80%81%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0-%EF%BC%88%E5%BA%94%E2%BD%A4%E4%BA%8E%E6%8E%A5%E2%BC%9D%E7%BB%A7%E6%89%BF%E5%92%8C%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF"><span class="nav-text">1.7.3、纯虚函数 （应⽤于接⼝继承和实现继承)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-8-C-%E4%B8%AD%E9%87%8D%E8%BD%BD%E5%92%8C%E9%87%8D%E5%86%99%E3%80%81%E9%87%8D%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">1.8 C++中重载和重写、重定义的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-9-%E4%BB%8B%E7%BB%8D-C-%E6%89%80%E6%9C%89%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1.9 介绍 C++ 所有的构造函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-10-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-text">1.10 面向对象的三大特性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-1-%E5%B0%81%E8%A3%85"><span class="nav-text">1.10.1 封装</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-2-%E7%BB%A7%E6%89%BF"><span class="nav-text">1.10.2 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-3-%E5%A4%9A%E6%80%81"><span class="nav-text">1.10.3 多态</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-10-4-%E5%A4%9A%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-text">1.10.4 多态的实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-11%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-text">1.11析构函数和构造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-1-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E2%BC%80%E8%88%AC%E5%86%99%E6%88%90%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="nav-text">1.11.1 析构函数⼀般写成虚函数的原因</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-2-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%BA%E4%BB%80%E4%B9%88%E2%BC%80%E8%88%AC%E4%B8%8D%E5%AE%9A%E4%B9%89%E4%B8%BA%E8%99%9A%E5%87%BD%E6%95%B0"><span class="nav-text">1.11.2 构造函数为什么⼀般不定义为虚函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-3%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E4%B8%AD%E8%B0%83%E2%BD%A4%E8%99%9A%E5%87%BD%E6%95%B0%E4%BC%9A%E6%80%8E%E6%A0%B7"><span class="nav-text">1.11.3、构造函数或析构函数中调⽤虚函数会怎样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-4-%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E2%BD%A4%EF%BC%8C%E5%A6%82%E4%BD%95%E8%B5%B7%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="nav-text">1.11.4 析构函数的作⽤，如何起作⽤？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-5%E3%80%81%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E2%BE%8F%E9%A1%BA%E5%BA%8F%EF%BC%9F%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A7%E2%BE%8F%E9%A1%BA%E5%BA%8F%EF%BC%9F"><span class="nav-text">1.11.5、构造函数的执⾏顺序？析构函数的执⾏顺序？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-6%E3%80%81%E4%BB%80%E4%B9%88%E6%83%85%E5%86%B5%E4%B8%8B%E4%BC%9A%E8%B0%83%E2%BD%A4%E6%8B%B7%E2%BB%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0-%E4%B8%89%E7%A7%8D%E6%83%85%E5%86%B5"><span class="nav-text">1.11.6、什么情况下会调⽤拷⻉构造函数(三种情况)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-11-7%E3%80%81%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8B%B7%E2%BB%89%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%BF%85%E9%9C%80%E6%97%B6%E5%BC%95%E2%BD%A4%E4%BC%A0%E9%80%92%EF%BC%8C%E4%B8%8D%E8%83%BD%E6%98%AF%E5%80%BC%E4%BC%A0%E9%80%92%EF%BC%9F"><span class="nav-text">1.11.7、为什么拷⻉构造函数必需时引⽤传递，不能是值传递？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-12-%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%92%8C%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="nav-text">1.12 静态绑定和动态绑定的介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-13-%E6%B7%B1%E6%8B%B7%E2%BB%89%E5%92%8C%E6%B5%85%E6%8B%B7%E2%BB%89%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E4%B8%BE%E4%BE%8B%E8%AF%B4%E6%98%8E%E6%B7%B1%E6%8B%B7%E2%BB%89%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%89"><span class="nav-text">1.13 深拷⻉和浅拷⻉的区别（举例说明深拷⻉的安全性）</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%8C%E3%80%81%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="nav-text">二、网络编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-HTTP%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">2.1 HTTP常见面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-HTTP%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="nav-text">2.1.1 HTTP基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-HTTP-%E5%B8%B8%E8%A7%81%E7%9A%84%E7%8A%B6%E6%80%81%E7%A0%81%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2.1.2 HTTP 常见的状态码有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-HTTP-%E5%B8%B8%E8%A7%81%E5%AD%97%E6%AE%B5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2.1.3 HTTP 常见字段有哪些？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-GET-%E4%B8%8E-POST"><span class="nav-text">2.1.4 GET 与 POST</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-GET-%E5%92%8C-POST-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">1 GET 和 POST 有什么区别？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-GET-%E5%92%8C-POST-%E6%96%B9%E6%B3%95%E9%83%BD%E6%98%AF%E5%AE%89%E5%85%A8%E5%92%8C%E5%B9%82%E7%AD%89%E7%9A%84%E5%90%97%EF%BC%9F"><span class="nav-text">2 GET 和 POST 方法都是安全和幂等的吗？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-5-HTTP%E7%BC%93%E5%AD%98%E6%8A%80%E6%9C%AF"><span class="nav-text">2.1.5 HTTP缓存技术</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-6-HTTP-%E7%89%B9%E6%80%A7"><span class="nav-text">2.1.6 HTTP 特性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-HTTP%EF%BC%881-1%EF%BC%89-%E7%9A%84%E4%BC%98%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">1. HTTP（1.1） 的优点有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-HTTP%EF%BC%881-1%EF%BC%89-%E7%9A%84%E7%BC%BA%E7%82%B9%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="nav-text">2.HTTP（1.1） 的缺点有哪些？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-HTTP-1-1-%E7%9A%84%E6%80%A7%E8%83%BD%E5%A6%82%E4%BD%95%EF%BC%9F"><span class="nav-text">3. HTTP&#x2F;1.1 的性能如何？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-7-HTTP%E4%B8%8EHTTPS"><span class="nav-text">2.1.7 HTTP与HTTPS</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-HTTP%E4%B8%8EHTTPS%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="nav-text">1.HTTP与HTTPS有哪些区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-HTTPS%E8%A7%A3%E5%86%B3%E4%BA%86HTTP%E7%9A%84%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="nav-text">2.HTTPS解决了HTTP的哪些问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-TCP-%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="nav-text">2.2 TCP 常见面试题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-1-TCP%E5%A4%B4%E6%A0%BC%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="nav-text">2.2.1 TCP头格式有哪些?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81TCP%E5%8D%8F%E8%AE%AE%EF%BC%9FTCP%E5%B7%A5%E4%BD%9C%E5%9C%A8%E5%93%AA%E4%B8%80%E5%B1%82%EF%BC%9F"><span class="nav-text">2.2.2 为什么需要TCP协议？TCP工作在哪一层？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-3-%E4%BB%80%E4%B9%88%E6%98%AF-TCP-%EF%BC%9F"><span class="nav-text">2.2.3 什么是 TCP ？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-4-%E4%BB%80%E4%B9%88%E6%98%AFTCP%E8%BF%9E%E6%8E%A5"><span class="nav-text">2.2.4  什么是TCP连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-5-%E5%A6%82%E4%BD%95%E5%94%AF%E4%B8%80%E7%A1%AE%E5%AE%9A%E4%B8%80%E4%B8%AATCP%E8%BF%9E%E6%8E%A5%E5%91%A2%EF%BC%9F"><span class="nav-text">2.2.5 如何唯一确定一个TCP连接呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-6-UDP%E5%92%8CTCP%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E5%91%A2%EF%BC%9F%E5%88%86%E5%88%AB%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF"><span class="nav-text">2.2.6 UDP和TCP有什么区别呢？分别的应用场景是?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-7-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-text">2.2.7 TCP三次握手过程是怎么样的？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-8-%E5%A6%82%E4%BD%95%E5%9C%A8Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%9F%A5%E7%9C%8BTCP%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="nav-text">2.2.8 如何在Linux系统中查看TCP状态？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-9-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%EF%BC%9F%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E3%80%81%E5%9B%9B%E6%AC%A1%EF%BC%9F"><span class="nav-text">2.2.9 为什么是三次握手？不是两次、四次？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-10-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AF%8F%E6%AC%A1%E5%BB%BA%E7%AB%8B-TCP-%E8%BF%9E%E6%8E%A5%E6%97%B6%EF%BC%8C%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E5%BA%8F%E5%88%97%E5%8F%B7%E9%83%BD%E8%A6%81%E6%B1%82%E4%B8%8D%E4%B8%80%E6%A0%B7%E5%91%A2%EF%BC%9F"><span class="nav-text">2.2.10 为什么每次建立 TCP 连接时，初始化的序列号都要求不一样呢？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-11-TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E8%BF%87%E7%A8%8B"><span class="nav-text">2.2.11 TCP四次挥手过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-12-TCP-%E9%87%8D%E4%BC%A0%E3%80%81%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E3%80%81%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E3%80%81%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="nav-text">2.2.12 TCP 重传、滑动窗口、流量控制、拥塞控制</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%89%E3%80%81%E7%B3%BB%E7%BB%9F%E7%BC%96%E7%A8%8B"><span class="nav-text">三、系统编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9"><span class="nav-text">3.1 操作系统特点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E8%BF%9B%E7%A8%8B"><span class="nav-text">3.2 进程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E8%BF%9B%E7%A8%8B"><span class="nav-text">3.2.2 进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B"><span class="nav-text">3.2.2 什么是进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.2.2 进程与线程的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%9B%BE"><span class="nav-text">3.2.3 进程状态转换图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%EF%BC%9F%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E5%87%BD%E6%95%B0%EF%BC%9F%E9%9C%80%E8%A6%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">3.2.4 进程的创建过程？需要哪些函数？需要哪些数据结构?</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E2%BC%A6%E8%BF%9B%E7%A8%8B-fork%E8%AF%A6%E8%A7%A3"><span class="nav-text">3.2.5 进程创建⼦进程,fork详解</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-%E2%BC%A6%E8%BF%9B%E7%A8%8B%E5%92%8C%E2%BD%97%E8%BF%9B%E7%A8%8B%E6%80%8E%E4%B9%88%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="nav-text">3.2.6 ⼦进程和⽗进程怎么通信？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-7-%E8%BF%9B%E7%A8%8B%E5%92%8C%E4%BD%9C%E4%B8%9A%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-text">3.2.7 进程和作业的区别？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-8-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E2%BD%85%E5%BC%8F%E6%9C%89%E2%BC%8F%E7%A7%8D%EF%BC%8C%E4%BB%96%E4%BB%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">3.2.8 进程间通信⽅式有⼏种，他们之间的区别是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-9-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E2%BD%85%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E2%BD%A4%EF%BC%9F"><span class="nav-text">3.2.9 线程同步的⽅式？怎么⽤？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-10-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E7%9A%84%E2%BD%85%E5%BC%8F%EF%BC%9F%E6%80%8E%E4%B9%88%E2%BD%A4%EF%BC%9F"><span class="nav-text">3.2.10 线程同步的⽅式？怎么⽤？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-11-%E5%AD%A4%E2%BC%89%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E2%BC%AB%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E8%BF%99%E4%B8%A4%E7%B1%BB%E8%BF%9B%E7%A8%8B%EF%BC%9F%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="nav-text">3.2.11 孤⼉进程和僵⼫进程的区别？怎么避免这两类进程？守护进程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-12-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">3.2.12 守护进程是什么？怎么实现？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-13-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E7%9A%84%E8%B5%84%E6%BA%90%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">3.2.13 线程和进程的区别？线程共享的资源是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-14-%E7%BA%BF%E7%A8%8B%E2%BD%90%E8%BF%9B%E7%A8%8B%E5%85%B7%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BC%98%E5%8A%BF%EF%BC%9F"><span class="nav-text">3.2.14 线程⽐进程具有哪些优势？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-15-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E2%BD%A4%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E2%BD%A4%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="nav-text">3.2.15 什么时候⽤多进程？什么时候⽤多线程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-16-%E5%8D%8F%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-text">3.2.16 协程是什么？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-17-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="nav-text">3.2.17  线程安全？如何实现？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E9%94%81"><span class="nav-text">3.3 锁</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1%E6%AD%BB%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6%EF%BC%9F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="nav-text">3.3.1死锁是什么？必要条件？如何解决？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E9%80%92%E5%BD%92%E9%94%81%EF%BC%9F"><span class="nav-text">3.3.2 递归锁？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E4%B8%AD%E6%96%AD"><span class="nav-text">3.4 中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-%E2%BD%A4%E6%88%B7%E6%80%81%E5%88%B0%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E8%BD%AC%E5%8C%96%E5%8E%9F%E7%90%86%EF%BC%9F"><span class="nav-text">3.4.1 ⽤户态到内核态的转化原理？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E4%BD%9C%E2%BD%A4%EF%BC%8C%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="nav-text">3.4.2 中断的实现与作⽤，中断的实现过程？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-3-%E7%B3%BB%E7%BB%9F%E4%B8%AD%E6%96%AD%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E2%BD%A4%E6%88%B7%E6%80%81%E5%92%8C%E5%86%85%E6%A0%B8%E6%80%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="nav-text">3.4.3 系统中断是什么，⽤户态和内核态的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-4-CPU%E4%B8%AD%E6%96%AD"><span class="nav-text">3.4.4 CPU中断</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-5-CPU%E4%B8%AD%E6%96%AD"><span class="nav-text">3.4.5 CPU中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="nav-text">3.5 虚拟内存</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%EF%BC%9F%E4%BD%BF%E2%BD%A4%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%EF%BC%9F"><span class="nav-text">3.5.1 虚拟内存？使⽤虚拟内存的优点？什么是虚拟地址空间？</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-IO%E6%A8%A1%E5%9E%8B"><span class="nav-text">3.6 IO模型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E3%80%81RPC%E9%A1%B9%E7%9B%AE"><span class="nav-text">四、RPC项目</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A"><span class="nav-text">4.1 日志系统：</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-%E5%8D%8F%E7%A8%8B"><span class="nav-text">4.2 协程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%8F%E7%A8%8B"><span class="nav-text">4.2.1 进程、线程和协程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-%E5%8D%8F%E7%A8%8B%E5%8E%9F%E8%AF%AD"><span class="nav-text">4.2.2 协程原语</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="nav-text">4.2.3 线程:协程模型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-TCPServer"><span class="nav-text">4.3 TCPServer</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-TcpConnection"><span class="nav-text">4.4 TcpConnection</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%94-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-text">五 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-%E6%A0%91"><span class="nav-text">5.1 树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-%E8%AF%B4%E2%BC%80%E4%B8%8B%E5%B9%B3%E8%A1%A1%E2%BC%86%E5%8F%89%E6%A0%91%E3%80%81%E2%BE%BC%E5%BA%A6%E5%B9%B3%E8%A1%A1%E2%BC%86%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="nav-text">5.1.1 说⼀下平衡⼆叉树、⾼度平衡⼆叉树（AVL）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-%E8%AF%B4%E2%BC%80%E4%B8%8B%E7%BA%A2%E2%BF%8A%E6%A0%91%EF%BC%88RB-tree%EF%BC%89"><span class="nav-text">5.1.2 说⼀下红⿊树（RB-tree）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%89%8D%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.1.3 二叉树的前序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.1.4 二叉树的中序遍历</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-5-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="nav-text">5.1.5 二叉树的后序遍历</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2 十大排序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.1 冒泡排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.2 插入排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.3 选择排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-4-%E5%BF%AB%E6%8E%92%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.4 快排排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-5-%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.5 归并排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-6-%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.6 堆排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-7-%E6%A1%B6%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.7 桶排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-8-%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.8  计数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-9-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.9  基数排序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-10-%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="nav-text">5.2.10  基数排序</span></a></li></ol></li></ol></li></ol>
    </div>
</div>
        </aside>
    

    <div class="image-viewer-container">
    <img src="">
</div>


    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>








<div class="post-scripts pjax">
    
        
<script src="/js/left-side-toggle.js"></script>

<script src="/js/libs/anime.min.js"></script>

<script src="/js/toc.js"></script>

    
</div>


    
<script src="/js/libs/pjax.min.js"></script>

<script>
    window.addEventListener('DOMContentLoaded', () => {
        window.pjax = new Pjax({
            selectors: [
                'head title',
                '.page-container',
                '.pjax'
            ],
            history: true,
            debug: false,
            cacheBust: false,
            timeout: 0,
            analytics: false,
            currentUrlFullReload: false,
            scrollRestoration: false,
            // scrollTo: true,
        });

        document.addEventListener('pjax:send', () => {
            KEEP.utils.pjaxProgressBarStart();
        });

        document.addEventListener('pjax:complete', () => {
            KEEP.utils.pjaxProgressBarEnd();
            window.pjax.executeScripts(document.querySelectorAll('script[data-pjax], .pjax script'));
            KEEP.refresh();
        });
    });
</script>



</body>
</html>
